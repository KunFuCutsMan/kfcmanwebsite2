var er = Object.defineProperty;
var Xe = (d) => {
  throw TypeError(d);
};
var rr = (d, m, g) => m in d ? er(d, m, { enumerable: !0, configurable: !0, writable: !0, value: g }) : d[m] = g;
var re = (d, m, g) => rr(d, typeof m != "symbol" ? m + "" : m, g), ir = (d, m, g) => m.has(d) || Xe("Cannot " + g);
var pe = (d, m, g) => (ir(d, m, "read from private field"), g ? g.call(d) : m.get(d)), xe = (d, m, g) => m.has(d) ? Xe("Cannot add the same private member more than once") : m instanceof WeakSet ? m.add(d) : m.set(d, g);
const DEV = !1;
var is_array = Array.isArray, index_of = Array.prototype.indexOf, array_from = Array.from, define_property = Object.defineProperty, get_descriptor = Object.getOwnPropertyDescriptor, get_descriptors = Object.getOwnPropertyDescriptors, object_prototype = Object.prototype, array_prototype = Array.prototype, get_prototype_of = Object.getPrototypeOf, is_extensible = Object.isExtensible;
function is_function(d) {
  return typeof d == "function";
}
const noop = () => {
};
function is_promise(d) {
  return typeof (d == null ? void 0 : d.then) == "function";
}
function run(d) {
  return d();
}
function run_all(d) {
  for (var m = 0; m < d.length; m++)
    d[m]();
}
const DERIVED = 2, EFFECT = 4, RENDER_EFFECT = 8, BLOCK_EFFECT = 16, BRANCH_EFFECT = 32, ROOT_EFFECT = 64, BOUNDARY_EFFECT = 128, UNOWNED = 256, DISCONNECTED = 512, CLEAN = 1024, DIRTY$1 = 2048, MAYBE_DIRTY = 4096, INERT = 8192, DESTROYED = 16384, EFFECT_RAN = 32768, EFFECT_TRANSPARENT = 65536, LEGACY_DERIVED_PROP = 1 << 17, HEAD_EFFECT = 1 << 19, EFFECT_HAS_DERIVED = 1 << 20, EFFECT_IS_UPDATING = 1 << 21, STATE_SYMBOL = Symbol("$state"), LEGACY_PROPS = Symbol("legacy props"), LOADING_ATTR_SYMBOL = Symbol("");
function equals(d) {
  return d === this.v;
}
function safe_not_equal(d, m) {
  return d != d ? m == m : d !== m || d !== null && typeof d == "object" || typeof d == "function";
}
function safe_equals(d) {
  return !safe_not_equal(d, this.v);
}
function effect_in_teardown(d) {
  throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function effect_in_unowned_derived() {
  throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function effect_orphan(d) {
  throw new Error("https://svelte.dev/e/effect_orphan");
}
function effect_update_depth_exceeded() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function props_invalid_value(d) {
  throw new Error("https://svelte.dev/e/props_invalid_value");
}
function state_descriptors_fixed() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function state_prototype_fixed() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function state_unsafe_mutation() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
let legacy_mode_flag = !1, tracing_mode_flag = !1;
function enable_legacy_mode_flag() {
  legacy_mode_flag = !0;
}
const EACH_ITEM_REACTIVE = 1, EACH_INDEX_REACTIVE = 2, EACH_IS_CONTROLLED = 4, EACH_IS_ANIMATED = 8, EACH_ITEM_IMMUTABLE = 16, PROPS_IS_IMMUTABLE = 1, PROPS_IS_RUNES = 2, PROPS_IS_UPDATED = 4, PROPS_IS_BINDABLE = 8, PROPS_IS_LAZY_INITIAL = 16, TEMPLATE_FRAGMENT = 1, TEMPLATE_USE_IMPORT_NODE = 2, UNINITIALIZED = Symbol(), NAMESPACE_HTML = "http://www.w3.org/1999/xhtml";
function lifecycle_outside_component(d) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
let component_context = null;
function set_component_context(d) {
  component_context = d;
}
function setContext(d, m) {
  return get_or_init_context_map().set(d, m), m;
}
function push(d, m = !1, g) {
  var w = component_context = {
    p: component_context,
    c: null,
    d: !1,
    e: null,
    m: !1,
    s: d,
    x: null,
    l: null
  };
  legacy_mode_flag && !m && (component_context.l = {
    s: null,
    u: null,
    r1: [],
    r2: source(!1)
  }), teardown(() => {
    w.d = !0;
  });
}
function pop(d) {
  const m = component_context;
  if (m !== null) {
    const F = m.e;
    if (F !== null) {
      var g = active_effect, w = active_reaction;
      m.e = null;
      try {
        for (var I = 0; I < F.length; I++) {
          var P = F[I];
          set_active_effect(P.effect), set_active_reaction(P.reaction), effect(P.fn);
        }
      } finally {
        set_active_effect(g), set_active_reaction(w);
      }
    }
    component_context = m.p, m.m = !0;
  }
  return (
    /** @type {T} */
    {}
  );
}
function is_runes() {
  return !legacy_mode_flag || component_context !== null && component_context.l === null;
}
function get_or_init_context_map(d) {
  return component_context === null && lifecycle_outside_component(), component_context.c ?? (component_context.c = new Map(get_parent_context(component_context) || void 0));
}
function get_parent_context(d) {
  let m = d.p;
  for (; m !== null; ) {
    const g = m.c;
    if (g !== null)
      return g;
    m = m.p;
  }
  return null;
}
function proxy(d) {
  if (typeof d != "object" || d === null || STATE_SYMBOL in d)
    return d;
  const m = get_prototype_of(d);
  if (m !== object_prototype && m !== array_prototype)
    return d;
  var g = /* @__PURE__ */ new Map(), w = is_array(d), I = /* @__PURE__ */ state(0), P = active_reaction, F = (D) => {
    var U = active_reaction;
    set_active_reaction(P);
    var Z = D();
    return set_active_reaction(U), Z;
  };
  return w && g.set("length", /* @__PURE__ */ state(
    /** @type {any[]} */
    d.length
  )), new Proxy(
    /** @type {any} */
    d,
    {
      defineProperty(D, U, Z) {
        (!("value" in Z) || Z.configurable === !1 || Z.enumerable === !1 || Z.writable === !1) && state_descriptors_fixed();
        var $ = g.get(U);
        return $ === void 0 ? ($ = F(() => /* @__PURE__ */ state(Z.value)), g.set(U, $)) : set(
          $,
          F(() => proxy(Z.value))
        ), !0;
      },
      deleteProperty(D, U) {
        var Z = g.get(U);
        if (Z === void 0)
          U in D && g.set(
            U,
            F(() => /* @__PURE__ */ state(UNINITIALIZED))
          );
        else {
          if (w && typeof U == "string") {
            var $ = (
              /** @type {Source<number>} */
              g.get("length")
            ), j = Number(U);
            Number.isInteger(j) && j < $.v && set($, j);
          }
          set(Z, UNINITIALIZED), update_version(I);
        }
        return !0;
      },
      get(D, U, Z) {
        var Q;
        if (U === STATE_SYMBOL)
          return d;
        var $ = g.get(U), j = U in D;
        if ($ === void 0 && (!j || (Q = get_descriptor(D, U)) != null && Q.writable) && ($ = F(() => /* @__PURE__ */ state(proxy(j ? D[U] : UNINITIALIZED))), g.set(U, $)), $ !== void 0) {
          var G = get($);
          return G === UNINITIALIZED ? void 0 : G;
        }
        return Reflect.get(D, U, Z);
      },
      getOwnPropertyDescriptor(D, U) {
        var Z = Reflect.getOwnPropertyDescriptor(D, U);
        if (Z && "value" in Z) {
          var $ = g.get(U);
          $ && (Z.value = get($));
        } else if (Z === void 0) {
          var j = g.get(U), G = j == null ? void 0 : j.v;
          if (j !== void 0 && G !== UNINITIALIZED)
            return {
              enumerable: !0,
              configurable: !0,
              value: G,
              writable: !0
            };
        }
        return Z;
      },
      has(D, U) {
        var G;
        if (U === STATE_SYMBOL)
          return !0;
        var Z = g.get(U), $ = Z !== void 0 && Z.v !== UNINITIALIZED || Reflect.has(D, U);
        if (Z !== void 0 || active_effect !== null && (!$ || (G = get_descriptor(D, U)) != null && G.writable)) {
          Z === void 0 && (Z = F(() => /* @__PURE__ */ state($ ? proxy(D[U]) : UNINITIALIZED)), g.set(U, Z));
          var j = get(Z);
          if (j === UNINITIALIZED)
            return !1;
        }
        return $;
      },
      set(D, U, Z, $) {
        var rt;
        var j = g.get(U), G = U in D;
        if (w && U === "length")
          for (var Q = Z; Q < /** @type {Source<number>} */
          j.v; Q += 1) {
            var H = g.get(Q + "");
            H !== void 0 ? set(H, UNINITIALIZED) : Q in D && (H = F(() => /* @__PURE__ */ state(UNINITIALIZED)), g.set(Q + "", H));
          }
        j === void 0 ? (!G || (rt = get_descriptor(D, U)) != null && rt.writable) && (j = F(() => /* @__PURE__ */ state(void 0)), set(
          j,
          F(() => proxy(Z))
        ), g.set(U, j)) : (G = j.v !== UNINITIALIZED, set(
          j,
          F(() => proxy(Z))
        ));
        var W = Reflect.getOwnPropertyDescriptor(D, U);
        if (W != null && W.set && W.set.call($, Z), !G) {
          if (w && typeof U == "string") {
            var q = (
              /** @type {Source<number>} */
              g.get("length")
            ), et = Number(U);
            Number.isInteger(et) && et >= q.v && set(q, et + 1);
          }
          update_version(I);
        }
        return !0;
      },
      ownKeys(D) {
        get(I);
        var U = Reflect.ownKeys(D).filter((j) => {
          var G = g.get(j);
          return G === void 0 || G.v !== UNINITIALIZED;
        });
        for (var [Z, $] of g)
          $.v !== UNINITIALIZED && !(Z in D) && U.push(Z);
        return U;
      },
      setPrototypeOf() {
        state_prototype_fixed();
      }
    }
  );
}
function update_version(d, m = 1) {
  set(d, d.v + m);
}
function get_proxied_value(d) {
  try {
    if (d !== null && typeof d == "object" && STATE_SYMBOL in d)
      return d[STATE_SYMBOL];
  } catch {
  }
  return d;
}
function is(d, m) {
  return Object.is(get_proxied_value(d), get_proxied_value(m));
}
// @__NO_SIDE_EFFECTS__
function derived(d) {
  var m = DERIVED | DIRTY$1, g = active_reaction !== null && (active_reaction.f & DERIVED) !== 0 ? (
    /** @type {Derived} */
    active_reaction
  ) : null;
  return active_effect === null || g !== null && (g.f & UNOWNED) !== 0 ? m |= UNOWNED : active_effect.f |= EFFECT_HAS_DERIVED, {
    ctx: component_context,
    deps: null,
    effects: null,
    equals,
    f: m,
    fn: d,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      null
    ),
    wv: 0,
    parent: g ?? active_effect
  };
}
// @__NO_SIDE_EFFECTS__
function user_derived(d) {
  const m = /* @__PURE__ */ derived(d);
  return push_reaction_value(m), m;
}
// @__NO_SIDE_EFFECTS__
function derived_safe_equal(d) {
  const m = /* @__PURE__ */ derived(d);
  return m.equals = safe_equals, m;
}
function destroy_derived_effects(d) {
  var m = d.effects;
  if (m !== null) {
    d.effects = null;
    for (var g = 0; g < m.length; g += 1)
      destroy_effect(
        /** @type {Effect} */
        m[g]
      );
  }
}
function get_derived_parent_effect(d) {
  for (var m = d.parent; m !== null; ) {
    if ((m.f & DERIVED) === 0)
      return (
        /** @type {Effect} */
        m
      );
    m = m.parent;
  }
  return null;
}
function execute_derived(d) {
  var m, g = active_effect;
  set_active_effect(get_derived_parent_effect(d));
  try {
    destroy_derived_effects(d), m = update_reaction(d);
  } finally {
    set_active_effect(g);
  }
  return m;
}
function update_derived(d) {
  var m = execute_derived(d), g = (skip_reaction || (d.f & UNOWNED) !== 0) && d.deps !== null ? MAYBE_DIRTY : CLEAN;
  set_signal_status(d, g), d.equals(m) || (d.v = m, d.wv = increment_write_version());
}
const old_values = /* @__PURE__ */ new Map();
function source(d, m) {
  var g = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: d,
    reactions: null,
    equals,
    rv: 0,
    wv: 0
  };
  return g;
}
// @__NO_SIDE_EFFECTS__
function state(d, m) {
  const g = source(d);
  return push_reaction_value(g), g;
}
// @__NO_SIDE_EFFECTS__
function mutable_source(d, m = !1) {
  var w;
  const g = source(d);
  return m || (g.equals = safe_equals), legacy_mode_flag && component_context !== null && component_context.l !== null && ((w = component_context.l).s ?? (w.s = [])).push(g), g;
}
function set(d, m, g = !1) {
  active_reaction !== null && !untracking && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 && !(reaction_sources != null && reaction_sources.includes(d)) && state_unsafe_mutation();
  let w = g ? proxy(m) : m;
  return internal_set(d, w);
}
function internal_set(d, m) {
  if (!d.equals(m)) {
    var g = d.v;
    is_destroying_effect ? old_values.set(d, m) : old_values.set(d, g), d.v = m, (d.f & DERIVED) !== 0 && ((d.f & DIRTY$1) !== 0 && execute_derived(
      /** @type {Derived} */
      d
    ), set_signal_status(d, (d.f & UNOWNED) === 0 ? CLEAN : MAYBE_DIRTY)), d.wv = increment_write_version(), mark_reactions(d, DIRTY$1), is_runes() && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 && (untracked_writes === null ? set_untracked_writes([d]) : untracked_writes.push(d));
  }
  return m;
}
function mark_reactions(d, m) {
  var g = d.reactions;
  if (g !== null)
    for (var w = is_runes(), I = g.length, P = 0; P < I; P++) {
      var F = g[P], D = F.f;
      (D & DIRTY$1) === 0 && (!w && F === active_effect || (set_signal_status(F, m), (D & (CLEAN | UNOWNED)) !== 0 && ((D & DERIVED) !== 0 ? mark_reactions(
        /** @type {Derived} */
        F,
        MAYBE_DIRTY
      ) : schedule_effect(
        /** @type {Effect} */
        F
      ))));
    }
}
let hydrating = !1;
var $window, is_firefox, first_child_getter, next_sibling_getter;
function init_operations() {
  if ($window === void 0) {
    $window = window, is_firefox = /Firefox/.test(navigator.userAgent);
    var d = Element.prototype, m = Node.prototype, g = Text.prototype;
    first_child_getter = get_descriptor(m, "firstChild").get, next_sibling_getter = get_descriptor(m, "nextSibling").get, is_extensible(d) && (d.__click = void 0, d.__className = void 0, d.__attributes = null, d.__style = void 0, d.__e = void 0), is_extensible(g) && (g.__t = void 0);
  }
}
function create_text(d = "") {
  return document.createTextNode(d);
}
// @__NO_SIDE_EFFECTS__
function get_first_child(d) {
  return first_child_getter.call(d);
}
// @__NO_SIDE_EFFECTS__
function get_next_sibling(d) {
  return next_sibling_getter.call(d);
}
function child(d, m) {
  return /* @__PURE__ */ get_first_child(d);
}
function first_child(d, m) {
  {
    var g = (
      /** @type {DocumentFragment} */
      /* @__PURE__ */ get_first_child(
        /** @type {Node} */
        d
      )
    );
    return g instanceof Comment && g.data === "" ? /* @__PURE__ */ get_next_sibling(g) : g;
  }
}
function sibling(d, m = 1, g = !1) {
  let w = d;
  for (; m--; )
    w = /** @type {TemplateNode} */
    /* @__PURE__ */ get_next_sibling(w);
  return w;
}
function clear_text_content(d) {
  d.textContent = "";
}
function validate_effect(d) {
  active_effect === null && active_reaction === null && effect_orphan(), active_reaction !== null && (active_reaction.f & UNOWNED) !== 0 && active_effect === null && effect_in_unowned_derived(), is_destroying_effect && effect_in_teardown();
}
function push_effect(d, m) {
  var g = m.last;
  g === null ? m.last = m.first = d : (g.next = d, d.prev = g, m.last = d);
}
function create_effect(d, m, g, w = !0) {
  var I = active_effect, P = {
    ctx: component_context,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: d | DIRTY$1,
    first: null,
    fn: m,
    last: null,
    next: null,
    parent: I,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0
  };
  if (g)
    try {
      update_effect(P), P.f |= EFFECT_RAN;
    } catch (U) {
      throw destroy_effect(P), U;
    }
  else m !== null && schedule_effect(P);
  var F = g && P.deps === null && P.first === null && P.nodes_start === null && P.teardown === null && (P.f & (EFFECT_HAS_DERIVED | BOUNDARY_EFFECT)) === 0;
  if (!F && w && (I !== null && push_effect(P, I), active_reaction !== null && (active_reaction.f & DERIVED) !== 0)) {
    var D = (
      /** @type {Derived} */
      active_reaction
    );
    (D.effects ?? (D.effects = [])).push(P);
  }
  return P;
}
function teardown(d) {
  const m = create_effect(RENDER_EFFECT, null, !1);
  return set_signal_status(m, CLEAN), m.teardown = d, m;
}
function user_effect(d) {
  validate_effect();
  var m = active_effect !== null && (active_effect.f & BRANCH_EFFECT) !== 0 && component_context !== null && !component_context.m;
  if (m) {
    var g = (
      /** @type {ComponentContext} */
      component_context
    );
    (g.e ?? (g.e = [])).push({
      fn: d,
      effect: active_effect,
      reaction: active_reaction
    });
  } else {
    var w = effect(d);
    return w;
  }
}
function user_pre_effect(d) {
  return validate_effect(), render_effect(d);
}
function component_root(d) {
  const m = create_effect(ROOT_EFFECT, d, !0);
  return (g = {}) => new Promise((w) => {
    g.outro ? pause_effect(m, () => {
      destroy_effect(m), w(void 0);
    }) : (destroy_effect(m), w(void 0));
  });
}
function effect(d) {
  return create_effect(EFFECT, d, !1);
}
function render_effect(d) {
  return create_effect(RENDER_EFFECT, d, !0);
}
function template_effect(d, m = [], g = derived) {
  const w = m.map(g);
  return block(() => d(...w.map(get)));
}
function block(d, m = 0) {
  return create_effect(RENDER_EFFECT | BLOCK_EFFECT | m, d, !0);
}
function branch(d, m = !0) {
  return create_effect(RENDER_EFFECT | BRANCH_EFFECT, d, !0, m);
}
function execute_effect_teardown(d) {
  var m = d.teardown;
  if (m !== null) {
    const g = is_destroying_effect, w = active_reaction;
    set_is_destroying_effect(!0), set_active_reaction(null);
    try {
      m.call(null);
    } finally {
      set_is_destroying_effect(g), set_active_reaction(w);
    }
  }
}
function destroy_effect_children(d, m = !1) {
  var g = d.first;
  for (d.first = d.last = null; g !== null; ) {
    var w = g.next;
    (g.f & ROOT_EFFECT) !== 0 ? g.parent = null : destroy_effect(g, m), g = w;
  }
}
function destroy_block_effect_children(d) {
  for (var m = d.first; m !== null; ) {
    var g = m.next;
    (m.f & BRANCH_EFFECT) === 0 && destroy_effect(m), m = g;
  }
}
function destroy_effect(d, m = !0) {
  var g = !1;
  if ((m || (d.f & HEAD_EFFECT) !== 0) && d.nodes_start !== null) {
    for (var w = d.nodes_start, I = d.nodes_end; w !== null; ) {
      var P = w === I ? null : (
        /** @type {TemplateNode} */
        /* @__PURE__ */ get_next_sibling(w)
      );
      w.remove(), w = P;
    }
    g = !0;
  }
  destroy_effect_children(d, m && !g), remove_reactions(d, 0), set_signal_status(d, DESTROYED);
  var F = d.transitions;
  if (F !== null)
    for (const U of F)
      U.stop();
  execute_effect_teardown(d);
  var D = d.parent;
  D !== null && D.first !== null && unlink_effect(d), d.next = d.prev = d.teardown = d.ctx = d.deps = d.fn = d.nodes_start = d.nodes_end = null;
}
function unlink_effect(d) {
  var m = d.parent, g = d.prev, w = d.next;
  g !== null && (g.next = w), w !== null && (w.prev = g), m !== null && (m.first === d && (m.first = w), m.last === d && (m.last = g));
}
function pause_effect(d, m) {
  var g = [];
  pause_children(d, g, !0), run_out_transitions(g, () => {
    destroy_effect(d), m && m();
  });
}
function run_out_transitions(d, m) {
  var g = d.length;
  if (g > 0) {
    var w = () => --g || m();
    for (var I of d)
      I.out(w);
  } else
    m();
}
function pause_children(d, m, g) {
  if ((d.f & INERT) === 0) {
    if (d.f ^= INERT, d.transitions !== null)
      for (const F of d.transitions)
        (F.is_global || g) && m.push(F);
    for (var w = d.first; w !== null; ) {
      var I = w.next, P = (w.f & EFFECT_TRANSPARENT) !== 0 || (w.f & BRANCH_EFFECT) !== 0;
      pause_children(w, m, P ? g : !1), w = I;
    }
  }
}
function resume_effect(d) {
  resume_children(d, !0);
}
function resume_children(d, m) {
  if ((d.f & INERT) !== 0) {
    d.f ^= INERT, (d.f & CLEAN) === 0 && (d.f ^= CLEAN), check_dirtiness(d) && (set_signal_status(d, DIRTY$1), schedule_effect(d));
    for (var g = d.first; g !== null; ) {
      var w = g.next, I = (g.f & EFFECT_TRANSPARENT) !== 0 || (g.f & BRANCH_EFFECT) !== 0;
      resume_children(g, I ? m : !1), g = w;
    }
    if (d.transitions !== null)
      for (const P of d.transitions)
        (P.is_global || m) && P.in();
  }
}
let micro_tasks = [], idle_tasks = [];
function run_micro_tasks() {
  var d = micro_tasks;
  micro_tasks = [], run_all(d);
}
function run_idle_tasks() {
  var d = idle_tasks;
  idle_tasks = [], run_all(d);
}
function queue_micro_task(d) {
  micro_tasks.length === 0 && queueMicrotask(run_micro_tasks), micro_tasks.push(d);
}
function flush_tasks() {
  micro_tasks.length > 0 && run_micro_tasks(), idle_tasks.length > 0 && run_idle_tasks();
}
let is_throwing_error = !1, is_flushing = !1, last_scheduled_effect = null, is_updating_effect = !1, is_destroying_effect = !1;
function set_is_destroying_effect(d) {
  is_destroying_effect = d;
}
let queued_root_effects = [], dev_effect_stack = [], active_reaction = null, untracking = !1;
function set_active_reaction(d) {
  active_reaction = d;
}
let active_effect = null;
function set_active_effect(d) {
  active_effect = d;
}
let reaction_sources = null;
function push_reaction_value(d) {
  active_reaction !== null && active_reaction.f & EFFECT_IS_UPDATING && (reaction_sources === null ? reaction_sources = [d] : reaction_sources.push(d));
}
let new_deps = null, skipped_deps = 0, untracked_writes = null;
function set_untracked_writes(d) {
  untracked_writes = d;
}
let write_version = 1, read_version = 0, skip_reaction = !1;
function increment_write_version() {
  return ++write_version;
}
function check_dirtiness(d) {
  var j;
  var m = d.f;
  if ((m & DIRTY$1) !== 0)
    return !0;
  if ((m & MAYBE_DIRTY) !== 0) {
    var g = d.deps, w = (m & UNOWNED) !== 0;
    if (g !== null) {
      var I, P, F = (m & DISCONNECTED) !== 0, D = w && active_effect !== null && !skip_reaction, U = g.length;
      if (F || D) {
        var Z = (
          /** @type {Derived} */
          d
        ), $ = Z.parent;
        for (I = 0; I < U; I++)
          P = g[I], (F || !((j = P == null ? void 0 : P.reactions) != null && j.includes(Z))) && (P.reactions ?? (P.reactions = [])).push(Z);
        F && (Z.f ^= DISCONNECTED), D && $ !== null && ($.f & UNOWNED) === 0 && (Z.f ^= UNOWNED);
      }
      for (I = 0; I < U; I++)
        if (P = g[I], check_dirtiness(
          /** @type {Derived} */
          P
        ) && update_derived(
          /** @type {Derived} */
          P
        ), P.wv > d.wv)
          return !0;
    }
    (!w || active_effect !== null && !skip_reaction) && set_signal_status(d, CLEAN);
  }
  return !1;
}
function propagate_error(d, m) {
  for (var g = m; g !== null; ) {
    if ((g.f & BOUNDARY_EFFECT) !== 0)
      try {
        g.fn(d);
        return;
      } catch {
        g.f ^= BOUNDARY_EFFECT;
      }
    g = g.parent;
  }
  throw is_throwing_error = !1, d;
}
function should_rethrow_error(d) {
  return (d.f & DESTROYED) === 0 && (d.parent === null || (d.parent.f & BOUNDARY_EFFECT) === 0);
}
function handle_error(d, m, g, w) {
  if (is_throwing_error) {
    if (g === null && (is_throwing_error = !1), should_rethrow_error(m))
      throw d;
    return;
  }
  g !== null && (is_throwing_error = !0);
  {
    propagate_error(d, m);
    return;
  }
}
function schedule_possible_effect_self_invalidation(d, m, g = !0) {
  var w = d.reactions;
  if (w !== null)
    for (var I = 0; I < w.length; I++) {
      var P = w[I];
      reaction_sources != null && reaction_sources.includes(d) || ((P.f & DERIVED) !== 0 ? schedule_possible_effect_self_invalidation(
        /** @type {Derived} */
        P,
        m,
        !1
      ) : m === P && (g ? set_signal_status(P, DIRTY$1) : (P.f & CLEAN) !== 0 && set_signal_status(P, MAYBE_DIRTY), schedule_effect(
        /** @type {Effect} */
        P
      )));
    }
}
function update_reaction(d) {
  var Q;
  var m = new_deps, g = skipped_deps, w = untracked_writes, I = active_reaction, P = skip_reaction, F = reaction_sources, D = component_context, U = untracking, Z = d.f;
  new_deps = /** @type {null | Value[]} */
  null, skipped_deps = 0, untracked_writes = null, skip_reaction = (Z & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null), active_reaction = (Z & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? d : null, reaction_sources = null, set_component_context(d.ctx), untracking = !1, read_version++, d.f |= EFFECT_IS_UPDATING;
  try {
    var $ = (
      /** @type {Function} */
      (0, d.fn)()
    ), j = d.deps;
    if (new_deps !== null) {
      var G;
      if (remove_reactions(d, skipped_deps), j !== null && skipped_deps > 0)
        for (j.length = skipped_deps + new_deps.length, G = 0; G < new_deps.length; G++)
          j[skipped_deps + G] = new_deps[G];
      else
        d.deps = j = new_deps;
      if (!skip_reaction)
        for (G = skipped_deps; G < j.length; G++)
          ((Q = j[G]).reactions ?? (Q.reactions = [])).push(d);
    } else j !== null && skipped_deps < j.length && (remove_reactions(d, skipped_deps), j.length = skipped_deps);
    if (is_runes() && untracked_writes !== null && !untracking && j !== null && (d.f & (DERIVED | MAYBE_DIRTY | DIRTY$1)) === 0)
      for (G = 0; G < /** @type {Source[]} */
      untracked_writes.length; G++)
        schedule_possible_effect_self_invalidation(
          untracked_writes[G],
          /** @type {Effect} */
          d
        );
    return I !== d && (read_version++, untracked_writes !== null && (w === null ? w = untracked_writes : w.push(.../** @type {Source[]} */
    untracked_writes))), $;
  } finally {
    new_deps = m, skipped_deps = g, untracked_writes = w, active_reaction = I, skip_reaction = P, reaction_sources = F, set_component_context(D), untracking = U, d.f ^= EFFECT_IS_UPDATING;
  }
}
function remove_reaction(d, m) {
  let g = m.reactions;
  if (g !== null) {
    var w = index_of.call(g, d);
    if (w !== -1) {
      var I = g.length - 1;
      I === 0 ? g = m.reactions = null : (g[w] = g[I], g.pop());
    }
  }
  g === null && (m.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (new_deps === null || !new_deps.includes(m)) && (set_signal_status(m, MAYBE_DIRTY), (m.f & (UNOWNED | DISCONNECTED)) === 0 && (m.f ^= DISCONNECTED), destroy_derived_effects(
    /** @type {Derived} **/
    m
  ), remove_reactions(
    /** @type {Derived} **/
    m,
    0
  ));
}
function remove_reactions(d, m) {
  var g = d.deps;
  if (g !== null)
    for (var w = m; w < g.length; w++)
      remove_reaction(d, g[w]);
}
function update_effect(d) {
  var m = d.f;
  if ((m & DESTROYED) === 0) {
    set_signal_status(d, CLEAN);
    var g = active_effect, w = component_context, I = is_updating_effect;
    active_effect = d, is_updating_effect = !0;
    try {
      (m & BLOCK_EFFECT) !== 0 ? destroy_block_effect_children(d) : destroy_effect_children(d), execute_effect_teardown(d);
      var P = update_reaction(d);
      d.teardown = typeof P == "function" ? P : null, d.wv = write_version;
      var F = d.deps, D;
    } catch (U) {
      handle_error(U, d, g, w || d.ctx);
    } finally {
      is_updating_effect = I, active_effect = g;
    }
  }
}
function infinite_loop_guard() {
  try {
    effect_update_depth_exceeded();
  } catch (d) {
    if (last_scheduled_effect !== null)
      handle_error(d, last_scheduled_effect, null);
    else
      throw d;
  }
}
function flush_queued_root_effects() {
  var d = is_updating_effect;
  try {
    var m = 0;
    for (is_updating_effect = !0; queued_root_effects.length > 0; ) {
      m++ > 1e3 && infinite_loop_guard();
      var g = queued_root_effects, w = g.length;
      queued_root_effects = [];
      for (var I = 0; I < w; I++) {
        var P = process_effects(g[I]);
        flush_queued_effects(P);
      }
      old_values.clear();
    }
  } finally {
    is_flushing = !1, is_updating_effect = d, last_scheduled_effect = null;
  }
}
function flush_queued_effects(d) {
  var m = d.length;
  if (m !== 0)
    for (var g = 0; g < m; g++) {
      var w = d[g];
      if ((w.f & (DESTROYED | INERT)) === 0)
        try {
          check_dirtiness(w) && (update_effect(w), w.deps === null && w.first === null && w.nodes_start === null && (w.teardown === null ? unlink_effect(w) : w.fn = null));
        } catch (I) {
          handle_error(I, w, null, w.ctx);
        }
    }
}
function schedule_effect(d) {
  is_flushing || (is_flushing = !0, queueMicrotask(flush_queued_root_effects));
  for (var m = last_scheduled_effect = d; m.parent !== null; ) {
    m = m.parent;
    var g = m.f;
    if ((g & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
      if ((g & CLEAN) === 0) return;
      m.f ^= CLEAN;
    }
  }
  queued_root_effects.push(m);
}
function process_effects(d) {
  for (var m = [], g = d; g !== null; ) {
    var w = g.f, I = (w & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0, P = I && (w & CLEAN) !== 0;
    if (!P && (w & INERT) === 0) {
      if ((w & EFFECT) !== 0)
        m.push(g);
      else if (I)
        g.f ^= CLEAN;
      else {
        var F = active_reaction;
        try {
          active_reaction = g, check_dirtiness(g) && update_effect(g);
        } catch (Z) {
          handle_error(Z, g, null, g.ctx);
        } finally {
          active_reaction = F;
        }
      }
      var D = g.first;
      if (D !== null) {
        g = D;
        continue;
      }
    }
    var U = g.parent;
    for (g = g.next; g === null && U !== null; )
      g = U.next, U = U.parent;
  }
  return m;
}
function flushSync(d) {
  var m;
  for (flush_tasks(); queued_root_effects.length > 0; )
    is_flushing = !0, flush_queued_root_effects(), flush_tasks();
  return (
    /** @type {T} */
    m
  );
}
function get(d) {
  var m = d.f, g = (m & DERIVED) !== 0;
  if (active_reaction !== null && !untracking) {
    if (!(reaction_sources != null && reaction_sources.includes(d))) {
      var w = active_reaction.deps;
      d.rv < read_version && (d.rv = read_version, new_deps === null && w !== null && w[skipped_deps] === d ? skipped_deps++ : new_deps === null ? new_deps = [d] : (!skip_reaction || !new_deps.includes(d)) && new_deps.push(d));
    }
  } else if (g && /** @type {Derived} */
  d.deps === null && /** @type {Derived} */
  d.effects === null) {
    var I = (
      /** @type {Derived} */
      d
    ), P = I.parent;
    P !== null && (P.f & UNOWNED) === 0 && (I.f ^= UNOWNED);
  }
  return g && (I = /** @type {Derived} */
  d, check_dirtiness(I) && update_derived(I)), is_destroying_effect && old_values.has(d) ? old_values.get(d) : d.v;
}
function untrack(d) {
  var m = untracking;
  try {
    return untracking = !0, d();
  } finally {
    untracking = m;
  }
}
const STATUS_MASK = -7169;
function set_signal_status(d, m) {
  d.f = d.f & STATUS_MASK | m;
}
function deep_read_state(d) {
  if (!(typeof d != "object" || !d || d instanceof EventTarget)) {
    if (STATE_SYMBOL in d)
      deep_read(d);
    else if (!Array.isArray(d))
      for (let m in d) {
        const g = d[m];
        typeof g == "object" && g && STATE_SYMBOL in g && deep_read(g);
      }
  }
}
function deep_read(d, m = /* @__PURE__ */ new Set()) {
  if (typeof d == "object" && d !== null && // We don't want to traverse DOM elements
  !(d instanceof EventTarget) && !m.has(d)) {
    m.add(d), d instanceof Date && d.getTime();
    for (let w in d)
      try {
        deep_read(d[w], m);
      } catch {
      }
    const g = get_prototype_of(d);
    if (g !== Object.prototype && g !== Array.prototype && g !== Map.prototype && g !== Set.prototype && g !== Date.prototype) {
      const w = get_descriptors(g);
      for (let I in w) {
        const P = w[I].get;
        if (P)
          try {
            P.call(d);
          } catch {
          }
      }
    }
  }
}
const PASSIVE_EVENTS = ["touchstart", "touchmove"];
function is_passive_event(d) {
  return PASSIVE_EVENTS.includes(d);
}
let listening_to_form_reset = !1;
function add_form_reset_listener() {
  listening_to_form_reset || (listening_to_form_reset = !0, document.addEventListener(
    "reset",
    (d) => {
      Promise.resolve().then(() => {
        var m;
        if (!d.defaultPrevented)
          for (
            const g of
            /**@type {HTMLFormElement} */
            d.target.elements
          )
            (m = g.__on_r) == null || m.call(g);
      });
    },
    // In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
    { capture: !0 }
  ));
}
function without_reactive_context(d) {
  var m = active_reaction, g = active_effect;
  set_active_reaction(null), set_active_effect(null);
  try {
    return d();
  } finally {
    set_active_reaction(m), set_active_effect(g);
  }
}
function listen_to_event_and_reset_event(d, m, g, w = g) {
  d.addEventListener(m, () => without_reactive_context(g));
  const I = d.__on_r;
  I ? d.__on_r = () => {
    I(), w(!0);
  } : d.__on_r = () => w(!0), add_form_reset_listener();
}
const all_registered_events = /* @__PURE__ */ new Set(), root_event_handles = /* @__PURE__ */ new Set();
function delegate(d) {
  for (var m = 0; m < d.length; m++)
    all_registered_events.add(d[m]);
  for (var g of root_event_handles)
    g(d);
}
function handle_event_propagation(d) {
  var rt;
  var m = this, g = (
    /** @type {Node} */
    m.ownerDocument
  ), w = d.type, I = ((rt = d.composedPath) == null ? void 0 : rt.call(d)) || [], P = (
    /** @type {null | Element} */
    I[0] || d.target
  ), F = 0, D = d.__root;
  if (D) {
    var U = I.indexOf(D);
    if (U !== -1 && (m === document || m === /** @type {any} */
    window)) {
      d.__root = m;
      return;
    }
    var Z = I.indexOf(m);
    if (Z === -1)
      return;
    U <= Z && (F = U);
  }
  if (P = /** @type {Element} */
  I[F] || d.target, P !== m) {
    define_property(d, "currentTarget", {
      configurable: !0,
      get() {
        return P || g;
      }
    });
    var $ = active_reaction, j = active_effect;
    set_active_reaction(null), set_active_effect(null);
    try {
      for (var G, Q = []; P !== null; ) {
        var H = P.assignedSlot || P.parentNode || /** @type {any} */
        P.host || null;
        try {
          var W = P["__" + w];
          if (W != null && (!/** @type {any} */
          P.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          d.target === P))
            if (is_array(W)) {
              var [q, ...et] = W;
              q.apply(P, [d, ...et]);
            } else
              W.call(P, d);
        } catch (tt) {
          G ? Q.push(tt) : G = tt;
        }
        if (d.cancelBubble || H === m || H === null)
          break;
        P = H;
      }
      if (G) {
        for (let tt of Q)
          queueMicrotask(() => {
            throw tt;
          });
        throw G;
      }
    } finally {
      d.__root = m, delete d.currentTarget, set_active_reaction($), set_active_effect(j);
    }
  }
}
function create_fragment_from_html(d) {
  var m = document.createElement("template");
  return m.innerHTML = d, m.content;
}
function assign_nodes(d, m) {
  var g = (
    /** @type {Effect} */
    active_effect
  );
  g.nodes_start === null && (g.nodes_start = d, g.nodes_end = m);
}
// @__NO_SIDE_EFFECTS__
function template(d, m) {
  var g = (m & TEMPLATE_FRAGMENT) !== 0, w = (m & TEMPLATE_USE_IMPORT_NODE) !== 0, I, P = !d.startsWith("<!>");
  return () => {
    I === void 0 && (I = create_fragment_from_html(P ? d : "<!>" + d), g || (I = /** @type {Node} */
    /* @__PURE__ */ get_first_child(I)));
    var F = (
      /** @type {TemplateNode} */
      w || is_firefox ? document.importNode(I, !0) : I.cloneNode(!0)
    );
    if (g) {
      var D = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ get_first_child(F)
      ), U = (
        /** @type {TemplateNode} */
        F.lastChild
      );
      assign_nodes(D, U);
    } else
      assign_nodes(F, F);
    return F;
  };
}
function comment() {
  var d = document.createDocumentFragment(), m = document.createComment(""), g = create_text();
  return d.append(m, g), assign_nodes(m, g), d;
}
function append(d, m) {
  d !== null && d.before(
    /** @type {Node} */
    m
  );
}
function set_text(d, m) {
  var g = m == null ? "" : typeof m == "object" ? m + "" : m;
  g !== (d.__t ?? (d.__t = d.nodeValue)) && (d.__t = g, d.nodeValue = g + "");
}
function mount(d, m) {
  return _mount(d, m);
}
const document_listeners = /* @__PURE__ */ new Map();
function _mount(d, { target: m, anchor: g, props: w = {}, events: I, context: P, intro: F = !0 }) {
  init_operations();
  var D = /* @__PURE__ */ new Set(), U = (j) => {
    for (var G = 0; G < j.length; G++) {
      var Q = j[G];
      if (!D.has(Q)) {
        D.add(Q);
        var H = is_passive_event(Q);
        m.addEventListener(Q, handle_event_propagation, { passive: H });
        var W = document_listeners.get(Q);
        W === void 0 ? (document.addEventListener(Q, handle_event_propagation, { passive: H }), document_listeners.set(Q, 1)) : document_listeners.set(Q, W + 1);
      }
    }
  };
  U(array_from(all_registered_events)), root_event_handles.add(U);
  var Z = void 0, $ = component_root(() => {
    var j = g ?? m.appendChild(create_text());
    return branch(() => {
      if (P) {
        push({});
        var G = (
          /** @type {ComponentContext} */
          component_context
        );
        G.c = P;
      }
      I && (w.$$events = I), Z = d(j, w) || {}, P && pop();
    }), () => {
      var H;
      for (var G of D) {
        m.removeEventListener(G, handle_event_propagation);
        var Q = (
          /** @type {number} */
          document_listeners.get(G)
        );
        --Q === 0 ? (document.removeEventListener(G, handle_event_propagation), document_listeners.delete(G)) : document_listeners.set(G, Q);
      }
      root_event_handles.delete(U), j !== g && ((H = j.parentNode) == null || H.removeChild(j));
    };
  });
  return mounted_components.set(Z, $), Z;
}
let mounted_components = /* @__PURE__ */ new WeakMap();
const PENDING = 0, THEN = 1, CATCH = 2;
function await_block(d, m, g, w, I) {
  var P = d, F = is_runes(), D = component_context, U = UNINITIALIZED, Z, $, j, G = (F ? source : mutable_source)(
    /** @type {V} */
    void 0
  ), Q = (F ? source : mutable_source)(void 0), H = !1;
  function W(et, rt) {
    H = !0, rt && (set_active_effect(q), set_active_reaction(q), set_component_context(D));
    try {
      et === PENDING && g && (Z ? resume_effect(Z) : Z = branch(() => g(P))), et === THEN && w && ($ ? resume_effect($) : $ = branch(() => w(P, G))), et !== PENDING && Z && pause_effect(Z, () => Z = null), et !== THEN && $ && pause_effect($, () => $ = null), et !== CATCH && j && pause_effect(j, () => j = null);
    } finally {
      rt && (set_component_context(null), set_active_reaction(null), set_active_effect(null), flushSync());
    }
  }
  var q = block(() => {
    if (U !== (U = m())) {
      if (is_promise(U)) {
        var et = U;
        H = !1, et.then(
          (rt) => {
            et === U && (internal_set(G, rt), W(THEN, !0));
          },
          (rt) => {
            if (et === U)
              throw internal_set(Q, rt), W(CATCH, !0), Q.v;
          }
        ), queue_micro_task(() => {
          H || W(PENDING, !0);
        });
      } else
        internal_set(G, U), W(THEN, !1);
      return () => U = UNINITIALIZED;
    }
  });
}
function if_block(d, m, [g, w] = [0, 0]) {
  var I = d, P = null, F = null, D = UNINITIALIZED, U = g > 0 ? EFFECT_TRANSPARENT : 0, Z = !1;
  const $ = (G, Q = !0) => {
    Z = !0, j(Q, G);
  }, j = (G, Q) => {
    D !== (D = G) && (D ? (P ? resume_effect(P) : Q && (P = branch(() => Q(I))), F && pause_effect(F, () => {
      F = null;
    })) : (F ? resume_effect(F) : Q && (F = branch(() => Q(I, [g + 1, w]))), P && pause_effect(P, () => {
      P = null;
    })));
  };
  block(() => {
    Z = !1, m($), Z || j(null, null);
  }, U);
}
function index(d, m) {
  return m;
}
function pause_effects(d, m, g, w) {
  for (var I = [], P = m.length, F = 0; F < P; F++)
    pause_children(m[F].e, I, !0);
  var D = P > 0 && I.length === 0 && g !== null;
  if (D) {
    var U = (
      /** @type {Element} */
      /** @type {Element} */
      g.parentNode
    );
    clear_text_content(U), U.append(
      /** @type {Element} */
      g
    ), w.clear(), link(d, m[0].prev, m[P - 1].next);
  }
  run_out_transitions(I, () => {
    for (var Z = 0; Z < P; Z++) {
      var $ = m[Z];
      D || (w.delete($.k), link(d, $.prev, $.next)), destroy_effect($.e, !D);
    }
  });
}
function each(d, m, g, w, I, P = null) {
  var F = d, D = { flags: m, items: /* @__PURE__ */ new Map(), first: null }, U = (m & EACH_IS_CONTROLLED) !== 0;
  if (U) {
    var Z = (
      /** @type {Element} */
      d
    );
    F = Z.appendChild(create_text());
  }
  var $ = null, j = !1, G = /* @__PURE__ */ derived_safe_equal(() => {
    var Q = g();
    return is_array(Q) ? Q : Q == null ? [] : array_from(Q);
  });
  block(() => {
    var Q = get(G), H = Q.length;
    j && H === 0 || (j = H === 0, reconcile(Q, D, F, I, m, w, g), P !== null && (H === 0 ? $ ? resume_effect($) : $ = branch(() => P(F)) : $ !== null && pause_effect($, () => {
      $ = null;
    })), get(G));
  });
}
function reconcile(d, m, g, w, I, P, F) {
  var dt, ht, pt, Ct;
  var D = (I & EACH_IS_ANIMATED) !== 0, U = (I & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0, Z = d.length, $ = m.items, j = m.first, G = j, Q, H = null, W, q = [], et = [], rt, tt, V, X;
  if (D)
    for (X = 0; X < Z; X += 1)
      rt = d[X], tt = P(rt, X), V = $.get(tt), V !== void 0 && ((dt = V.a) == null || dt.measure(), (W ?? (W = /* @__PURE__ */ new Set())).add(V));
  for (X = 0; X < Z; X += 1) {
    if (rt = d[X], tt = P(rt, X), V = $.get(tt), V === void 0) {
      var ot = G ? (
        /** @type {TemplateNode} */
        G.e.nodes_start
      ) : g;
      H = create_item(
        ot,
        m,
        H,
        H === null ? m.first : H.next,
        rt,
        tt,
        X,
        w,
        I,
        F
      ), $.set(tt, H), q = [], et = [], G = H.next;
      continue;
    }
    if (U && update_item(V, rt, X, I), (V.e.f & INERT) !== 0 && (resume_effect(V.e), D && ((ht = V.a) == null || ht.unfix(), (W ?? (W = /* @__PURE__ */ new Set())).delete(V))), V !== G) {
      if (Q !== void 0 && Q.has(V)) {
        if (q.length < et.length) {
          var it = et[0], st;
          H = it.prev;
          var at = q[0], ct = q[q.length - 1];
          for (st = 0; st < q.length; st += 1)
            move(q[st], it, g);
          for (st = 0; st < et.length; st += 1)
            Q.delete(et[st]);
          link(m, at.prev, ct.next), link(m, H, at), link(m, ct, it), G = it, H = ct, X -= 1, q = [], et = [];
        } else
          Q.delete(V), move(V, G, g), link(m, V.prev, V.next), link(m, V, H === null ? m.first : H.next), link(m, H, V), H = V;
        continue;
      }
      for (q = [], et = []; G !== null && G.k !== tt; )
        (G.e.f & INERT) === 0 && (Q ?? (Q = /* @__PURE__ */ new Set())).add(G), et.push(G), G = G.next;
      if (G === null)
        continue;
      V = G;
    }
    q.push(V), H = V, G = V.next;
  }
  if (G !== null || Q !== void 0) {
    for (var K = Q === void 0 ? [] : array_from(Q); G !== null; )
      (G.e.f & INERT) === 0 && K.push(G), G = G.next;
    var lt = K.length;
    if (lt > 0) {
      var vt = (I & EACH_IS_CONTROLLED) !== 0 && Z === 0 ? g : null;
      if (D) {
        for (X = 0; X < lt; X += 1)
          (pt = K[X].a) == null || pt.measure();
        for (X = 0; X < lt; X += 1)
          (Ct = K[X].a) == null || Ct.fix();
      }
      pause_effects(m, K, vt, $);
    }
  }
  D && queue_micro_task(() => {
    var St;
    if (W !== void 0)
      for (V of W)
        (St = V.a) == null || St.apply();
  }), active_effect.first = m.first && m.first.e, active_effect.last = H && H.e;
}
function update_item(d, m, g, w) {
  (w & EACH_ITEM_REACTIVE) !== 0 && internal_set(d.v, m), (w & EACH_INDEX_REACTIVE) !== 0 ? internal_set(
    /** @type {Value<number>} */
    d.i,
    g
  ) : d.i = g;
}
function create_item(d, m, g, w, I, P, F, D, U, Z) {
  var $ = (U & EACH_ITEM_REACTIVE) !== 0, j = (U & EACH_ITEM_IMMUTABLE) === 0, G = $ ? j ? /* @__PURE__ */ mutable_source(I) : source(I) : I, Q = (U & EACH_INDEX_REACTIVE) === 0 ? F : source(F), H = {
    i: Q,
    v: G,
    k: P,
    a: null,
    // @ts-expect-error
    e: null,
    prev: g,
    next: w
  };
  try {
    return H.e = branch(() => D(d, G, Q, Z), hydrating), H.e.prev = g && g.e, H.e.next = w && w.e, g === null ? m.first = H : (g.next = H, g.e.next = H.e), w !== null && (w.prev = H, w.e.prev = H.e), H;
  } finally {
  }
}
function move(d, m, g) {
  for (var w = d.next ? (
    /** @type {TemplateNode} */
    d.next.e.nodes_start
  ) : g, I = m ? (
    /** @type {TemplateNode} */
    m.e.nodes_start
  ) : g, P = (
    /** @type {TemplateNode} */
    d.e.nodes_start
  ); P !== w; ) {
    var F = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(P)
    );
    I.before(P), P = F;
  }
}
function link(d, m, g) {
  m === null ? d.first = g : (m.next = g, m.e.next = g && g.e), g !== null && (g.prev = m, g.e.prev = m && m.e);
}
function html(d, m, g, w, I) {
  var P = d, F = "", D;
  block(() => {
    F !== (F = m() ?? "") && (D !== void 0 && (destroy_effect(D), D = void 0), F !== "" && (D = branch(() => {
      var U = F + "", Z = create_fragment_from_html(U);
      assign_nodes(
        /** @type {TemplateNode} */
        /* @__PURE__ */ get_first_child(Z),
        /** @type {TemplateNode} */
        Z.lastChild
      ), P.before(Z);
    })));
  });
}
function snippet(d, m, ...g) {
  var w = d, I = noop, P;
  block(() => {
    I !== (I = m()) && (P && (destroy_effect(P), P = null), P = branch(() => (
      /** @type {SnippetFn} */
      I(w, ...g)
    )));
  }, EFFECT_TRANSPARENT);
}
function component(d, m, g) {
  var w = d, I, P;
  block(() => {
    I !== (I = m()) && (P && (pause_effect(P), P = null), I && (P = branch(() => g(w, I))));
  }, EFFECT_TRANSPARENT);
}
function append_styles(d, m = !1) {
  var g = m ? " !important;" : ";", w = "";
  for (var I in d) {
    var P = d[I];
    P != null && P !== "" && (w += " " + I + ": " + P + g);
  }
  return w;
}
function to_style(d, m) {
  if (m) {
    var g = "", w, I;
    return Array.isArray(m) ? (w = m[0], I = m[1]) : w = m, w && (g += append_styles(w)), I && (g += append_styles(I, !0)), g = g.trim(), g === "" ? null : g;
  }
  return String(d);
}
function update_styles(d, m = {}, g, w) {
  for (var I in g) {
    var P = g[I];
    m[I] !== P && (g[I] == null ? d.style.removeProperty(I) : d.style.setProperty(I, P, w));
  }
}
function set_style(d, m, g, w) {
  var I = d.__style;
  if (I !== m) {
    var P = to_style(m, w);
    P == null ? d.removeAttribute("style") : d.style.cssText = P, d.__style = m;
  } else w && (Array.isArray(w) ? (update_styles(d, g == null ? void 0 : g[0], w[0]), update_styles(d, g == null ? void 0 : g[1], w[1], "important")) : update_styles(d, g, w));
  return w;
}
const IS_CUSTOM_ELEMENT = Symbol("is custom element"), IS_HTML = Symbol("is html");
function set_attribute(d, m, g, w) {
  var I = get_attributes(d);
  I[m] !== (I[m] = g) && (m === "loading" && (d[LOADING_ATTR_SYMBOL] = g), g == null ? d.removeAttribute(m) : typeof g != "string" && get_setters(d).includes(m) ? d[m] = g : d.setAttribute(m, g));
}
function get_attributes(d) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    d.__attributes ?? (d.__attributes = {
      [IS_CUSTOM_ELEMENT]: d.nodeName.includes("-"),
      [IS_HTML]: d.namespaceURI === NAMESPACE_HTML
    })
  );
}
var setters_cache = /* @__PURE__ */ new Map();
function get_setters(d) {
  var m = setters_cache.get(d.nodeName);
  if (m) return m;
  setters_cache.set(d.nodeName, m = []);
  for (var g, w = d, I = Element.prototype; I !== w; ) {
    g = get_descriptors(w);
    for (var P in g)
      g[P].set && m.push(P);
    w = get_prototype_of(w);
  }
  return m;
}
function bind_value(d, m, g = m) {
  var w = is_runes();
  listen_to_event_and_reset_event(d, "input", (I) => {
    var P = I ? d.defaultValue : d.value;
    if (P = is_numberlike_input(d) ? to_number(P) : P, g(P), w && P !== (P = m())) {
      var F = d.selectionStart, D = d.selectionEnd;
      d.value = P ?? "", D !== null && (d.selectionStart = F, d.selectionEnd = Math.min(D, d.value.length));
    }
  }), // If we are hydrating and the value has since changed,
  // then use the updated value from the input instead.
  // If defaultValue is set, then value == defaultValue
  // TODO Svelte 6: remove input.value check and set to empty string?
  untrack(m) == null && d.value && g(is_numberlike_input(d) ? to_number(d.value) : d.value), render_effect(() => {
    var I = m();
    is_numberlike_input(d) && I === to_number(d.value) || d.type === "date" && !I && !d.value || I !== d.value && (d.value = I ?? "");
  });
}
function is_numberlike_input(d) {
  var m = d.type;
  return m === "number" || m === "range";
}
function to_number(d) {
  return d === "" ? null : +d;
}
function select_option(d, m, g) {
  if (d.multiple)
    return select_options(d, m);
  for (var w of d.options) {
    var I = get_option_value(w);
    if (is(I, m)) {
      w.selected = !0;
      return;
    }
  }
  (!g || m !== void 0) && (d.selectedIndex = -1);
}
function init_select(d, m) {
  effect(() => {
    var g = new MutationObserver(() => {
      var w = d.__value;
      select_option(d, w);
    });
    return g.observe(d, {
      // Listen to option element changes
      childList: !0,
      subtree: !0,
      // because of <optgroup>
      // Listen to option element value attribute changes
      // (doesn't get notified of select value changes,
      // because that property is not reflected as an attribute)
      attributes: !0,
      attributeFilter: ["value"]
    }), () => {
      g.disconnect();
    };
  });
}
function bind_select_value(d, m, g = m) {
  var w = !0;
  listen_to_event_and_reset_event(d, "change", (I) => {
    var P = I ? "[selected]" : ":checked", F;
    if (d.multiple)
      F = [].map.call(d.querySelectorAll(P), get_option_value);
    else {
      var D = d.querySelector(P) ?? // will fall back to first non-disabled option if no option is selected
      d.querySelector("option:not([disabled])");
      F = D && get_option_value(D);
    }
    g(F);
  }), effect(() => {
    var I = m();
    if (select_option(d, I, w), w && I === void 0) {
      var P = d.querySelector(":checked");
      P !== null && (I = get_option_value(P), g(I));
    }
    d.__value = I, w = !1;
  }), init_select(d);
}
function select_options(d, m) {
  for (var g of d.options)
    g.selected = ~m.indexOf(get_option_value(g));
}
function get_option_value(d) {
  return "__value" in d ? d.__value : d.value;
}
function is_bound_this(d, m) {
  return d === m || (d == null ? void 0 : d[STATE_SYMBOL]) === m;
}
function bind_this(d = {}, m, g, w) {
  return effect(() => {
    var I, P;
    return render_effect(() => {
      I = P, P = [], untrack(() => {
        d !== g(...P) && (m(d, ...P), I && is_bound_this(g(...I), d) && m(null, ...I));
      });
    }), () => {
      queue_micro_task(() => {
        P && is_bound_this(g(...P), d) && m(null, ...P);
      });
    };
  }), d;
}
function init$1(d = !1) {
  const m = (
    /** @type {ComponentContextLegacy} */
    component_context
  ), g = m.l.u;
  if (!g) return;
  let w = () => deep_read_state(m.s);
  if (d) {
    let I = 0, P = (
      /** @type {Record<string, any>} */
      {}
    );
    const F = /* @__PURE__ */ derived(() => {
      let D = !1;
      const U = m.s;
      for (const Z in U)
        U[Z] !== P[Z] && (P[Z] = U[Z], D = !0);
      return D && I++, I;
    });
    w = () => get(F);
  }
  g.b.length && user_pre_effect(() => {
    observe_all(m, w), run_all(g.b);
  }), user_effect(() => {
    const I = untrack(() => g.m.map(run));
    return () => {
      for (const P of I)
        typeof P == "function" && P();
    };
  }), g.a.length && user_effect(() => {
    observe_all(m, w), run_all(g.a);
  });
}
function observe_all(d, m) {
  if (d.l.s)
    for (const g of d.l.s) get(g);
  m();
}
let is_store_binding = !1;
function capture_store_binding(d) {
  var m = is_store_binding;
  try {
    return is_store_binding = !1, [d(), is_store_binding];
  } finally {
    is_store_binding = m;
  }
}
const spread_props_handler = {
  get(d, m) {
    let g = d.props.length;
    for (; g--; ) {
      let w = d.props[g];
      if (is_function(w) && (w = w()), typeof w == "object" && w !== null && m in w) return w[m];
    }
  },
  set(d, m, g) {
    let w = d.props.length;
    for (; w--; ) {
      let I = d.props[w];
      is_function(I) && (I = I());
      const P = get_descriptor(I, m);
      if (P && P.set)
        return P.set(g), !0;
    }
    return !1;
  },
  getOwnPropertyDescriptor(d, m) {
    let g = d.props.length;
    for (; g--; ) {
      let w = d.props[g];
      if (is_function(w) && (w = w()), typeof w == "object" && w !== null && m in w) {
        const I = get_descriptor(w, m);
        return I && !I.configurable && (I.configurable = !0), I;
      }
    }
  },
  has(d, m) {
    if (m === STATE_SYMBOL || m === LEGACY_PROPS) return !1;
    for (let g of d.props)
      if (is_function(g) && (g = g()), g != null && m in g) return !0;
    return !1;
  },
  ownKeys(d) {
    const m = [];
    for (let g of d.props) {
      is_function(g) && (g = g());
      for (const w in g)
        m.includes(w) || m.push(w);
    }
    return m;
  }
};
function spread_props(...d) {
  return new Proxy({ props: d }, spread_props_handler);
}
function has_destroyed_component_ctx(d) {
  var m;
  return ((m = d.ctx) == null ? void 0 : m.d) ?? !1;
}
function prop(d, m, g, w) {
  var ot;
  var I = (g & PROPS_IS_IMMUTABLE) !== 0, P = !legacy_mode_flag || (g & PROPS_IS_RUNES) !== 0, F = (g & PROPS_IS_BINDABLE) !== 0, D = (g & PROPS_IS_LAZY_INITIAL) !== 0, U = !1, Z;
  F ? [Z, U] = capture_store_binding(() => (
    /** @type {V} */
    d[m]
  )) : Z = /** @type {V} */
  d[m];
  var $ = STATE_SYMBOL in d || LEGACY_PROPS in d, j = F && (((ot = get_descriptor(d, m)) == null ? void 0 : ot.set) ?? ($ && m in d && ((it) => d[m] = it))) || void 0, G = (
    /** @type {V} */
    w
  ), Q = !0, H = !1, W = () => (H = !0, Q && (Q = !1, D ? G = untrack(
    /** @type {() => V} */
    w
  ) : G = /** @type {V} */
  w), G);
  Z === void 0 && w !== void 0 && (j && P && props_invalid_value(), Z = W(), j && j(Z));
  var q;
  if (P)
    q = () => {
      var it = (
        /** @type {V} */
        d[m]
      );
      return it === void 0 ? W() : (Q = !0, H = !1, it);
    };
  else {
    var et = (I ? derived : derived_safe_equal)(
      () => (
        /** @type {V} */
        d[m]
      )
    );
    et.f |= LEGACY_DERIVED_PROP, q = () => {
      var it = get(et);
      return it !== void 0 && (G = /** @type {V} */
      void 0), it === void 0 ? G : it;
    };
  }
  if ((g & PROPS_IS_UPDATED) === 0)
    return q;
  if (j) {
    var rt = d.$$legacy;
    return function(it, st) {
      return arguments.length > 0 ? ((!P || !st || rt || U) && j(st ? q() : it), it) : q();
    };
  }
  var tt = !1, V = /* @__PURE__ */ mutable_source(Z), X = /* @__PURE__ */ derived(() => {
    var it = q(), st = get(V);
    return tt ? (tt = !1, st) : V.v = it;
  });
  return F && get(X), I || (X.equals = safe_equals), function(it, st) {
    if (arguments.length > 0) {
      const at = st ? get(X) : P && F ? proxy(it) : it;
      if (!X.equals(at)) {
        if (tt = !0, set(V, at), H && G !== void 0 && (G = at), has_destroyed_component_ctx(X))
          return it;
        untrack(() => get(X));
      }
      return it;
    }
    return has_destroyed_component_ctx(X) ? X.v : get(X);
  };
}
function onMount(d) {
  component_context === null && lifecycle_outside_component(), legacy_mode_flag && component_context.l !== null ? init_update_callbacks(component_context).m.push(d) : user_effect(() => {
    const m = untrack(d);
    if (typeof m == "function") return (
      /** @type {() => void} */
      m
    );
  });
}
function init_update_callbacks(d) {
  var m = (
    /** @type {ComponentContextLegacy} */
    d.l
  );
  return m.u ?? (m.u = { a: [], b: [], m: [] });
}
const PUBLIC_VERSION = "5";
var tr;
typeof window < "u" && ((tr = window.__svelte ?? (window.__svelte = {})).v ?? (tr.v = /* @__PURE__ */ new Set())).add(PUBLIC_VERSION);
enable_legacy_mode_flag();
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(d) {
  return d && d.__esModule && Object.prototype.hasOwnProperty.call(d, "default") ? d.default : d;
}
function getAugmentedNamespace(d) {
  if (d.__esModule) return d;
  var m = d.default;
  if (typeof m == "function") {
    var g = function w() {
      return this instanceof w ? Reflect.construct(m, arguments, this.constructor) : m.apply(this, arguments);
    };
    g.prototype = m.prototype;
  } else g = {};
  return Object.defineProperty(g, "__esModule", { value: !0 }), Object.keys(d).forEach(function(w) {
    var I = Object.getOwnPropertyDescriptor(d, w);
    Object.defineProperty(g, w, I.get ? I : { enumerable: !0, get: function() {
      return d[w];
    } });
  }), g;
}
typeof self > "u" && typeof commonjsGlobal == "object" && (commonjsGlobal.self = commonjsGlobal);
var global$1 = typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {}, lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, inited = !1;
function init() {
  inited = !0;
  for (var d = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", m = 0; m < 64; ++m) lookup[m] = d[m], revLookup[d.charCodeAt(m)] = m;
  revLookup[45] = 62, revLookup[95] = 63;
}
function toByteArray(d) {
  var m, g, w, I, P, F;
  inited || init();
  var D = d.length;
  if (D % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
  P = d[D - 2] === "=" ? 2 : d[D - 1] === "=" ? 1 : 0, F = new Arr(3 * D / 4 - P), w = P > 0 ? D - 4 : D;
  var U = 0;
  for (m = 0, g = 0; m < w; m += 4, g += 3) I = revLookup[d.charCodeAt(m)] << 18 | revLookup[d.charCodeAt(m + 1)] << 12 | revLookup[d.charCodeAt(m + 2)] << 6 | revLookup[d.charCodeAt(m + 3)], F[U++] = I >> 16 & 255, F[U++] = I >> 8 & 255, F[U++] = 255 & I;
  return P === 2 ? (I = revLookup[d.charCodeAt(m)] << 2 | revLookup[d.charCodeAt(m + 1)] >> 4, F[U++] = 255 & I) : P === 1 && (I = revLookup[d.charCodeAt(m)] << 10 | revLookup[d.charCodeAt(m + 1)] << 4 | revLookup[d.charCodeAt(m + 2)] >> 2, F[U++] = I >> 8 & 255, F[U++] = 255 & I), F;
}
function tripletToBase64(d) {
  return lookup[d >> 18 & 63] + lookup[d >> 12 & 63] + lookup[d >> 6 & 63] + lookup[63 & d];
}
function encodeChunk(d, m, g) {
  for (var w, I = [], P = m; P < g; P += 3) w = (d[P] << 16) + (d[P + 1] << 8) + d[P + 2], I.push(tripletToBase64(w));
  return I.join("");
}
function fromByteArray(d) {
  var m;
  inited || init();
  for (var g = d.length, w = g % 3, I = "", P = [], F = 16383, D = 0, U = g - w; D < U; D += F) P.push(encodeChunk(d, D, D + F > U ? U : D + F));
  return w === 1 ? (m = d[g - 1], I += lookup[m >> 2], I += lookup[m << 4 & 63], I += "==") : w === 2 && (m = (d[g - 2] << 8) + d[g - 1], I += lookup[m >> 10], I += lookup[m >> 4 & 63], I += lookup[m << 2 & 63], I += "="), P.push(I), P.join("");
}
function read(d, m, g, w, I) {
  var P, F, D = 8 * I - w - 1, U = (1 << D) - 1, Z = U >> 1, $ = -7, j = g ? I - 1 : 0, G = g ? -1 : 1, Q = d[m + j];
  for (j += G, P = Q & (1 << -$) - 1, Q >>= -$, $ += D; $ > 0; P = 256 * P + d[m + j], j += G, $ -= 8) ;
  for (F = P & (1 << -$) - 1, P >>= -$, $ += w; $ > 0; F = 256 * F + d[m + j], j += G, $ -= 8) ;
  if (P === 0) P = 1 - Z;
  else {
    if (P === U) return F ? NaN : 1 / 0 * (Q ? -1 : 1);
    F += Math.pow(2, w), P -= Z;
  }
  return (Q ? -1 : 1) * F * Math.pow(2, P - w);
}
function write(d, m, g, w, I, P) {
  var F, D, U, Z = 8 * P - I - 1, $ = (1 << Z) - 1, j = $ >> 1, G = I === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Q = w ? 0 : P - 1, H = w ? 1 : -1, W = m < 0 || m === 0 && 1 / m < 0 ? 1 : 0;
  for (m = Math.abs(m), isNaN(m) || m === 1 / 0 ? (D = isNaN(m) ? 1 : 0, F = $) : (F = Math.floor(Math.log(m) / Math.LN2), m * (U = Math.pow(2, -F)) < 1 && (F--, U *= 2), (m += F + j >= 1 ? G / U : G * Math.pow(2, 1 - j)) * U >= 2 && (F++, U /= 2), F + j >= $ ? (D = 0, F = $) : F + j >= 1 ? (D = (m * U - 1) * Math.pow(2, I), F += j) : (D = m * Math.pow(2, j - 1) * Math.pow(2, I), F = 0)); I >= 8; d[g + Q] = 255 & D, Q += H, D /= 256, I -= 8) ;
  for (F = F << I | D, Z += I; Z > 0; d[g + Q] = 255 & F, Q += H, F /= 256, Z -= 8) ;
  d[g + Q - H] |= 128 * W;
}
var toString = {}.toString, isArray = Array.isArray || function(d) {
  return toString.call(d) == "[object Array]";
}, INSPECT_MAX_BYTES = 50;
function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(d, m) {
  if (kMaxLength() < m) throw new RangeError("Invalid typed array length");
  return Buffer.TYPED_ARRAY_SUPPORT ? (d = new Uint8Array(m)).__proto__ = Buffer.prototype : (d === null && (d = new Buffer(m)), d.length = m), d;
}
function Buffer(d, m, g) {
  if (!(Buffer.TYPED_ARRAY_SUPPORT || this instanceof Buffer)) return new Buffer(d, m, g);
  if (typeof d == "number") {
    if (typeof m == "string") throw new Error("If encoding is specified then the first argument must be a string");
    return allocUnsafe(this, d);
  }
  return from(this, d, m, g);
}
function from(d, m, g, w) {
  if (typeof m == "number") throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer < "u" && m instanceof ArrayBuffer ? fromArrayBuffer(d, m, g, w) : typeof m == "string" ? fromString(d, m, g) : fromObject(d, m);
}
function assertSize(d) {
  if (typeof d != "number") throw new TypeError('"size" argument must be a number');
  if (d < 0) throw new RangeError('"size" argument must not be negative');
}
function alloc(d, m, g, w) {
  return assertSize(m), m <= 0 ? createBuffer(d, m) : g !== void 0 ? typeof w == "string" ? createBuffer(d, m).fill(g, w) : createBuffer(d, m).fill(g) : createBuffer(d, m);
}
function allocUnsafe(d, m) {
  if (assertSize(m), d = createBuffer(d, m < 0 ? 0 : 0 | checked(m)), !Buffer.TYPED_ARRAY_SUPPORT) for (var g = 0; g < m; ++g) d[g] = 0;
  return d;
}
function fromString(d, m, g) {
  if (typeof g == "string" && g !== "" || (g = "utf8"), !Buffer.isEncoding(g)) throw new TypeError('"encoding" must be a valid string encoding');
  var w = 0 | byteLength(m, g), I = (d = createBuffer(d, w)).write(m, g);
  return I !== w && (d = d.slice(0, I)), d;
}
function fromArrayLike(d, m) {
  var g = m.length < 0 ? 0 : 0 | checked(m.length);
  d = createBuffer(d, g);
  for (var w = 0; w < g; w += 1) d[w] = 255 & m[w];
  return d;
}
function fromArrayBuffer(d, m, g, w) {
  if (m.byteLength, g < 0 || m.byteLength < g) throw new RangeError("'offset' is out of bounds");
  if (m.byteLength < g + (w || 0)) throw new RangeError("'length' is out of bounds");
  return m = g === void 0 && w === void 0 ? new Uint8Array(m) : w === void 0 ? new Uint8Array(m, g) : new Uint8Array(m, g, w), Buffer.TYPED_ARRAY_SUPPORT ? (d = m).__proto__ = Buffer.prototype : d = fromArrayLike(d, m), d;
}
function fromObject(d, m) {
  if (internalIsBuffer(m)) {
    var g = 0 | checked(m.length);
    return (d = createBuffer(d, g)).length === 0 || m.copy(d, 0, 0, g), d;
  }
  if (m) {
    if (typeof ArrayBuffer < "u" && m.buffer instanceof ArrayBuffer || "length" in m) return typeof m.length != "number" || isnan(m.length) ? createBuffer(d, 0) : fromArrayLike(d, m);
    if (m.type === "Buffer" && isArray(m.data)) return fromArrayLike(d, m.data);
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(d) {
  if (d >= kMaxLength()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  return 0 | d;
}
function internalIsBuffer(d) {
  return !(d == null || !d._isBuffer);
}
function byteLength(d, m) {
  if (internalIsBuffer(d)) return d.length;
  if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(d) || d instanceof ArrayBuffer)) return d.byteLength;
  typeof d != "string" && (d = "" + d);
  var g = d.length;
  if (g === 0) return 0;
  for (var w = !1; ; ) switch (m) {
    case "ascii":
    case "latin1":
    case "binary":
      return g;
    case "utf8":
    case "utf-8":
    case void 0:
      return utf8ToBytes(d).length;
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return 2 * g;
    case "hex":
      return g >>> 1;
    case "base64":
      return base64ToBytes(d).length;
    default:
      if (w) return utf8ToBytes(d).length;
      m = ("" + m).toLowerCase(), w = !0;
  }
}
function slowToString(d, m, g) {
  var w = !1;
  if ((m === void 0 || m < 0) && (m = 0), m > this.length || ((g === void 0 || g > this.length) && (g = this.length), g <= 0) || (g >>>= 0) <= (m >>>= 0)) return "";
  for (d || (d = "utf8"); ; ) switch (d) {
    case "hex":
      return hexSlice(this, m, g);
    case "utf8":
    case "utf-8":
      return utf8Slice(this, m, g);
    case "ascii":
      return asciiSlice(this, m, g);
    case "latin1":
    case "binary":
      return latin1Slice(this, m, g);
    case "base64":
      return base64Slice(this, m, g);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return utf16leSlice(this, m, g);
    default:
      if (w) throw new TypeError("Unknown encoding: " + d);
      d = (d + "").toLowerCase(), w = !0;
  }
}
function swap(d, m, g) {
  var w = d[m];
  d[m] = d[g], d[g] = w;
}
function bidirectionalIndexOf(d, m, g, w, I) {
  if (d.length === 0) return -1;
  if (typeof g == "string" ? (w = g, g = 0) : g > 2147483647 ? g = 2147483647 : g < -2147483648 && (g = -2147483648), g = +g, isNaN(g) && (g = I ? 0 : d.length - 1), g < 0 && (g = d.length + g), g >= d.length) {
    if (I) return -1;
    g = d.length - 1;
  } else if (g < 0) {
    if (!I) return -1;
    g = 0;
  }
  if (typeof m == "string" && (m = Buffer.from(m, w)), internalIsBuffer(m)) return m.length === 0 ? -1 : arrayIndexOf(d, m, g, w, I);
  if (typeof m == "number") return m &= 255, Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? I ? Uint8Array.prototype.indexOf.call(d, m, g) : Uint8Array.prototype.lastIndexOf.call(d, m, g) : arrayIndexOf(d, [m], g, w, I);
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(d, m, g, w, I) {
  var P, F = 1, D = d.length, U = m.length;
  if (w !== void 0 && ((w = String(w).toLowerCase()) === "ucs2" || w === "ucs-2" || w === "utf16le" || w === "utf-16le")) {
    if (d.length < 2 || m.length < 2) return -1;
    F = 2, D /= 2, U /= 2, g /= 2;
  }
  function Z(Q, H) {
    return F === 1 ? Q[H] : Q.readUInt16BE(H * F);
  }
  if (I) {
    var $ = -1;
    for (P = g; P < D; P++) if (Z(d, P) === Z(m, $ === -1 ? 0 : P - $)) {
      if ($ === -1 && ($ = P), P - $ + 1 === U) return $ * F;
    } else $ !== -1 && (P -= P - $), $ = -1;
  } else for (g + U > D && (g = D - U), P = g; P >= 0; P--) {
    for (var j = !0, G = 0; G < U; G++) if (Z(d, P + G) !== Z(m, G)) {
      j = !1;
      break;
    }
    if (j) return P;
  }
  return -1;
}
function hexWrite(d, m, g, w) {
  g = Number(g) || 0;
  var I = d.length - g;
  w ? (w = Number(w)) > I && (w = I) : w = I;
  var P = m.length;
  if (P % 2 != 0) throw new TypeError("Invalid hex string");
  w > P / 2 && (w = P / 2);
  for (var F = 0; F < w; ++F) {
    var D = parseInt(m.substr(2 * F, 2), 16);
    if (isNaN(D)) return F;
    d[g + F] = D;
  }
  return F;
}
function utf8Write(d, m, g, w) {
  return blitBuffer(utf8ToBytes(m, d.length - g), d, g, w);
}
function asciiWrite(d, m, g, w) {
  return blitBuffer(asciiToBytes(m), d, g, w);
}
function latin1Write(d, m, g, w) {
  return asciiWrite(d, m, g, w);
}
function base64Write(d, m, g, w) {
  return blitBuffer(base64ToBytes(m), d, g, w);
}
function ucs2Write(d, m, g, w) {
  return blitBuffer(utf16leToBytes(m, d.length - g), d, g, w);
}
function base64Slice(d, m, g) {
  return m === 0 && g === d.length ? fromByteArray(d) : fromByteArray(d.slice(m, g));
}
function utf8Slice(d, m, g) {
  g = Math.min(d.length, g);
  for (var w = [], I = m; I < g; ) {
    var P, F, D, U, Z = d[I], $ = null, j = Z > 239 ? 4 : Z > 223 ? 3 : Z > 191 ? 2 : 1;
    if (I + j <= g) switch (j) {
      case 1:
        Z < 128 && ($ = Z);
        break;
      case 2:
        (192 & (P = d[I + 1])) == 128 && (U = (31 & Z) << 6 | 63 & P) > 127 && ($ = U);
        break;
      case 3:
        P = d[I + 1], F = d[I + 2], (192 & P) == 128 && (192 & F) == 128 && (U = (15 & Z) << 12 | (63 & P) << 6 | 63 & F) > 2047 && (U < 55296 || U > 57343) && ($ = U);
        break;
      case 4:
        P = d[I + 1], F = d[I + 2], D = d[I + 3], (192 & P) == 128 && (192 & F) == 128 && (192 & D) == 128 && (U = (15 & Z) << 18 | (63 & P) << 12 | (63 & F) << 6 | 63 & D) > 65535 && U < 1114112 && ($ = U);
    }
    $ === null ? ($ = 65533, j = 1) : $ > 65535 && ($ -= 65536, w.push($ >>> 10 & 1023 | 55296), $ = 56320 | 1023 & $), w.push($), I += j;
  }
  return decodeCodePointsArray(w);
}
Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT === void 0 || global$1.TYPED_ARRAY_SUPPORT, kMaxLength(), Buffer.poolSize = 8192, Buffer._augment = function(d) {
  return d.__proto__ = Buffer.prototype, d;
}, Buffer.from = function(d, m, g) {
  return from(null, d, m, g);
}, Buffer.TYPED_ARRAY_SUPPORT && (Buffer.prototype.__proto__ = Uint8Array.prototype, Buffer.__proto__ = Uint8Array, typeof Symbol < "u" && Symbol.species && Buffer[Symbol.species]), Buffer.alloc = function(d, m, g) {
  return alloc(null, d, m, g);
}, Buffer.allocUnsafe = function(d) {
  return allocUnsafe(null, d);
}, Buffer.allocUnsafeSlow = function(d) {
  return allocUnsafe(null, d);
}, Buffer.isBuffer = isBuffer, Buffer.compare = function(d, m) {
  if (!internalIsBuffer(d) || !internalIsBuffer(m)) throw new TypeError("Arguments must be Buffers");
  if (d === m) return 0;
  for (var g = d.length, w = m.length, I = 0, P = Math.min(g, w); I < P; ++I) if (d[I] !== m[I]) {
    g = d[I], w = m[I];
    break;
  }
  return g < w ? -1 : w < g ? 1 : 0;
}, Buffer.isEncoding = function(d) {
  switch (String(d).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return !0;
    default:
      return !1;
  }
}, Buffer.concat = function(d, m) {
  if (!isArray(d)) throw new TypeError('"list" argument must be an Array of Buffers');
  if (d.length === 0) return Buffer.alloc(0);
  var g;
  if (m === void 0) for (m = 0, g = 0; g < d.length; ++g) m += d[g].length;
  var w = Buffer.allocUnsafe(m), I = 0;
  for (g = 0; g < d.length; ++g) {
    var P = d[g];
    if (!internalIsBuffer(P)) throw new TypeError('"list" argument must be an Array of Buffers');
    P.copy(w, I), I += P.length;
  }
  return w;
}, Buffer.byteLength = byteLength, Buffer.prototype._isBuffer = !0, Buffer.prototype.swap16 = function() {
  var d = this.length;
  if (d % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var m = 0; m < d; m += 2) swap(this, m, m + 1);
  return this;
}, Buffer.prototype.swap32 = function() {
  var d = this.length;
  if (d % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var m = 0; m < d; m += 4) swap(this, m, m + 3), swap(this, m + 1, m + 2);
  return this;
}, Buffer.prototype.swap64 = function() {
  var d = this.length;
  if (d % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var m = 0; m < d; m += 8) swap(this, m, m + 7), swap(this, m + 1, m + 6), swap(this, m + 2, m + 5), swap(this, m + 3, m + 4);
  return this;
}, Buffer.prototype.toString = function() {
  var d = 0 | this.length;
  return d === 0 ? "" : arguments.length === 0 ? utf8Slice(this, 0, d) : slowToString.apply(this, arguments);
}, Buffer.prototype.equals = function(d) {
  if (!internalIsBuffer(d)) throw new TypeError("Argument must be a Buffer");
  return this === d || Buffer.compare(this, d) === 0;
}, Buffer.prototype.inspect = function() {
  var d = "", m = INSPECT_MAX_BYTES;
  return this.length > 0 && (d = this.toString("hex", 0, m).match(/.{2}/g).join(" "), this.length > m && (d += " ... ")), "<Buffer " + d + ">";
}, Buffer.prototype.compare = function(d, m, g, w, I) {
  if (!internalIsBuffer(d)) throw new TypeError("Argument must be a Buffer");
  if (m === void 0 && (m = 0), g === void 0 && (g = d ? d.length : 0), w === void 0 && (w = 0), I === void 0 && (I = this.length), m < 0 || g > d.length || w < 0 || I > this.length) throw new RangeError("out of range index");
  if (w >= I && m >= g) return 0;
  if (w >= I) return -1;
  if (m >= g) return 1;
  if (this === d) return 0;
  for (var P = (I >>>= 0) - (w >>>= 0), F = (g >>>= 0) - (m >>>= 0), D = Math.min(P, F), U = this.slice(w, I), Z = d.slice(m, g), $ = 0; $ < D; ++$) if (U[$] !== Z[$]) {
    P = U[$], F = Z[$];
    break;
  }
  return P < F ? -1 : F < P ? 1 : 0;
}, Buffer.prototype.includes = function(d, m, g) {
  return this.indexOf(d, m, g) !== -1;
}, Buffer.prototype.indexOf = function(d, m, g) {
  return bidirectionalIndexOf(this, d, m, g, !0);
}, Buffer.prototype.lastIndexOf = function(d, m, g) {
  return bidirectionalIndexOf(this, d, m, g, !1);
}, Buffer.prototype.write = function(d, m, g, w) {
  if (m === void 0) w = "utf8", g = this.length, m = 0;
  else if (g === void 0 && typeof m == "string") w = m, g = this.length, m = 0;
  else {
    if (!isFinite(m)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    m |= 0, isFinite(g) ? (g |= 0, w === void 0 && (w = "utf8")) : (w = g, g = void 0);
  }
  var I = this.length - m;
  if ((g === void 0 || g > I) && (g = I), d.length > 0 && (g < 0 || m < 0) || m > this.length) throw new RangeError("Attempt to write outside buffer bounds");
  w || (w = "utf8");
  for (var P = !1; ; ) switch (w) {
    case "hex":
      return hexWrite(this, d, m, g);
    case "utf8":
    case "utf-8":
      return utf8Write(this, d, m, g);
    case "ascii":
      return asciiWrite(this, d, m, g);
    case "latin1":
    case "binary":
      return latin1Write(this, d, m, g);
    case "base64":
      return base64Write(this, d, m, g);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return ucs2Write(this, d, m, g);
    default:
      if (P) throw new TypeError("Unknown encoding: " + w);
      w = ("" + w).toLowerCase(), P = !0;
  }
}, Buffer.prototype.toJSON = function() {
  return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
};
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(d) {
  var m = d.length;
  if (m <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, d);
  for (var g = "", w = 0; w < m; ) g += String.fromCharCode.apply(String, d.slice(w, w += MAX_ARGUMENTS_LENGTH));
  return g;
}
function asciiSlice(d, m, g) {
  var w = "";
  g = Math.min(d.length, g);
  for (var I = m; I < g; ++I) w += String.fromCharCode(127 & d[I]);
  return w;
}
function latin1Slice(d, m, g) {
  var w = "";
  g = Math.min(d.length, g);
  for (var I = m; I < g; ++I) w += String.fromCharCode(d[I]);
  return w;
}
function hexSlice(d, m, g) {
  var w = d.length;
  (!m || m < 0) && (m = 0), (!g || g < 0 || g > w) && (g = w);
  for (var I = "", P = m; P < g; ++P) I += toHex(d[P]);
  return I;
}
function utf16leSlice(d, m, g) {
  for (var w = d.slice(m, g), I = "", P = 0; P < w.length; P += 2) I += String.fromCharCode(w[P] + 256 * w[P + 1]);
  return I;
}
function checkOffset(d, m, g) {
  if (d % 1 != 0 || d < 0) throw new RangeError("offset is not uint");
  if (d + m > g) throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(d, m, g, w, I, P) {
  if (!internalIsBuffer(d)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (m > I || m < P) throw new RangeError('"value" argument is out of bounds');
  if (g + w > d.length) throw new RangeError("Index out of range");
}
function objectWriteUInt16(d, m, g, w) {
  m < 0 && (m = 65535 + m + 1);
  for (var I = 0, P = Math.min(d.length - g, 2); I < P; ++I) d[g + I] = (m & 255 << 8 * (w ? I : 1 - I)) >>> 8 * (w ? I : 1 - I);
}
function objectWriteUInt32(d, m, g, w) {
  m < 0 && (m = 4294967295 + m + 1);
  for (var I = 0, P = Math.min(d.length - g, 4); I < P; ++I) d[g + I] = m >>> 8 * (w ? I : 3 - I) & 255;
}
function checkIEEE754(d, m, g, w, I, P) {
  if (g + w > d.length) throw new RangeError("Index out of range");
  if (g < 0) throw new RangeError("Index out of range");
}
function writeFloat(d, m, g, w, I) {
  return I || checkIEEE754(d, m, g, 4), write(d, m, g, w, 23, 4), g + 4;
}
function writeDouble(d, m, g, w, I) {
  return I || checkIEEE754(d, m, g, 8), write(d, m, g, w, 52, 8), g + 8;
}
Buffer.prototype.slice = function(d, m) {
  var g, w = this.length;
  if ((d = ~~d) < 0 ? (d += w) < 0 && (d = 0) : d > w && (d = w), (m = m === void 0 ? w : ~~m) < 0 ? (m += w) < 0 && (m = 0) : m > w && (m = w), m < d && (m = d), Buffer.TYPED_ARRAY_SUPPORT) (g = this.subarray(d, m)).__proto__ = Buffer.prototype;
  else {
    var I = m - d;
    g = new Buffer(I, void 0);
    for (var P = 0; P < I; ++P) g[P] = this[P + d];
  }
  return g;
}, Buffer.prototype.readUIntLE = function(d, m, g) {
  d |= 0, m |= 0, g || checkOffset(d, m, this.length);
  for (var w = this[d], I = 1, P = 0; ++P < m && (I *= 256); ) w += this[d + P] * I;
  return w;
}, Buffer.prototype.readUIntBE = function(d, m, g) {
  d |= 0, m |= 0, g || checkOffset(d, m, this.length);
  for (var w = this[d + --m], I = 1; m > 0 && (I *= 256); ) w += this[d + --m] * I;
  return w;
}, Buffer.prototype.readUInt8 = function(d, m) {
  return m || checkOffset(d, 1, this.length), this[d];
}, Buffer.prototype.readUInt16LE = function(d, m) {
  return m || checkOffset(d, 2, this.length), this[d] | this[d + 1] << 8;
}, Buffer.prototype.readUInt16BE = function(d, m) {
  return m || checkOffset(d, 2, this.length), this[d] << 8 | this[d + 1];
}, Buffer.prototype.readUInt32LE = function(d, m) {
  return m || checkOffset(d, 4, this.length), (this[d] | this[d + 1] << 8 | this[d + 2] << 16) + 16777216 * this[d + 3];
}, Buffer.prototype.readUInt32BE = function(d, m) {
  return m || checkOffset(d, 4, this.length), 16777216 * this[d] + (this[d + 1] << 16 | this[d + 2] << 8 | this[d + 3]);
}, Buffer.prototype.readIntLE = function(d, m, g) {
  d |= 0, m |= 0, g || checkOffset(d, m, this.length);
  for (var w = this[d], I = 1, P = 0; ++P < m && (I *= 256); ) w += this[d + P] * I;
  return w >= (I *= 128) && (w -= Math.pow(2, 8 * m)), w;
}, Buffer.prototype.readIntBE = function(d, m, g) {
  d |= 0, m |= 0, g || checkOffset(d, m, this.length);
  for (var w = m, I = 1, P = this[d + --w]; w > 0 && (I *= 256); ) P += this[d + --w] * I;
  return P >= (I *= 128) && (P -= Math.pow(2, 8 * m)), P;
}, Buffer.prototype.readInt8 = function(d, m) {
  return m || checkOffset(d, 1, this.length), 128 & this[d] ? -1 * (255 - this[d] + 1) : this[d];
}, Buffer.prototype.readInt16LE = function(d, m) {
  m || checkOffset(d, 2, this.length);
  var g = this[d] | this[d + 1] << 8;
  return 32768 & g ? 4294901760 | g : g;
}, Buffer.prototype.readInt16BE = function(d, m) {
  m || checkOffset(d, 2, this.length);
  var g = this[d + 1] | this[d] << 8;
  return 32768 & g ? 4294901760 | g : g;
}, Buffer.prototype.readInt32LE = function(d, m) {
  return m || checkOffset(d, 4, this.length), this[d] | this[d + 1] << 8 | this[d + 2] << 16 | this[d + 3] << 24;
}, Buffer.prototype.readInt32BE = function(d, m) {
  return m || checkOffset(d, 4, this.length), this[d] << 24 | this[d + 1] << 16 | this[d + 2] << 8 | this[d + 3];
}, Buffer.prototype.readFloatLE = function(d, m) {
  return m || checkOffset(d, 4, this.length), read(this, d, !0, 23, 4);
}, Buffer.prototype.readFloatBE = function(d, m) {
  return m || checkOffset(d, 4, this.length), read(this, d, !1, 23, 4);
}, Buffer.prototype.readDoubleLE = function(d, m) {
  return m || checkOffset(d, 8, this.length), read(this, d, !0, 52, 8);
}, Buffer.prototype.readDoubleBE = function(d, m) {
  return m || checkOffset(d, 8, this.length), read(this, d, !1, 52, 8);
}, Buffer.prototype.writeUIntLE = function(d, m, g, w) {
  d = +d, m |= 0, g |= 0, w || checkInt(this, d, m, g, Math.pow(2, 8 * g) - 1, 0);
  var I = 1, P = 0;
  for (this[m] = 255 & d; ++P < g && (I *= 256); ) this[m + P] = d / I & 255;
  return m + g;
}, Buffer.prototype.writeUIntBE = function(d, m, g, w) {
  d = +d, m |= 0, g |= 0, w || checkInt(this, d, m, g, Math.pow(2, 8 * g) - 1, 0);
  var I = g - 1, P = 1;
  for (this[m + I] = 255 & d; --I >= 0 && (P *= 256); ) this[m + I] = d / P & 255;
  return m + g;
}, Buffer.prototype.writeUInt8 = function(d, m, g) {
  return d = +d, m |= 0, g || checkInt(this, d, m, 1, 255, 0), Buffer.TYPED_ARRAY_SUPPORT || (d = Math.floor(d)), this[m] = 255 & d, m + 1;
}, Buffer.prototype.writeUInt16LE = function(d, m, g) {
  return d = +d, m |= 0, g || checkInt(this, d, m, 2, 65535, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[m] = 255 & d, this[m + 1] = d >>> 8) : objectWriteUInt16(this, d, m, !0), m + 2;
}, Buffer.prototype.writeUInt16BE = function(d, m, g) {
  return d = +d, m |= 0, g || checkInt(this, d, m, 2, 65535, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[m] = d >>> 8, this[m + 1] = 255 & d) : objectWriteUInt16(this, d, m, !1), m + 2;
}, Buffer.prototype.writeUInt32LE = function(d, m, g) {
  return d = +d, m |= 0, g || checkInt(this, d, m, 4, 4294967295, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[m + 3] = d >>> 24, this[m + 2] = d >>> 16, this[m + 1] = d >>> 8, this[m] = 255 & d) : objectWriteUInt32(this, d, m, !0), m + 4;
}, Buffer.prototype.writeUInt32BE = function(d, m, g) {
  return d = +d, m |= 0, g || checkInt(this, d, m, 4, 4294967295, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[m] = d >>> 24, this[m + 1] = d >>> 16, this[m + 2] = d >>> 8, this[m + 3] = 255 & d) : objectWriteUInt32(this, d, m, !1), m + 4;
}, Buffer.prototype.writeIntLE = function(d, m, g, w) {
  if (d = +d, m |= 0, !w) {
    var I = Math.pow(2, 8 * g - 1);
    checkInt(this, d, m, g, I - 1, -I);
  }
  var P = 0, F = 1, D = 0;
  for (this[m] = 255 & d; ++P < g && (F *= 256); ) d < 0 && D === 0 && this[m + P - 1] !== 0 && (D = 1), this[m + P] = (d / F | 0) - D & 255;
  return m + g;
}, Buffer.prototype.writeIntBE = function(d, m, g, w) {
  if (d = +d, m |= 0, !w) {
    var I = Math.pow(2, 8 * g - 1);
    checkInt(this, d, m, g, I - 1, -I);
  }
  var P = g - 1, F = 1, D = 0;
  for (this[m + P] = 255 & d; --P >= 0 && (F *= 256); ) d < 0 && D === 0 && this[m + P + 1] !== 0 && (D = 1), this[m + P] = (d / F | 0) - D & 255;
  return m + g;
}, Buffer.prototype.writeInt8 = function(d, m, g) {
  return d = +d, m |= 0, g || checkInt(this, d, m, 1, 127, -128), Buffer.TYPED_ARRAY_SUPPORT || (d = Math.floor(d)), d < 0 && (d = 255 + d + 1), this[m] = 255 & d, m + 1;
}, Buffer.prototype.writeInt16LE = function(d, m, g) {
  return d = +d, m |= 0, g || checkInt(this, d, m, 2, 32767, -32768), Buffer.TYPED_ARRAY_SUPPORT ? (this[m] = 255 & d, this[m + 1] = d >>> 8) : objectWriteUInt16(this, d, m, !0), m + 2;
}, Buffer.prototype.writeInt16BE = function(d, m, g) {
  return d = +d, m |= 0, g || checkInt(this, d, m, 2, 32767, -32768), Buffer.TYPED_ARRAY_SUPPORT ? (this[m] = d >>> 8, this[m + 1] = 255 & d) : objectWriteUInt16(this, d, m, !1), m + 2;
}, Buffer.prototype.writeInt32LE = function(d, m, g) {
  return d = +d, m |= 0, g || checkInt(this, d, m, 4, 2147483647, -2147483648), Buffer.TYPED_ARRAY_SUPPORT ? (this[m] = 255 & d, this[m + 1] = d >>> 8, this[m + 2] = d >>> 16, this[m + 3] = d >>> 24) : objectWriteUInt32(this, d, m, !0), m + 4;
}, Buffer.prototype.writeInt32BE = function(d, m, g) {
  return d = +d, m |= 0, g || checkInt(this, d, m, 4, 2147483647, -2147483648), d < 0 && (d = 4294967295 + d + 1), Buffer.TYPED_ARRAY_SUPPORT ? (this[m] = d >>> 24, this[m + 1] = d >>> 16, this[m + 2] = d >>> 8, this[m + 3] = 255 & d) : objectWriteUInt32(this, d, m, !1), m + 4;
}, Buffer.prototype.writeFloatLE = function(d, m, g) {
  return writeFloat(this, d, m, !0, g);
}, Buffer.prototype.writeFloatBE = function(d, m, g) {
  return writeFloat(this, d, m, !1, g);
}, Buffer.prototype.writeDoubleLE = function(d, m, g) {
  return writeDouble(this, d, m, !0, g);
}, Buffer.prototype.writeDoubleBE = function(d, m, g) {
  return writeDouble(this, d, m, !1, g);
}, Buffer.prototype.copy = function(d, m, g, w) {
  if (g || (g = 0), w || w === 0 || (w = this.length), m >= d.length && (m = d.length), m || (m = 0), w > 0 && w < g && (w = g), w === g || d.length === 0 || this.length === 0) return 0;
  if (m < 0) throw new RangeError("targetStart out of bounds");
  if (g < 0 || g >= this.length) throw new RangeError("sourceStart out of bounds");
  if (w < 0) throw new RangeError("sourceEnd out of bounds");
  w > this.length && (w = this.length), d.length - m < w - g && (w = d.length - m + g);
  var I, P = w - g;
  if (this === d && g < m && m < w) for (I = P - 1; I >= 0; --I) d[I + m] = this[I + g];
  else if (P < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) for (I = 0; I < P; ++I) d[I + m] = this[I + g];
  else Uint8Array.prototype.set.call(d, this.subarray(g, g + P), m);
  return P;
}, Buffer.prototype.fill = function(d, m, g, w) {
  if (typeof d == "string") {
    if (typeof m == "string" ? (w = m, m = 0, g = this.length) : typeof g == "string" && (w = g, g = this.length), d.length === 1) {
      var I = d.charCodeAt(0);
      I < 256 && (d = I);
    }
    if (w !== void 0 && typeof w != "string") throw new TypeError("encoding must be a string");
    if (typeof w == "string" && !Buffer.isEncoding(w)) throw new TypeError("Unknown encoding: " + w);
  } else typeof d == "number" && (d &= 255);
  if (m < 0 || this.length < m || this.length < g) throw new RangeError("Out of range index");
  if (g <= m) return this;
  var P;
  if (m >>>= 0, g = g === void 0 ? this.length : g >>> 0, d || (d = 0), typeof d == "number") for (P = m; P < g; ++P) this[P] = d;
  else {
    var F = internalIsBuffer(d) ? d : utf8ToBytes(new Buffer(d, w).toString()), D = F.length;
    for (P = 0; P < g - m; ++P) this[P + m] = F[P % D];
  }
  return this;
};
var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g, HeaderTypes;
function base64clean(d) {
  if ((d = stringtrim(d).replace(INVALID_BASE64_RE, "")).length < 2) return "";
  for (; d.length % 4 != 0; ) d += "=";
  return d;
}
function stringtrim(d) {
  return d.trim ? d.trim() : d.replace(/^\s+|\s+$/g, "");
}
function toHex(d) {
  return d < 16 ? "0" + d.toString(16) : d.toString(16);
}
function utf8ToBytes(d, m) {
  var g;
  m = m || 1 / 0;
  for (var w = d.length, I = null, P = [], F = 0; F < w; ++F) {
    if ((g = d.charCodeAt(F)) > 55295 && g < 57344) {
      if (!I) {
        if (g > 56319) {
          (m -= 3) > -1 && P.push(239, 191, 189);
          continue;
        }
        if (F + 1 === w) {
          (m -= 3) > -1 && P.push(239, 191, 189);
          continue;
        }
        I = g;
        continue;
      }
      if (g < 56320) {
        (m -= 3) > -1 && P.push(239, 191, 189), I = g;
        continue;
      }
      g = 65536 + (I - 55296 << 10 | g - 56320);
    } else I && (m -= 3) > -1 && P.push(239, 191, 189);
    if (I = null, g < 128) {
      if ((m -= 1) < 0) break;
      P.push(g);
    } else if (g < 2048) {
      if ((m -= 2) < 0) break;
      P.push(g >> 6 | 192, 63 & g | 128);
    } else if (g < 65536) {
      if ((m -= 3) < 0) break;
      P.push(g >> 12 | 224, g >> 6 & 63 | 128, 63 & g | 128);
    } else {
      if (!(g < 1114112)) throw new Error("Invalid code point");
      if ((m -= 4) < 0) break;
      P.push(g >> 18 | 240, g >> 12 & 63 | 128, g >> 6 & 63 | 128, 63 & g | 128);
    }
  }
  return P;
}
function asciiToBytes(d) {
  for (var m = [], g = 0; g < d.length; ++g) m.push(255 & d.charCodeAt(g));
  return m;
}
function utf16leToBytes(d, m) {
  for (var g, w, I, P = [], F = 0; F < d.length && !((m -= 2) < 0); ++F) w = (g = d.charCodeAt(F)) >> 8, I = g % 256, P.push(I), P.push(w);
  return P;
}
function base64ToBytes(d) {
  return toByteArray(base64clean(d));
}
function blitBuffer(d, m, g, w) {
  for (var I = 0; I < w && !(I + g >= m.length || I >= d.length); ++I) m[I + g] = d[I];
  return I;
}
function isnan(d) {
  return d != d;
}
function isBuffer(d) {
  return d != null && (!!d._isBuffer || isFastBuffer(d) || isSlowBuffer(d));
}
function isFastBuffer(d) {
  return !!d.constructor && typeof d.constructor.isBuffer == "function" && d.constructor.isBuffer(d);
}
function isSlowBuffer(d) {
  return typeof d.readFloatLE == "function" && typeof d.slice == "function" && isFastBuffer(d.slice(0, 0));
}
(function(d) {
  d[d.BITMAP_INFO_HEADER = 40] = "BITMAP_INFO_HEADER", d[d.BITMAP_V2_INFO_HEADER = 52] = "BITMAP_V2_INFO_HEADER", d[d.BITMAP_V3_INFO_HEADER = 56] = "BITMAP_V3_INFO_HEADER", d[d.BITMAP_V4_HEADER = 108] = "BITMAP_V4_HEADER", d[d.BITMAP_V5_HEADER = 124] = "BITMAP_V5_HEADER";
})(HeaderTypes || (HeaderTypes = {}));
var HeaderTypes$1 = HeaderTypes, BmpCompression;
function maskColor(d, m, g, w) {
  const I = 1 + ~d & d, P = 1 + ~m & m, F = 1 + ~g & g, D = 1 + ~w & w, U = d / I + 1, Z = m / P + 1, $ = g / F + 1, j = w / D + 1;
  return { shiftRed: (G) => (G & d) / I * 256 / U, shiftGreen: (G) => (G & m) / P * 256 / Z, shiftBlue: (G) => (G & g) / F * 256 / $, shiftAlpha: w !== 0 ? (G) => (G & w) / D * 256 / j : () => 255 };
}
(function(d) {
  d[d.NONE = 0] = "NONE", d[d.BI_RLE8 = 1] = "BI_RLE8", d[d.BI_RLE4 = 2] = "BI_RLE4", d[d.BI_BIT_FIELDS = 3] = "BI_BIT_FIELDS", d[d.BI_ALPHA_BIT_FIELDS = 6] = "BI_ALPHA_BIT_FIELDS";
})(BmpCompression || (BmpCompression = {}));
class BmpDecoder {
  constructor(m, { toRGBA: g } = { toRGBA: !1 }) {
    re(this, "flag");
    re(this, "fileSize");
    re(this, "reserved1");
    re(this, "reserved2");
    re(this, "offset");
    re(this, "headerSize");
    re(this, "width");
    re(this, "height");
    re(this, "planes");
    re(this, "bitPP");
    re(this, "compression");
    re(this, "rawSize");
    re(this, "hr");
    re(this, "vr");
    re(this, "colors");
    re(this, "importantColors");
    re(this, "palette");
    re(this, "data");
    re(this, "maskRed");
    re(this, "maskGreen");
    re(this, "maskBlue");
    re(this, "maskAlpha");
    re(this, "toRGBA");
    re(this, "pos");
    re(this, "bottomUp");
    re(this, "buffer");
    re(this, "locRed");
    re(this, "locGreen");
    re(this, "locBlue");
    re(this, "locAlpha");
    re(this, "shiftRed");
    re(this, "shiftGreen");
    re(this, "shiftBlue");
    re(this, "shiftAlpha");
    if (this.buffer = m, this.toRGBA = !!g, this.pos = 0, this.bottomUp = !0, this.flag = this.buffer.toString("utf-8", 0, this.pos += 2), this.flag !== "BM") throw new Error("Invalid BMP File");
    this.locRed = this.toRGBA ? 0 : 3, this.locGreen = this.toRGBA ? 1 : 2, this.locBlue = this.toRGBA ? 2 : 1, this.locAlpha = this.toRGBA ? 3 : 0, this.parseHeader(), this.parseRGBA();
  }
  parseHeader() {
    if (this.fileSize = this.readUInt32LE(), this.reserved1 = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.reserved2 = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.offset = this.readUInt32LE(), this.headerSize = this.readUInt32LE(), !(this.headerSize in HeaderTypes$1)) throw new Error(`Unsupported BMP header size ${this.headerSize}`);
    if (this.width = this.readUInt32LE(), this.height = this.readUInt32LE(), this.height = this.height > 2147483647 ? this.height - 4294967296 : this.height, this.planes = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.bitPP = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.compression = this.readUInt32LE(), this.rawSize = this.readUInt32LE(), this.hr = this.readUInt32LE(), this.vr = this.readUInt32LE(), this.colors = this.readUInt32LE(), this.importantColors = this.readUInt32LE(), this.bitPP === 32 ? (this.maskAlpha = 0, this.maskRed = 16711680, this.maskGreen = 65280, this.maskBlue = 255) : this.bitPP === 16 && (this.maskAlpha = 0, this.maskRed = 31744, this.maskGreen = 992, this.maskBlue = 31), (this.headerSize > HeaderTypes$1.BITMAP_INFO_HEADER || this.compression === BmpCompression.BI_BIT_FIELDS || this.compression === BmpCompression.BI_ALPHA_BIT_FIELDS) && (this.maskRed = this.readUInt32LE(), this.maskGreen = this.readUInt32LE(), this.maskBlue = this.readUInt32LE()), (this.headerSize > HeaderTypes$1.BITMAP_V2_INFO_HEADER || this.compression === BmpCompression.BI_ALPHA_BIT_FIELDS) && (this.maskAlpha = this.readUInt32LE()), this.headerSize > HeaderTypes$1.BITMAP_V3_INFO_HEADER && (this.pos += HeaderTypes$1.BITMAP_V4_HEADER - HeaderTypes$1.BITMAP_V3_INFO_HEADER), this.headerSize > HeaderTypes$1.BITMAP_V4_HEADER && (this.pos += HeaderTypes$1.BITMAP_V5_HEADER - HeaderTypes$1.BITMAP_V4_HEADER), this.bitPP <= 8 || this.colors > 0) {
      const g = this.colors === 0 ? 1 << this.bitPP : this.colors;
      this.palette = new Array(g);
      for (let w = 0; w < g; w++) {
        const I = this.buffer.readUInt8(this.pos++), P = this.buffer.readUInt8(this.pos++), F = this.buffer.readUInt8(this.pos++), D = this.buffer.readUInt8(this.pos++);
        this.palette[w] = { red: F, green: P, blue: I, quad: D };
      }
    }
    this.height < 0 && (this.height *= -1, this.bottomUp = !1);
    const m = maskColor(this.maskRed, this.maskGreen, this.maskBlue, this.maskAlpha);
    this.shiftRed = m.shiftRed, this.shiftGreen = m.shiftGreen, this.shiftBlue = m.shiftBlue, this.shiftAlpha = m.shiftAlpha;
  }
  parseRGBA() {
    switch (this.data = Buffer.alloc(this.width * this.height * 4), this.bitPP) {
      case 1:
        this.bit1();
        break;
      case 4:
        this.bit4();
        break;
      case 8:
        this.bit8();
        break;
      case 16:
        this.bit16();
        break;
      case 24:
        this.bit24();
        break;
      default:
        this.bit32();
    }
  }
  bit1() {
    const m = Math.ceil(this.width / 8), g = m % 4, w = g !== 0 ? 4 - g : 0;
    this.scanImage(w, m, (I, P) => {
      const F = this.buffer.readUInt8(this.pos++), D = P * this.width * 4 + 8 * I * 4;
      for (let U = 0; U < 8 && 8 * I + U < this.width; U++) {
        const Z = this.palette[F >> 7 - U & 1];
        this.data[D + U * this.locAlpha] = 0, this.data[D + 4 * U + this.locBlue] = Z.blue, this.data[D + 4 * U + this.locGreen] = Z.green, this.data[D + 4 * U + this.locRed] = Z.red;
      }
    });
  }
  bit4() {
    if (this.compression === BmpCompression.BI_RLE4) {
      this.data.fill(0);
      let m = !1, g = this.bottomUp ? this.height - 1 : 0, w = 0;
      for (; w < this.data.length; ) {
        const I = this.buffer.readUInt8(this.pos++), P = this.buffer.readUInt8(this.pos++);
        if (I === 0) {
          if (P === 0) {
            g += this.bottomUp ? -1 : 1, w = g * this.width * 4, m = !1;
            continue;
          }
          if (P === 1) break;
          if (P === 2) {
            const F = this.buffer.readUInt8(this.pos++), D = this.buffer.readUInt8(this.pos++);
            g += this.bottomUp ? -D : D, w += D * this.width * 4 + 4 * F;
          } else {
            let F = this.buffer.readUInt8(this.pos++);
            for (let D = 0; D < P; D++) w = this.setPixelData(w, m ? 15 & F : (240 & F) >> 4), 1 & D && D + 1 < P && (F = this.buffer.readUInt8(this.pos++)), m = !m;
            (P + 1 >> 1 & 1) == 1 && this.pos++;
          }
        } else for (let F = 0; F < I; F++) w = this.setPixelData(w, m ? 15 & P : (240 & P) >> 4), m = !m;
      }
    } else {
      const m = Math.ceil(this.width / 2), g = m % 4, w = g !== 0 ? 4 - g : 0;
      this.scanImage(w, m, (I, P) => {
        const F = this.buffer.readUInt8(this.pos++), D = P * this.width * 4 + 2 * I * 4, U = F >> 4;
        let Z = this.palette[U];
        if (this.data[D] = 0, this.data[D + 1] = Z.blue, this.data[D + 2] = Z.green, this.data[D + 3] = Z.red, 2 * I + 1 >= this.width) return !1;
        const $ = 15 & F;
        Z = this.palette[$], this.data[D + 4] = 0, this.data[D + 4 + 1] = Z.blue, this.data[D + 4 + 2] = Z.green, this.data[D + 4 + 3] = Z.red;
      });
    }
  }
  bit8() {
    if (this.compression === BmpCompression.BI_RLE8) {
      this.data.fill(0);
      let m = this.bottomUp ? this.height - 1 : 0, g = 0;
      for (; g < this.data.length; ) {
        const w = this.buffer.readUInt8(this.pos++), I = this.buffer.readUInt8(this.pos++);
        if (w === 0) {
          if (I === 0) {
            m += this.bottomUp ? -1 : 1, g = m * this.width * 4;
            continue;
          }
          if (I === 1) break;
          if (I === 2) {
            const P = this.buffer.readUInt8(this.pos++), F = this.buffer.readUInt8(this.pos++);
            m += this.bottomUp ? -F : F, g += F * this.width * 4 + 4 * P;
          } else {
            for (let P = 0; P < I; P++) {
              const F = this.buffer.readUInt8(this.pos++);
              g = this.setPixelData(g, F);
            }
            !0 & I && this.pos++;
          }
        } else for (let P = 0; P < w; P++) g = this.setPixelData(g, I);
      }
    } else {
      const m = this.width % 4, g = m !== 0 ? 4 - m : 0;
      this.scanImage(g, this.width, (w, I) => {
        const P = this.buffer.readUInt8(this.pos++), F = I * this.width * 4 + 4 * w;
        if (P < this.palette.length) {
          const D = this.palette[P];
          this.data[F] = 0, this.data[F + 1] = D.blue, this.data[F + 2] = D.green, this.data[F + 3] = D.red;
        } else this.data[F] = 0, this.data[F + 1] = 255, this.data[F + 2] = 255, this.data[F + 3] = 255;
      });
    }
  }
  bit16() {
    const m = this.width % 2 * 2;
    this.scanImage(m, this.width, (g, w) => {
      const I = w * this.width * 4 + 4 * g, P = this.buffer.readUInt16LE(this.pos);
      this.pos += 2, this.data[I + this.locRed] = this.shiftRed(P), this.data[I + this.locGreen] = this.shiftGreen(P), this.data[I + this.locBlue] = this.shiftBlue(P), this.data[I + this.locAlpha] = this.shiftAlpha(P);
    });
  }
  bit24() {
    const m = this.width % 4;
    this.scanImage(m, this.width, (g, w) => {
      const I = w * this.width * 4 + 4 * g, P = this.buffer.readUInt8(this.pos++), F = this.buffer.readUInt8(this.pos++), D = this.buffer.readUInt8(this.pos++);
      this.data[I + this.locRed] = D, this.data[I + this.locGreen] = F, this.data[I + this.locBlue] = P, this.data[I + this.locAlpha] = 0;
    });
  }
  bit32() {
    this.scanImage(0, this.width, (m, g) => {
      const w = g * this.width * 4 + 4 * m, I = this.readUInt32LE();
      this.data[w + this.locRed] = this.shiftRed(I), this.data[w + this.locGreen] = this.shiftGreen(I), this.data[w + this.locBlue] = this.shiftBlue(I), this.data[w + this.locAlpha] = this.shiftAlpha(I);
    });
  }
  scanImage(m = 0, g = this.width, w) {
    for (let I = this.height - 1; I >= 0; I--) {
      const P = this.bottomUp ? I : this.height - 1 - I;
      for (let F = 0; F < g; F++)
        if (w.call(this, F, P) === !1) return;
      this.pos += m;
    }
  }
  readUInt32LE() {
    const m = this.buffer.readUInt32LE(this.pos);
    return this.pos += 4, m;
  }
  setPixelData(m, g) {
    const { blue: w, green: I, red: P } = this.palette[g];
    return this.data[m + this.locAlpha] = 0, this.data[m + 1 + this.locBlue] = w, this.data[m + 2 + this.locGreen] = I, this.data[m + 3 + this.locRed] = P, m + 4;
  }
}
function createInteger(d) {
  return d.reduce((m, g) => m << 1 | g, 0);
}
function createColor(d) {
  return d.quad << 24 | d.red << 16 | d.green << 8 | d.blue;
}
class BmpEncoder {
  constructor(m) {
    re(this, "fileSize");
    re(this, "reserved1");
    re(this, "reserved2");
    re(this, "offset");
    re(this, "width");
    re(this, "flag");
    re(this, "height");
    re(this, "planes");
    re(this, "bitPP");
    re(this, "compress");
    re(this, "hr");
    re(this, "vr");
    re(this, "colors");
    re(this, "importantColors");
    re(this, "rawSize");
    re(this, "headerSize");
    re(this, "data");
    re(this, "palette");
    re(this, "extraBytes");
    re(this, "buffer");
    re(this, "bytesInColor");
    re(this, "pos");
    switch (this.buffer = m.data, this.width = m.width, this.height = m.height, this.headerSize = HeaderTypes$1.BITMAP_INFO_HEADER, this.flag = "BM", this.bitPP = m.bitPP || 24, this.offset = 54, this.reserved1 = m.reserved1 || 0, this.reserved2 = m.reserved2 || 0, this.planes = 1, this.compress = 0, this.hr = m.hr || 0, this.vr = m.vr || 0, this.importantColors = m.importantColors || 0, this.colors = Math.min(2 ** (this.bitPP - 1 || 1), m.colors || 1 / 0), this.palette = m.palette || [], this.colors && this.bitPP < 16 ? this.offset += 4 * this.colors : this.colors = 0, this.bitPP) {
      case 32:
        this.bytesInColor = 4;
        break;
      case 16:
        this.bytesInColor = 2;
        break;
      case 8:
        this.bytesInColor = 1;
        break;
      case 4:
        this.bytesInColor = 0.5;
        break;
      case 1:
        this.bytesInColor = 1 / 8;
        break;
      default:
        this.bytesInColor = 3, this.bitPP = 24;
    }
    const g = this.width * this.bitPP / 32, w = Math.ceil(g);
    this.extraBytes = 4 * (w - g), this.rawSize = this.height * w * 4 + 2, this.fileSize = this.rawSize + this.offset, this.data = Buffer.alloc(this.fileSize, 1), this.pos = 0, this.encode();
  }
  encode() {
    switch (this.pos = 0, this.writeHeader(), this.bitPP) {
      case 32:
        this.bit32();
        break;
      case 16:
        this.bit16();
        break;
      case 8:
        this.bit8();
        break;
      case 4:
        this.bit4();
        break;
      case 1:
        this.bit1();
        break;
      default:
        this.bit24();
    }
  }
  writeHeader() {
    this.data.write(this.flag, this.pos, 2), this.pos += 2, this.writeUInt32LE(this.fileSize), this.writeUInt32LE(this.reserved1 << 16 | this.reserved2), this.writeUInt32LE(this.offset), this.writeUInt32LE(this.headerSize), this.writeUInt32LE(this.width), this.writeUInt32LE(this.height), this.data.writeUInt16LE(this.planes, this.pos), this.pos += 2, this.data.writeUInt16LE(this.bitPP, this.pos), this.pos += 2, this.writeUInt32LE(this.compress), this.writeUInt32LE(this.rawSize), this.writeUInt32LE(this.hr), this.writeUInt32LE(this.vr), this.writeUInt32LE(this.colors), this.writeUInt32LE(this.importantColors);
  }
  bit1() {
    this.palette.length && this.colors === 2 ? this.initColors(1) : (this.writeUInt32LE(16777215), this.writeUInt32LE(0)), this.pos += 1;
    let m = [];
    this.writeImage((g, w, I) => {
      let P = w;
      P++;
      const F = this.buffer[P++], D = this.buffer[P++], U = 0.2126 * this.buffer[P++] + 0.7152 * D + 0.0722 * F;
      return m.push(U > 127 ? 0 : 1), (I + 1) % 8 == 0 ? (this.data[g - 1] = createInteger(m), m = []) : I === this.width - 1 && m.length > 0 && (this.data[g - 1] = createInteger(m) << 4, m = []), P;
    });
  }
  bit4() {
    const m = this.initColors(4);
    let g = [];
    this.writeImage((w, I, P) => {
      let F = I;
      const D = createColor({ quad: this.buffer[F++], blue: this.buffer[F++], green: this.buffer[F++], red: this.buffer[F++] }), U = m.findIndex((Z) => Z === D);
      return U !== -1 ? g.push(U) : g.push(0), (P + 1) % 2 == 0 && (this.data[w] = g[0] << 4 | g[1], g = []), F;
    });
  }
  bit8() {
    const m = this.initColors(8);
    this.writeImage((g, w) => {
      let I = w;
      const P = createColor({ quad: this.buffer[I++], blue: this.buffer[I++], green: this.buffer[I++], red: this.buffer[I++] }), F = m.findIndex((D) => D === P);
      return this.data[g] = F !== -1 ? F : 0, I;
    });
  }
  bit16() {
    this.writeImage((m, g) => {
      let w = g + 1;
      const I = this.buffer[w++] / 8, P = this.buffer[w++] / 8, F = this.buffer[w++] / 8 << 10 | P << 5 | I;
      return this.data[m] = 255 & F, this.data[m + 1] = (65280 & F) >> 8, w;
    });
  }
  bit24() {
    this.writeImage((m, g) => {
      let w = g + 1;
      return this.data[m] = this.buffer[w++], this.data[m + 1] = this.buffer[w++], this.data[m + 2] = this.buffer[w++], w;
    });
  }
  bit32() {
    this.writeImage((m, g) => {
      let w = g;
      return this.data[m + 3] = this.buffer[w++], this.data[m] = this.buffer[w++], this.data[m + 1] = this.buffer[w++], this.data[m + 2] = this.buffer[w++], w;
    });
  }
  writeImage(m) {
    const g = this.extraBytes + this.width * this.bytesInColor;
    let w = 0;
    for (let I = 0; I < this.height; I++) for (let P = 0; P < this.width; P++) {
      const F = Math.floor(this.pos + (this.height - 1 - I) * g + P * this.bytesInColor);
      w = m.call(this, F, w, P, I);
    }
  }
  initColors(m) {
    const g = [];
    if (!this.palette.length) throw new Error(`To encode ${m}-bit BMPs a pallette is needed. Please choose up to ${this.colors} colors. Colors must be 32-bit integers.`);
    for (let w = 0; w < this.colors; w++) {
      const I = createColor(this.palette[w]);
      this.writeUInt32LE(I), g.push(I);
    }
    return g;
  }
  writeUInt32LE(m) {
    this.data.writeUInt32LE(m, this.pos), this.pos += 4;
  }
}
function decode$2(d, m) {
  return new BmpDecoder(d, m);
}
function encode$2(d) {
  return new BmpEncoder(d);
}
function _typeof(d) {
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(m) {
    return typeof m;
  } : function(m) {
    return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
  }, _typeof(d);
}
var trimLeft = /^\s+/, trimRight = /\s+$/;
function tinycolor(d, m) {
  if (m = m || {}, (d = d || "") instanceof tinycolor) return d;
  if (!(this instanceof tinycolor)) return new tinycolor(d, m);
  var g = inputToRGB(d);
  this._originalInput = d, this._r = g.r, this._g = g.g, this._b = g.b, this._a = g.a, this._roundA = Math.round(100 * this._a) / 100, this._format = m.format || g.format, this._gradientType = m.gradientType, this._r < 1 && (this._r = Math.round(this._r)), this._g < 1 && (this._g = Math.round(this._g)), this._b < 1 && (this._b = Math.round(this._b)), this._ok = g.ok;
}
function inputToRGB(d) {
  var m = { r: 0, g: 0, b: 0 }, g = 1, w = null, I = null, P = null, F = !1, D = !1;
  return typeof d == "string" && (d = stringInputToObject(d)), _typeof(d) == "object" && (isValidCSSUnit(d.r) && isValidCSSUnit(d.g) && isValidCSSUnit(d.b) ? (m = rgbToRgb(d.r, d.g, d.b), F = !0, D = String(d.r).substr(-1) === "%" ? "prgb" : "rgb") : isValidCSSUnit(d.h) && isValidCSSUnit(d.s) && isValidCSSUnit(d.v) ? (w = convertToPercentage(d.s), I = convertToPercentage(d.v), m = hsvToRgb(d.h, w, I), F = !0, D = "hsv") : isValidCSSUnit(d.h) && isValidCSSUnit(d.s) && isValidCSSUnit(d.l) && (w = convertToPercentage(d.s), P = convertToPercentage(d.l), m = hslToRgb(d.h, w, P), F = !0, D = "hsl"), d.hasOwnProperty("a") && (g = d.a)), g = boundAlpha(g), { ok: F, format: d.format || D, r: Math.min(255, Math.max(m.r, 0)), g: Math.min(255, Math.max(m.g, 0)), b: Math.min(255, Math.max(m.b, 0)), a: g };
}
function rgbToRgb(d, m, g) {
  return { r: 255 * bound01(d, 255), g: 255 * bound01(m, 255), b: 255 * bound01(g, 255) };
}
function rgbToHsl(d, m, g) {
  d = bound01(d, 255), m = bound01(m, 255), g = bound01(g, 255);
  var w, I, P = Math.max(d, m, g), F = Math.min(d, m, g), D = (P + F) / 2;
  if (P == F) w = I = 0;
  else {
    var U = P - F;
    switch (I = D > 0.5 ? U / (2 - P - F) : U / (P + F), P) {
      case d:
        w = (m - g) / U + (m < g ? 6 : 0);
        break;
      case m:
        w = (g - d) / U + 2;
        break;
      case g:
        w = (d - m) / U + 4;
    }
    w /= 6;
  }
  return { h: w, s: I, l: D };
}
function hslToRgb(d, m, g) {
  var w, I, P;
  function F(Z, $, j) {
    return j < 0 && (j += 1), j > 1 && (j -= 1), j < 1 / 6 ? Z + 6 * ($ - Z) * j : j < 0.5 ? $ : j < 2 / 3 ? Z + ($ - Z) * (2 / 3 - j) * 6 : Z;
  }
  if (d = bound01(d, 360), m = bound01(m, 100), g = bound01(g, 100), m === 0) w = I = P = g;
  else {
    var D = g < 0.5 ? g * (1 + m) : g + m - g * m, U = 2 * g - D;
    w = F(U, D, d + 1 / 3), I = F(U, D, d), P = F(U, D, d - 1 / 3);
  }
  return { r: 255 * w, g: 255 * I, b: 255 * P };
}
function rgbToHsv(d, m, g) {
  d = bound01(d, 255), m = bound01(m, 255), g = bound01(g, 255);
  var w, I, P = Math.max(d, m, g), F = Math.min(d, m, g), D = P, U = P - F;
  if (I = P === 0 ? 0 : U / P, P == F) w = 0;
  else {
    switch (P) {
      case d:
        w = (m - g) / U + (m < g ? 6 : 0);
        break;
      case m:
        w = (g - d) / U + 2;
        break;
      case g:
        w = (d - m) / U + 4;
    }
    w /= 6;
  }
  return { h: w, s: I, v: D };
}
function hsvToRgb(d, m, g) {
  d = 6 * bound01(d, 360), m = bound01(m, 100), g = bound01(g, 100);
  var w = Math.floor(d), I = d - w, P = g * (1 - m), F = g * (1 - I * m), D = g * (1 - (1 - I) * m), U = w % 6;
  return { r: 255 * [g, F, P, P, D, g][U], g: 255 * [D, g, g, F, P, P][U], b: 255 * [P, P, D, g, g, F][U] };
}
function rgbToHex(d, m, g, w) {
  var I = [pad2(Math.round(d).toString(16)), pad2(Math.round(m).toString(16)), pad2(Math.round(g).toString(16))];
  return w && I[0].charAt(0) == I[0].charAt(1) && I[1].charAt(0) == I[1].charAt(1) && I[2].charAt(0) == I[2].charAt(1) ? I[0].charAt(0) + I[1].charAt(0) + I[2].charAt(0) : I.join("");
}
function rgbaToHex(d, m, g, w, I) {
  var P = [pad2(Math.round(d).toString(16)), pad2(Math.round(m).toString(16)), pad2(Math.round(g).toString(16)), pad2(convertDecimalToHex(w))];
  return I && P[0].charAt(0) == P[0].charAt(1) && P[1].charAt(0) == P[1].charAt(1) && P[2].charAt(0) == P[2].charAt(1) && P[3].charAt(0) == P[3].charAt(1) ? P[0].charAt(0) + P[1].charAt(0) + P[2].charAt(0) + P[3].charAt(0) : P.join("");
}
function rgbaToArgbHex(d, m, g, w) {
  return [pad2(convertDecimalToHex(w)), pad2(Math.round(d).toString(16)), pad2(Math.round(m).toString(16)), pad2(Math.round(g).toString(16))].join("");
}
function _desaturate(d, m) {
  m = m === 0 ? 0 : m || 10;
  var g = tinycolor(d).toHsl();
  return g.s -= m / 100, g.s = clamp01(g.s), tinycolor(g);
}
function _saturate(d, m) {
  m = m === 0 ? 0 : m || 10;
  var g = tinycolor(d).toHsl();
  return g.s += m / 100, g.s = clamp01(g.s), tinycolor(g);
}
function _greyscale(d) {
  return tinycolor(d).desaturate(100);
}
function _lighten(d, m) {
  m = m === 0 ? 0 : m || 10;
  var g = tinycolor(d).toHsl();
  return g.l += m / 100, g.l = clamp01(g.l), tinycolor(g);
}
function _brighten(d, m) {
  m = m === 0 ? 0 : m || 10;
  var g = tinycolor(d).toRgb();
  return g.r = Math.max(0, Math.min(255, g.r - Math.round(-m / 100 * 255))), g.g = Math.max(0, Math.min(255, g.g - Math.round(-m / 100 * 255))), g.b = Math.max(0, Math.min(255, g.b - Math.round(-m / 100 * 255))), tinycolor(g);
}
function _darken(d, m) {
  m = m === 0 ? 0 : m || 10;
  var g = tinycolor(d).toHsl();
  return g.l -= m / 100, g.l = clamp01(g.l), tinycolor(g);
}
function _spin(d, m) {
  var g = tinycolor(d).toHsl(), w = (g.h + m) % 360;
  return g.h = w < 0 ? 360 + w : w, tinycolor(g);
}
function _complement(d) {
  var m = tinycolor(d).toHsl();
  return m.h = (m.h + 180) % 360, tinycolor(m);
}
function polyad(d, m) {
  if (isNaN(m) || m <= 0) throw new Error("Argument to polyad must be a positive number");
  for (var g = tinycolor(d).toHsl(), w = [tinycolor(d)], I = 360 / m, P = 1; P < m; P++) w.push(tinycolor({ h: (g.h + P * I) % 360, s: g.s, l: g.l }));
  return w;
}
function _splitcomplement(d) {
  var m = tinycolor(d).toHsl(), g = m.h;
  return [tinycolor(d), tinycolor({ h: (g + 72) % 360, s: m.s, l: m.l }), tinycolor({ h: (g + 216) % 360, s: m.s, l: m.l })];
}
function _analogous(d, m, g) {
  m = m || 6, g = g || 30;
  var w = tinycolor(d).toHsl(), I = 360 / g, P = [tinycolor(d)];
  for (w.h = (w.h - (I * m >> 1) + 720) % 360; --m; ) w.h = (w.h + I) % 360, P.push(tinycolor(w));
  return P;
}
function _monochromatic(d, m) {
  m = m || 6;
  for (var g = tinycolor(d).toHsv(), w = g.h, I = g.s, P = g.v, F = [], D = 1 / m; m--; ) F.push(tinycolor({ h: w, s: I, v: P })), P = (P + D) % 1;
  return F;
}
tinycolor.prototype = { isDark: function() {
  return this.getBrightness() < 128;
}, isLight: function() {
  return !this.isDark();
}, isValid: function() {
  return this._ok;
}, getOriginalInput: function() {
  return this._originalInput;
}, getFormat: function() {
  return this._format;
}, getAlpha: function() {
  return this._a;
}, getBrightness: function() {
  var d = this.toRgb();
  return (299 * d.r + 587 * d.g + 114 * d.b) / 1e3;
}, getLuminance: function() {
  var d, m, g, w = this.toRgb();
  return d = w.r / 255, m = w.g / 255, g = w.b / 255, 0.2126 * (d <= 0.03928 ? d / 12.92 : Math.pow((d + 0.055) / 1.055, 2.4)) + 0.7152 * (m <= 0.03928 ? m / 12.92 : Math.pow((m + 0.055) / 1.055, 2.4)) + 0.0722 * (g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4));
}, setAlpha: function(d) {
  return this._a = boundAlpha(d), this._roundA = Math.round(100 * this._a) / 100, this;
}, toHsv: function() {
  var d = rgbToHsv(this._r, this._g, this._b);
  return { h: 360 * d.h, s: d.s, v: d.v, a: this._a };
}, toHsvString: function() {
  var d = rgbToHsv(this._r, this._g, this._b), m = Math.round(360 * d.h), g = Math.round(100 * d.s), w = Math.round(100 * d.v);
  return this._a == 1 ? "hsv(" + m + ", " + g + "%, " + w + "%)" : "hsva(" + m + ", " + g + "%, " + w + "%, " + this._roundA + ")";
}, toHsl: function() {
  var d = rgbToHsl(this._r, this._g, this._b);
  return { h: 360 * d.h, s: d.s, l: d.l, a: this._a };
}, toHslString: function() {
  var d = rgbToHsl(this._r, this._g, this._b), m = Math.round(360 * d.h), g = Math.round(100 * d.s), w = Math.round(100 * d.l);
  return this._a == 1 ? "hsl(" + m + ", " + g + "%, " + w + "%)" : "hsla(" + m + ", " + g + "%, " + w + "%, " + this._roundA + ")";
}, toHex: function(d) {
  return rgbToHex(this._r, this._g, this._b, d);
}, toHexString: function(d) {
  return "#" + this.toHex(d);
}, toHex8: function(d) {
  return rgbaToHex(this._r, this._g, this._b, this._a, d);
}, toHex8String: function(d) {
  return "#" + this.toHex8(d);
}, toRgb: function() {
  return { r: Math.round(this._r), g: Math.round(this._g), b: Math.round(this._b), a: this._a };
}, toRgbString: function() {
  return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
}, toPercentageRgb: function() {
  return { r: Math.round(100 * bound01(this._r, 255)) + "%", g: Math.round(100 * bound01(this._g, 255)) + "%", b: Math.round(100 * bound01(this._b, 255)) + "%", a: this._a };
}, toPercentageRgbString: function() {
  return this._a == 1 ? "rgb(" + Math.round(100 * bound01(this._r, 255)) + "%, " + Math.round(100 * bound01(this._g, 255)) + "%, " + Math.round(100 * bound01(this._b, 255)) + "%)" : "rgba(" + Math.round(100 * bound01(this._r, 255)) + "%, " + Math.round(100 * bound01(this._g, 255)) + "%, " + Math.round(100 * bound01(this._b, 255)) + "%, " + this._roundA + ")";
}, toName: function() {
  return this._a === 0 ? "transparent" : !(this._a < 1) && (hexNames[rgbToHex(this._r, this._g, this._b, !0)] || !1);
}, toFilter: function(d) {
  var m = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a), g = m, w = this._gradientType ? "GradientType = 1, " : "";
  if (d) {
    var I = tinycolor(d);
    g = "#" + rgbaToArgbHex(I._r, I._g, I._b, I._a);
  }
  return "progid:DXImageTransform.Microsoft.gradient(" + w + "startColorstr=" + m + ",endColorstr=" + g + ")";
}, toString: function(d) {
  var m = !!d;
  d = d || this._format;
  var g = !1, w = this._a < 1 && this._a >= 0;
  return m || !w || d !== "hex" && d !== "hex6" && d !== "hex3" && d !== "hex4" && d !== "hex8" && d !== "name" ? (d === "rgb" && (g = this.toRgbString()), d === "prgb" && (g = this.toPercentageRgbString()), d !== "hex" && d !== "hex6" || (g = this.toHexString()), d === "hex3" && (g = this.toHexString(!0)), d === "hex4" && (g = this.toHex8String(!0)), d === "hex8" && (g = this.toHex8String()), d === "name" && (g = this.toName()), d === "hsl" && (g = this.toHslString()), d === "hsv" && (g = this.toHsvString()), g || this.toHexString()) : d === "name" && this._a === 0 ? this.toName() : this.toRgbString();
}, clone: function() {
  return tinycolor(this.toString());
}, _applyModification: function(d, m) {
  var g = d.apply(null, [this].concat([].slice.call(m)));
  return this._r = g._r, this._g = g._g, this._b = g._b, this.setAlpha(g._a), this;
}, lighten: function() {
  return this._applyModification(_lighten, arguments);
}, brighten: function() {
  return this._applyModification(_brighten, arguments);
}, darken: function() {
  return this._applyModification(_darken, arguments);
}, desaturate: function() {
  return this._applyModification(_desaturate, arguments);
}, saturate: function() {
  return this._applyModification(_saturate, arguments);
}, greyscale: function() {
  return this._applyModification(_greyscale, arguments);
}, spin: function() {
  return this._applyModification(_spin, arguments);
}, _applyCombination: function(d, m) {
  return d.apply(null, [this].concat([].slice.call(m)));
}, analogous: function() {
  return this._applyCombination(_analogous, arguments);
}, complement: function() {
  return this._applyCombination(_complement, arguments);
}, monochromatic: function() {
  return this._applyCombination(_monochromatic, arguments);
}, splitcomplement: function() {
  return this._applyCombination(_splitcomplement, arguments);
}, triad: function() {
  return this._applyCombination(polyad, [3]);
}, tetrad: function() {
  return this._applyCombination(polyad, [4]);
} }, tinycolor.fromRatio = function(d, m) {
  if (_typeof(d) == "object") {
    var g = {};
    for (var w in d) d.hasOwnProperty(w) && (g[w] = w === "a" ? d[w] : convertToPercentage(d[w]));
    d = g;
  }
  return tinycolor(d, m);
}, tinycolor.equals = function(d, m) {
  return !(!d || !m) && tinycolor(d).toRgbString() == tinycolor(m).toRgbString();
}, tinycolor.random = function() {
  return tinycolor.fromRatio({ r: Math.random(), g: Math.random(), b: Math.random() });
}, tinycolor.mix = function(d, m, g) {
  g = g === 0 ? 0 : g || 50;
  var w = tinycolor(d).toRgb(), I = tinycolor(m).toRgb(), P = g / 100;
  return tinycolor({ r: (I.r - w.r) * P + w.r, g: (I.g - w.g) * P + w.g, b: (I.b - w.b) * P + w.b, a: (I.a - w.a) * P + w.a });
}, tinycolor.readability = function(d, m) {
  var g = tinycolor(d), w = tinycolor(m);
  return (Math.max(g.getLuminance(), w.getLuminance()) + 0.05) / (Math.min(g.getLuminance(), w.getLuminance()) + 0.05);
}, tinycolor.isReadable = function(d, m, g) {
  var w, I, P = tinycolor.readability(d, m);
  switch (I = !1, (w = validateWCAG2Parms(g)).level + w.size) {
    case "AAsmall":
    case "AAAlarge":
      I = P >= 4.5;
      break;
    case "AAlarge":
      I = P >= 3;
      break;
    case "AAAsmall":
      I = P >= 7;
  }
  return I;
}, tinycolor.mostReadable = function(d, m, g) {
  var w, I, P, F, D = null, U = 0;
  I = (g = g || {}).includeFallbackColors, P = g.level, F = g.size;
  for (var Z = 0; Z < m.length; Z++) (w = tinycolor.readability(d, m[Z])) > U && (U = w, D = tinycolor(m[Z]));
  return tinycolor.isReadable(d, D, { level: P, size: F }) || !I ? D : (g.includeFallbackColors = !1, tinycolor.mostReadable(d, ["#fff", "#000"], g));
};
var names$1 = tinycolor.names = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "0ff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000", blanchedalmond: "ffebcd", blue: "00f", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", burntsienna: "ea7e5d", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "0ff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkgrey: "a9a9a9", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkslategrey: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dimgrey: "696969", dodgerblue: "1e90ff", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "f0f", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", grey: "808080", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgray: "d3d3d3", lightgreen: "90ee90", lightgrey: "d3d3d3", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslategray: "789", lightslategrey: "789", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "0f0", limegreen: "32cd32", linen: "faf0e6", magenta: "f0f", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370db", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "db7093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", rebeccapurple: "663399", red: "f00", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", slategrey: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", wheat: "f5deb3", white: "fff", whitesmoke: "f5f5f5", yellow: "ff0", yellowgreen: "9acd32" }, hexNames = tinycolor.hexNames = flip(names$1);
function flip(d) {
  var m = {};
  for (var g in d) d.hasOwnProperty(g) && (m[d[g]] = g);
  return m;
}
function boundAlpha(d) {
  return d = parseFloat(d), (isNaN(d) || d < 0 || d > 1) && (d = 1), d;
}
function bound01(d, m) {
  isOnePointZero(d) && (d = "100%");
  var g = isPercentage(d);
  return d = Math.min(m, Math.max(0, parseFloat(d))), g && (d = parseInt(d * m, 10) / 100), Math.abs(d - m) < 1e-6 ? 1 : d % m / parseFloat(m);
}
function clamp01(d) {
  return Math.min(1, Math.max(0, d));
}
function parseIntFromHex(d) {
  return parseInt(d, 16);
}
function isOnePointZero(d) {
  return typeof d == "string" && d.indexOf(".") != -1 && parseFloat(d) === 1;
}
function isPercentage(d) {
  return typeof d == "string" && d.indexOf("%") != -1;
}
function pad2(d) {
  return d.length == 1 ? "0" + d : "" + d;
}
function convertToPercentage(d) {
  return d <= 1 && (d = 100 * d + "%"), d;
}
function convertDecimalToHex(d) {
  return Math.round(255 * parseFloat(d)).toString(16);
}
function convertHexToDecimal(d) {
  return parseIntFromHex(d) / 255;
}
var matchers = (CSS_UNIT = "(?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?)", PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?", PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?", { CSS_UNIT: new RegExp(CSS_UNIT), rgb: new RegExp("rgb" + PERMISSIVE_MATCH3), rgba: new RegExp("rgba" + PERMISSIVE_MATCH4), hsl: new RegExp("hsl" + PERMISSIVE_MATCH3), hsla: new RegExp("hsla" + PERMISSIVE_MATCH4), hsv: new RegExp("hsv" + PERMISSIVE_MATCH3), hsva: new RegExp("hsva" + PERMISSIVE_MATCH4), hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/, hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/ }), CSS_UNIT, PERMISSIVE_MATCH3, PERMISSIVE_MATCH4;
function isValidCSSUnit(d) {
  return !!matchers.CSS_UNIT.exec(d);
}
function stringInputToObject(d) {
  d = d.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var m, g = !1;
  if (names$1[d]) d = names$1[d], g = !0;
  else if (d == "transparent") return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  return (m = matchers.rgb.exec(d)) ? { r: m[1], g: m[2], b: m[3] } : (m = matchers.rgba.exec(d)) ? { r: m[1], g: m[2], b: m[3], a: m[4] } : (m = matchers.hsl.exec(d)) ? { h: m[1], s: m[2], l: m[3] } : (m = matchers.hsla.exec(d)) ? { h: m[1], s: m[2], l: m[3], a: m[4] } : (m = matchers.hsv.exec(d)) ? { h: m[1], s: m[2], v: m[3] } : (m = matchers.hsva.exec(d)) ? { h: m[1], s: m[2], v: m[3], a: m[4] } : (m = matchers.hex8.exec(d)) ? { r: parseIntFromHex(m[1]), g: parseIntFromHex(m[2]), b: parseIntFromHex(m[3]), a: convertHexToDecimal(m[4]), format: g ? "name" : "hex8" } : (m = matchers.hex6.exec(d)) ? { r: parseIntFromHex(m[1]), g: parseIntFromHex(m[2]), b: parseIntFromHex(m[3]), format: g ? "name" : "hex" } : (m = matchers.hex4.exec(d)) ? { r: parseIntFromHex(m[1] + "" + m[1]), g: parseIntFromHex(m[2] + "" + m[2]), b: parseIntFromHex(m[3] + "" + m[3]), a: convertHexToDecimal(m[4] + "" + m[4]), format: g ? "name" : "hex8" } : !!(m = matchers.hex3.exec(d)) && { r: parseIntFromHex(m[1] + "" + m[1]), g: parseIntFromHex(m[2] + "" + m[2]), b: parseIntFromHex(m[3] + "" + m[3]), format: g ? "name" : "hex" };
}
function validateWCAG2Parms(d) {
  var m, g;
  return (m = ((d = d || { level: "AA", size: "small" }).level || "AA").toUpperCase()) !== "AA" && m !== "AAA" && (m = "AA"), (g = (d.size || "small").toLowerCase()) !== "small" && g !== "large" && (g = "small"), { level: m, size: g };
}
function clone(d) {
  const m = { width: d.bitmap.width, height: d.bitmap.height, data: Buffer.from(d.bitmap.data) };
  return new d.constructor(m);
}
function scan(d, m, g, w, I, P) {
  let F, D, U, Z, $;
  if (typeof m == "function") $ = m, F = 0, D = 0, U = d.bitmap.width, Z = d.bitmap.height;
  else {
    if (F = m, typeof g != "number") throw new Error("y must be a number");
    if (D = g, typeof w != "number") throw new Error("w must be a number");
    if (U = w, typeof I != "number") throw new Error("h must be a number");
    if (Z = I, typeof P != "function") throw new Error("cb must be a function");
    $ = P;
  }
  F = Math.round(F), D = Math.round(D), U = Math.round(U), Z = Math.round(Z);
  const j = $.bind(d);
  for (let G = D; G < D + Z; G++) for (let Q = F; Q < F + U; Q++)
    j(Q, G, d.bitmap.width * G + Q << 2);
  return d;
}
function* scanIterator(d, m, g, w, I) {
  m = Math.round(m), g = Math.round(g), w = Math.round(w), I = Math.round(I);
  for (let P = g; P < g + I; P++) for (let F = m; F < m + w; F++) {
    const D = d.bitmap.width * P + F << 2;
    yield { x: F, y: P, idx: D, image: d };
  }
}
function intToRGBA$1(d) {
  if (typeof d != "number") throw new Error("i must be a number");
  const m = { r: 0, g: 0, b: 0, a: 0 };
  return m.r = Math.floor(d / Math.pow(256, 3)), m.g = Math.floor((d - m.r * Math.pow(256, 3)) / Math.pow(256, 2)), m.b = Math.floor((d - m.r * Math.pow(256, 3) - m.g * Math.pow(256, 2)) / Math.pow(256, 1)), m.a = Math.floor((d - m.r * Math.pow(256, 3) - m.g * Math.pow(256, 2) - m.b * Math.pow(256, 1)) / Math.pow(256, 0)), m;
}
function rgbaToInt(d, m, g, w) {
  if (typeof d != "number" || typeof m != "number" || typeof g != "number" || typeof w != "number") throw new Error("r, g, b and a must be numbers");
  if (d < 0 || d > 255) throw new Error("r must be between 0 and 255");
  if (m < 0 || m > 255) throw new Error("g must be between 0 and 255");
  if (g < 0 || g > 255) throw new Error("b must be between 0 and 255");
  if (w < 0 || w > 255) throw new Error("a must be between 0 and 255");
  let I = 255 & d;
  return I <<= 8, I |= 255 & m, I <<= 8, I |= 255 & g, I <<= 8, I |= 255 & w, I >>>= 0, I;
}
function colorDiff(d, m) {
  const g = (F) => Math.pow(F, 2), { max: w } = Math, I = "a" in d ? d.a : 255, P = "a" in m ? m.a : 255;
  return (w(g(d.r - m.r), g(d.r - m.r - I + P)) + w(g(d.g - m.g), g(d.g - m.g - I + P)) + w(g(d.b - m.b), g(d.b - m.b - I + P))) / 195075;
}
function limit255(d) {
  return d = Math.max(d, 0), d = Math.min(d, 255);
}
function cssColorToHex(d) {
  return typeof d == "number" ? d : parseInt(tinycolor(d).toHex8(), 16);
}
function encode$1(d, m = {}) {
  return scan({ bitmap: d }, 0, 0, d.width, d.height, function(g, w, I) {
    const P = d.data[I + 0], F = d.data[I + 1], D = d.data[I + 2], U = d.data[I + 3];
    d.data[I + 0] = U, d.data[I + 1] = D, d.data[I + 2] = F, d.data[I + 3] = P;
  }), encode$2({ ...d, ...m }).data;
}
function decode$1(d, m) {
  const g = decode$2(d, m);
  return scan({ bitmap: g }, 0, 0, g.width, g.height, function(w, I, P) {
    const F = g.data[P + 1], D = g.data[P + 2], U = g.data[P + 3];
    g.data[P + 0] = U, g.data[P + 1] = D, g.data[P + 2] = F, g.data[P + 3] = 255;
  }), g;
}
function msBmp() {
  return { mime: "image/x-ms-bmp", encode: encode$1, decode: decode$1 };
}
function bmp() {
  return { mime: "image/bmp", encode: encode$1, decode: decode$1 };
}
var omggif = {}, GifReader_1, GifWriter_1;
function GifWriter(d, m, g, w) {
  var I = 0, P = (w = w === void 0 ? {} : w).loop === void 0 ? null : w.loop, F = w.palette === void 0 ? null : w.palette;
  if (m <= 0 || g <= 0 || m > 65535 || g > 65535) throw new Error("Width/Height invalid.");
  function D(W) {
    var q = W.length;
    if (q < 2 || q > 256 || q & q - 1) throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
    return q;
  }
  d[I++] = 71, d[I++] = 73, d[I++] = 70, d[I++] = 56, d[I++] = 57, d[I++] = 97;
  var U = 0, Z = 0;
  if (F !== null) {
    for (var $ = D(F); $ >>= 1; ) ++U;
    if ($ = 1 << U, --U, w.background !== void 0) {
      if ((Z = w.background) >= $) throw new Error("Background index out of range.");
      if (Z === 0) throw new Error("Background index explicitly passed as 0.");
    }
  }
  if (d[I++] = 255 & m, d[I++] = m >> 8 & 255, d[I++] = 255 & g, d[I++] = g >> 8 & 255, d[I++] = (F !== null ? 128 : 0) | U, d[I++] = Z, d[I++] = 0, F !== null) for (var j = 0, G = F.length; j < G; ++j) {
    var Q = F[j];
    d[I++] = Q >> 16 & 255, d[I++] = Q >> 8 & 255, d[I++] = 255 & Q;
  }
  if (P !== null) {
    if (P < 0 || P > 65535) throw new Error("Loop count invalid.");
    d[I++] = 33, d[I++] = 255, d[I++] = 11, d[I++] = 78, d[I++] = 69, d[I++] = 84, d[I++] = 83, d[I++] = 67, d[I++] = 65, d[I++] = 80, d[I++] = 69, d[I++] = 50, d[I++] = 46, d[I++] = 48, d[I++] = 3, d[I++] = 1, d[I++] = 255 & P, d[I++] = P >> 8 & 255, d[I++] = 0;
  }
  var H = !1;
  this.addFrame = function(W, q, et, rt, tt, V) {
    if (H === !0 && (--I, H = !1), V = V === void 0 ? {} : V, W < 0 || q < 0 || W > 65535 || q > 65535) throw new Error("x/y invalid.");
    if (et <= 0 || rt <= 0 || et > 65535 || rt > 65535) throw new Error("Width/Height invalid.");
    if (tt.length < et * rt) throw new Error("Not enough pixels for the frame size.");
    var X = !0, ot = V.palette;
    if (ot == null && (X = !1, ot = F), ot == null) throw new Error("Must supply either a local or global palette.");
    for (var it = D(ot), st = 0; it >>= 1; ) ++st;
    it = 1 << st;
    var at = V.delay === void 0 ? 0 : V.delay, ct = V.disposal === void 0 ? 0 : V.disposal;
    if (ct < 0 || ct > 3) throw new Error("Disposal out of range.");
    var K = !1, lt = 0;
    if (V.transparent !== void 0 && V.transparent !== null && (K = !0, (lt = V.transparent) < 0 || lt >= it)) throw new Error("Transparent color index.");
    if ((ct !== 0 || K || at !== 0) && (d[I++] = 33, d[I++] = 249, d[I++] = 4, d[I++] = ct << 2 | (K === !0 ? 1 : 0), d[I++] = 255 & at, d[I++] = at >> 8 & 255, d[I++] = lt, d[I++] = 0), d[I++] = 44, d[I++] = 255 & W, d[I++] = W >> 8 & 255, d[I++] = 255 & q, d[I++] = q >> 8 & 255, d[I++] = 255 & et, d[I++] = et >> 8 & 255, d[I++] = 255 & rt, d[I++] = rt >> 8 & 255, d[I++] = X === !0 ? 128 | st - 1 : 0, X === !0) for (var vt = 0, dt = ot.length; vt < dt; ++vt) {
      var ht = ot[vt];
      d[I++] = ht >> 16 & 255, d[I++] = ht >> 8 & 255, d[I++] = 255 & ht;
    }
    return I = GifWriterOutputLZWCodeStream(d, I, st < 2 ? 2 : st, tt);
  }, this.end = function() {
    return H === !1 && (d[I++] = 59, H = !0), I;
  }, this.getOutputBuffer = function() {
    return d;
  }, this.setOutputBuffer = function(W) {
    d = W;
  }, this.getOutputBufferPosition = function() {
    return I;
  }, this.setOutputBufferPosition = function(W) {
    I = W;
  };
}
function GifWriterOutputLZWCodeStream(d, m, g, w) {
  d[m++] = g;
  var I = m++, P = 1 << g, F = P - 1, D = P + 1, U = D + 1, Z = g + 1, $ = 0, j = 0;
  function G(X) {
    for (; $ >= X; ) d[m++] = 255 & j, j >>= 8, $ -= 8, m === I + 256 && (d[I] = 255, I = m++);
  }
  function Q(X) {
    j |= X << $, $ += Z, G(8);
  }
  var H = w[0] & F, W = {};
  Q(P);
  for (var q = 1, et = w.length; q < et; ++q) {
    var rt = w[q] & F, tt = H << 8 | rt, V = W[tt];
    if (V === void 0) {
      for (j |= H << $, $ += Z; $ >= 8; ) d[m++] = 255 & j, j >>= 8, $ -= 8, m === I + 256 && (d[I] = 255, I = m++);
      U === 4096 ? (Q(P), U = D + 1, Z = g + 1, W = {}) : (U >= 1 << Z && ++Z, W[tt] = U++), H = rt;
    } else H = V;
  }
  return Q(H), Q(D), G(1), I + 1 === m ? d[I] = 0 : (d[I] = m - I - 1, d[m++] = 0), m;
}
function GifReader(d) {
  var m = 0;
  if (d[m++] !== 71 || d[m++] !== 73 || d[m++] !== 70 || d[m++] !== 56 || (d[m++] + 1 & 253) != 56 || d[m++] !== 97) throw new Error("Invalid GIF 87a/89a header.");
  var g = d[m++] | d[m++] << 8, w = d[m++] | d[m++] << 8, I = d[m++], P = I >> 7, F = 1 << (7 & I) + 1;
  d[m++], d[m++];
  var D = null, U = null;
  P && (D = m, U = F, m += 3 * F);
  var Z = !0, $ = [], j = 0, G = null, Q = 0, H = null;
  for (this.width = g, this.height = w; Z && m < d.length; ) switch (d[m++]) {
    case 33:
      switch (d[m++]) {
        case 255:
          if (d[m] !== 11 || d[m + 1] == 78 && d[m + 2] == 69 && d[m + 3] == 84 && d[m + 4] == 83 && d[m + 5] == 67 && d[m + 6] == 65 && d[m + 7] == 80 && d[m + 8] == 69 && d[m + 9] == 50 && d[m + 10] == 46 && d[m + 11] == 48 && d[m + 12] == 3 && d[m + 13] == 1 && d[m + 16] == 0) m += 14, H = d[m++] | d[m++] << 8, m++;
          else for (m += 12; ; ) {
            if (!((K = d[m++]) >= 0)) throw Error("Invalid block size");
            if (K === 0) break;
            m += K;
          }
          break;
        case 249:
          if (d[m++] !== 4 || d[m + 4] !== 0) throw new Error("Invalid graphics extension block.");
          var W = d[m++];
          j = d[m++] | d[m++] << 8, G = d[m++], 1 & W || (G = null), Q = W >> 2 & 7, m++;
          break;
        case 254:
          for (; ; ) {
            if (!((K = d[m++]) >= 0)) throw Error("Invalid block size");
            if (K === 0) break;
            m += K;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + d[m - 1].toString(16));
      }
      break;
    case 44:
      var q = d[m++] | d[m++] << 8, et = d[m++] | d[m++] << 8, rt = d[m++] | d[m++] << 8, tt = d[m++] | d[m++] << 8, V = d[m++], X = V >> 6 & 1, ot = 1 << (7 & V) + 1, it = D, st = U, at = !1;
      V >> 7 && (at = !0, it = m, st = ot, m += 3 * ot);
      var ct = m;
      for (m++; ; ) {
        var K;
        if (!((K = d[m++]) >= 0)) throw Error("Invalid block size");
        if (K === 0) break;
        m += K;
      }
      $.push({ x: q, y: et, width: rt, height: tt, has_local_palette: at, palette_offset: it, palette_size: st, data_offset: ct, data_length: m - ct, transparent_index: G, interlaced: !!X, delay: j, disposal: Q });
      break;
    case 59:
      Z = !1;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + d[m - 1].toString(16));
  }
  this.numFrames = function() {
    return $.length;
  }, this.loopCount = function() {
    return H;
  }, this.frameInfo = function(lt) {
    if (lt < 0 || lt >= $.length) throw new Error("Frame index out of range.");
    return $[lt];
  }, this.decodeAndBlitFrameBGRA = function(lt, vt) {
    var dt = this.frameInfo(lt), ht = dt.width * dt.height, pt = new Uint8Array(ht);
    GifReaderLZWOutputIndexStream(d, dt.data_offset, pt, ht);
    var Ct = dt.palette_offset, St = dt.transparent_index;
    St === null && (St = 256);
    var At = dt.width, Ft = g - At, xt = At, Pt = 4 * (dt.y * g + dt.x), Ot = 4 * ((dt.y + dt.height) * g + dt.x), Bt = Pt, kt = 4 * Ft;
    dt.interlaced === !0 && (kt += 4 * g * 7);
    for (var Tt = 8, Dt = 0, Zt = pt.length; Dt < Zt; ++Dt) {
      var $t = pt[Dt];
      if (xt === 0 && (xt = At, (Bt += kt) >= Ot && (kt = 4 * Ft + 4 * g * (Tt - 1), Bt = Pt + (At + Ft) * (Tt << 1), Tt >>= 1)), $t === St) Bt += 4;
      else {
        var Mt = d[Ct + 3 * $t], nt = d[Ct + 3 * $t + 1], It = d[Ct + 3 * $t + 2];
        vt[Bt++] = It, vt[Bt++] = nt, vt[Bt++] = Mt, vt[Bt++] = 255;
      }
      --xt;
    }
  }, this.decodeAndBlitFrameRGBA = function(lt, vt) {
    var dt = this.frameInfo(lt), ht = dt.width * dt.height, pt = new Uint8Array(ht);
    GifReaderLZWOutputIndexStream(d, dt.data_offset, pt, ht);
    var Ct = dt.palette_offset, St = dt.transparent_index;
    St === null && (St = 256);
    var At = dt.width, Ft = g - At, xt = At, Pt = 4 * (dt.y * g + dt.x), Ot = 4 * ((dt.y + dt.height) * g + dt.x), Bt = Pt, kt = 4 * Ft;
    dt.interlaced === !0 && (kt += 4 * g * 7);
    for (var Tt = 8, Dt = 0, Zt = pt.length; Dt < Zt; ++Dt) {
      var $t = pt[Dt];
      if (xt === 0 && (xt = At, (Bt += kt) >= Ot && (kt = 4 * Ft + 4 * g * (Tt - 1), Bt = Pt + (At + Ft) * (Tt << 1), Tt >>= 1)), $t === St) Bt += 4;
      else {
        var Mt = d[Ct + 3 * $t], nt = d[Ct + 3 * $t + 1], It = d[Ct + 3 * $t + 2];
        vt[Bt++] = Mt, vt[Bt++] = nt, vt[Bt++] = It, vt[Bt++] = 255;
      }
      --xt;
    }
  };
}
function GifReaderLZWOutputIndexStream(d, m, g, w) {
  for (var I = d[m++], P = 1 << I, F = P + 1, D = F + 1, U = I + 1, Z = (1 << U) - 1, $ = 0, j = 0, G = 0, Q = d[m++], H = new Int32Array(4096), W = null; ; ) {
    for (; $ < 16 && Q !== 0; ) j |= d[m++] << $, $ += 8, Q === 1 ? Q = d[m++] : --Q;
    if ($ < U) break;
    var q = j & Z;
    if (j >>= U, $ -= U, q !== P) {
      if (q === F) break;
      for (var et = q < D ? q : W, rt = 0, tt = et; tt > P; ) tt = H[tt] >> 8, ++rt;
      var V = tt;
      if (G + rt + (et !== q ? 1 : 0) > w) return void console.log("Warning, gif stream longer than expected.");
      g[G++] = V;
      var X = G += rt;
      for (et !== q && (g[G++] = V), tt = et; rt--; ) tt = H[tt], g[--X] = 255 & tt, tt >>= 8;
      W !== null && D < 4096 && (H[D++] = W << 8 | V, D >= Z + 1 && U < 12 && (++U, Z = Z << 1 | 1)), W = q;
    } else D = F + 1, Z = (1 << (U = I + 1)) - 1, W = null;
  }
  return G !== w && console.log("Warning, gif stream shorter than expected."), g;
}
try {
  GifWriter_1 = omggif.GifWriter = GifWriter, GifReader_1 = omggif.GifReader = GifReader;
} catch {
}
let BitmapImage$2 = class je {
  constructor(...m) {
    if (m.length === 0) throw new Error("constructor requires parameters");
    const g = m[0];
    if (g !== null && typeof g == "object") if (g instanceof je) {
      const w = g.bitmap;
      this.bitmap = { width: w.width, height: w.height, data: new Buffer(w.width * w.height * 4) }, w.data.copy(this.bitmap.data);
    } else {
      if (!(g.width && g.height && g.data)) throw new Error("unrecognized constructor parameters");
      this.bitmap = g;
    }
    else {
      if (typeof g != "number" || typeof m[1] != "number") throw new Error("unrecognized constructor parameters");
      {
        const w = g, I = m[1], P = m[2];
        this.bitmap = { width: w, height: I }, Buffer.isBuffer(P) ? this.bitmap.data = P : (this.bitmap.data = new Buffer(w * I * 4), typeof P == "number" && this.fillRGBA(P));
      }
    }
  }
  blit(m, g, w, I, P, F, D) {
    if (I + F > this.bitmap.width) throw new Error("copy exceeds width of source bitmap");
    if (g + F > m.bitmap.width) throw new Error("copy exceeds width of target bitmap");
    if (P + D > this.bitmap.height) throw new Error("copy exceeds height of source bitmap");
    if (w + D > m.bitmap.height) throw new Erro("copy exceeds height of target bitmap");
    const U = this.bitmap.data, Z = m.bitmap.data, $ = 4 * this.bitmap.width, j = 4 * m.bitmap.width, G = 4 * F;
    let Q = P * $ + 4 * I, H = w * j + 4 * g;
    for (; --D >= 0; ) U.copy(Z, H, Q, Q + G), Q += $, H += j;
    return this;
  }
  fillRGBA(m) {
    const g = this.bitmap.data, w = 4 * this.bitmap.height;
    let I = 0;
    for (; I < w; ) g.writeUInt32BE(m, I), I += 4;
    for (; I < g.length; ) g.copy(g, I, 0, w), I += w;
    return this;
  }
  getRGBA(m, g) {
    const w = 4 * (g * this.bitmap.width + m);
    return this.bitmap.data.readUInt32BE(w);
  }
  getRGBASet() {
    const m = /* @__PURE__ */ new Set(), g = this.bitmap.data;
    for (let w = 0; w < g.length; w += 4) m.add(g.readUInt32BE(w, !0));
    return m;
  }
  greyscale() {
    const m = this.bitmap.data;
    return this.scan(0, 0, this.bitmap.width, this.bitmap.height, (g, w, I) => {
      const P = Math.round(0.299 * m[I] + 0.587 * m[I + 1] + 0.114 * m[I + 2]);
      m[I] = P, m[I + 1] = P, m[I + 2] = P;
    }), this;
  }
  reframe(m, g, w, I, P) {
    const F = m < 0 ? 0 : m, D = g < 0 ? 0 : g, U = w + F > this.bitmap.width ? this.bitmap.width - F : w, Z = I + D > this.bitmap.height ? this.bitmap.height - D : I, $ = m < 0 ? -m : 0, j = g < 0 ? -g : 0;
    let G;
    if (P === void 0) {
      if (F !== m || D != g || U !== w || Z !== I) throw new GifError("fillRGBA required for this reframing");
      G = new je(w, I);
    } else G = new je(w, I, P);
    return this.blit(G, $, j, F, D, U, Z), this.bitmap = G.bitmap, this;
  }
  scale(m) {
    if (m === 1) return;
    if (!Number.isInteger(m) || m < 1) throw new Error("the scale must be an integer >= 1");
    const g = this.bitmap.width, w = this.bitmap.height, I = g * m * 4, P = this.bitmap.data, F = new Buffer(w * I * m);
    let D, U = 0, Z = 0;
    for (let $ = 0; $ < w; ++$) {
      D = Z;
      for (let j = 0; j < g; ++j) {
        const G = P.readUInt32BE(U, !0);
        for (let Q = 0; Q < m; ++Q) F.writeUInt32BE(G, Z), Z += 4;
        U += 4;
      }
      for (let j = 1; j < m; ++j) F.copy(F, Z, D, Z), Z += I, D += I;
    }
    return this.bitmap = { width: g * m, height: w * m, data: F }, this;
  }
  scanAllCoords(m) {
    const g = this.bitmap.width, w = this.bitmap.data.length;
    let I = 0, P = 0;
    for (let F = 0; F < w; F += 4) m(I, P, F), ++I === g && (I = 0, ++P);
  }
  scanAllIndexes(m) {
    const g = this.bitmap.data.length;
    for (let w = 0; w < g; w += 4) m(w);
  }
};
var bitmapimage = BitmapImage$2, gif$1 = {};
let Gif$1 = class {
  constructor(d, m, g) {
    this.width = g.width, this.height = g.height, this.loops = g.loops, this.usesTransparency = g.usesTransparency, this.colorScope = g.colorScope, this.frames = m, this.buffer = d;
  }
};
Gif$1.GlobalColorsPreferred = 0, Gif$1.GlobalColorsOnly = 1, Gif$1.LocalColorsOnly = 2;
let GifError$2 = class extends Error {
  constructor(d) {
    super(d), d instanceof Error && (this.stack = "Gif" + d.stack);
  }
};
gif$1.Gif = Gif$1, gif$1.GifError = GifError$2;
var gifcodec = {}, gifutil = {}, _polyfillNode_fs = {}, _polyfillNode_fs$1 = Object.freeze({ __proto__: null, default: _polyfillNode_fs }), require$$0 = getAugmentedNamespace(_polyfillNode_fs$1), __defProp$3 = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __hasOwnProp = Object.prototype.hasOwnProperty, __defNormalProp$3 = (d, m, g) => m in d ? __defProp$3(d, m, { enumerable: !0, configurable: !0, writable: !0, value: g }) : d[m] = g, __markAsModule = (d) => __defProp$3(d, "__esModule", { value: !0 }), __export$1 = (d, m) => {
  for (var g in m) __defProp$3(d, g, { get: m[g], enumerable: !0 });
}, __reExport = (d, m, g, w) => {
  if (m && typeof m == "object" || typeof m == "function") for (let I of __getOwnPropNames(m)) !__hasOwnProp.call(d, I) && g && __defProp$3(d, I, { get: () => m[I], enumerable: !(w = __getOwnPropDesc(m, I)) || w.enumerable });
  return d;
}, __toCommonJS = /* @__PURE__ */ ((d) => (m, g) => d && d.get(m) || (g = __reExport(__markAsModule({}), m, 1), d && d.set(m, g), g))(typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : 0), __publicField$3 = (d, m, g) => (__defNormalProp$3(d, typeof m != "symbol" ? m + "" : m, g), g), src_exports = {};
__export$1(src_exports, { applyPalette: () => applyPalette, applyPaletteSync: () => applyPaletteSync$1, buildPalette: () => buildPalette, buildPaletteSync: () => buildPaletteSync$1, constants: () => constants_exports$1, conversion: () => conversion_exports$1, distance: () => distance_exports$1, image: () => image_exports$1, palette: () => palette_exports$1, quality: () => quality_exports$1, utils: () => utils_exports$1 });
var constants_exports$1 = {};
__export$1(constants_exports$1, { bt709: () => bt709_exports$1 });
var bt709_exports$1 = {};
__export$1(bt709_exports$1, { Y: () => Y$1, x: () => x$2, y: () => y$2 });
var Y$1 = ((d) => (d[d.RED = 0.2126] = "RED", d[d.GREEN = 0.7152] = "GREEN", d[d.BLUE = 0.0722] = "BLUE", d[d.WHITE = 1] = "WHITE", d))(Y$1 || {}), x$2 = ((d) => (d[d.RED = 0.64] = "RED", d[d.GREEN = 0.3] = "GREEN", d[d.BLUE = 0.15] = "BLUE", d[d.WHITE = 0.3127] = "WHITE", d))(x$2 || {}), y$2 = ((d) => (d[d.RED = 0.33] = "RED", d[d.GREEN = 0.6] = "GREEN", d[d.BLUE = 0.06] = "BLUE", d[d.WHITE = 0.329] = "WHITE", d))(y$2 || {}), conversion_exports$1 = {};
function correctGamma$1(d) {
  return d > 0.04045 ? ((d + 0.055) / 1.055) ** 2.4 : d / 12.92;
}
function rgb2xyz$1(d, m, g) {
  return { x: 0.4124 * (d = correctGamma$1(d / 255)) + 0.3576 * (m = correctGamma$1(m / 255)) + 0.1805 * (g = correctGamma$1(g / 255)), y: 0.2126 * d + 0.7152 * m + 0.0722 * g, z: 0.0193 * d + 0.1192 * m + 0.9505 * g };
}
__export$1(conversion_exports$1, { lab2rgb: () => lab2rgb$1, lab2xyz: () => lab2xyz$1, rgb2hsl: () => rgb2hsl$1, rgb2lab: () => rgb2lab$1, rgb2xyz: () => rgb2xyz$1, xyz2lab: () => xyz2lab$1, xyz2rgb: () => xyz2rgb$1 });
var arithmetic_exports$1 = {};
function degrees2radians$1(d) {
  return d * (Math.PI / 180);
}
function max3$1(d, m, g) {
  let w = d;
  return w < m && (w = m), w < g && (w = g), w;
}
function min3$1(d, m, g) {
  let w = d;
  return w > m && (w = m), w > g && (w = g), w;
}
function intInRange$1(d, m, g) {
  return d > g && (d = g), d < m && (d = m), 0 | d;
}
function inRange0to255Rounded$1(d) {
  return (d = Math.round(d)) > 255 ? d = 255 : d < 0 && (d = 0), d;
}
function inRange0to255$1(d) {
  return d > 255 ? d = 255 : d < 0 && (d = 0), d;
}
function stableSort$1(d, m) {
  const g = typeof d[0];
  let w;
  if (g === "number" || g === "string") {
    const I = /* @__PURE__ */ Object.create(null);
    for (let P = 0, F = d.length; P < F; P++) {
      const D = d[P];
      I[D] || I[D] === 0 || (I[D] = P);
    }
    w = d.sort((P, F) => m(P, F) || I[P] - I[F]);
  } else {
    const I = d.slice(0);
    w = d.sort((P, F) => m(P, F) || I.indexOf(P) - I.indexOf(F));
  }
  return w;
}
function rgb2hsl$1(d, m, g) {
  const w = min3$1(d, m, g), I = max3$1(d, m, g), P = I - w, F = (w + I) / 510;
  let D = 0;
  F > 0 && F < 1 && (D = P / (F < 0.5 ? I + w : 510 - I - w));
  let U = 0;
  return P > 0 && (U = I === d ? (m - g) / P : I === m ? 2 + (g - d) / P : 4 + (d - m) / P, U *= 60, U < 0 && (U += 360)), { h: U, s: D, l: F };
}
__export$1(arithmetic_exports$1, { degrees2radians: () => degrees2radians$1, inRange0to255: () => inRange0to255$1, inRange0to255Rounded: () => inRange0to255Rounded$1, intInRange: () => intInRange$1, max3: () => max3$1, min3: () => min3$1, stableSort: () => stableSort$1 });
var refX$1 = 0.95047, refY$1 = 1, refZ$1 = 1.08883;
function pivot$1(d) {
  return d > 8856e-6 ? d ** (1 / 3) : 7.787 * d + 16 / 116;
}
function xyz2lab$1(d, m, g) {
  if (d = pivot$1(d / refX$1), m = pivot$1(m / refY$1), g = pivot$1(g / refZ$1), 116 * m - 16 < 0) throw new Error("xxx");
  return { L: Math.max(0, 116 * m - 16), a: 500 * (d - m), b: 200 * (m - g) };
}
function rgb2lab$1(d, m, g) {
  const w = rgb2xyz$1(d, m, g);
  return xyz2lab$1(w.x, w.y, w.z);
}
var refX2$1 = 0.95047, refY2$1 = 1, refZ2$1 = 1.08883;
function pivot2$1(d) {
  return d > 0.206893034 ? d ** 3 : (d - 16 / 116) / 7.787;
}
function lab2xyz$1(d, m, g) {
  const w = (d + 16) / 116, I = w - g / 200;
  return { x: refX2$1 * pivot2$1(m / 500 + w), y: refY2$1 * pivot2$1(w), z: refZ2$1 * pivot2$1(I) };
}
function correctGamma2$1(d) {
  return d > 31308e-7 ? 1.055 * d ** (1 / 2.4) - 0.055 : 12.92 * d;
}
function xyz2rgb$1(d, m, g) {
  const w = correctGamma2$1(3.2406 * d + -1.5372 * m + -0.4986 * g), I = correctGamma2$1(-0.9689 * d + 1.8758 * m + 0.0415 * g), P = correctGamma2$1(0.0557 * d + -0.204 * m + 1.057 * g);
  return { r: inRange0to255Rounded$1(255 * w), g: inRange0to255Rounded$1(255 * I), b: inRange0to255Rounded$1(255 * P) };
}
function lab2rgb$1(d, m, g) {
  const w = lab2xyz$1(d, m, g);
  return xyz2rgb$1(w.x, w.y, w.z);
}
var distance_exports$1 = {};
__export$1(distance_exports$1, { AbstractDistanceCalculator: () => AbstractDistanceCalculator$1, AbstractEuclidean: () => AbstractEuclidean$1, AbstractManhattan: () => AbstractManhattan$1, CIE94GraphicArts: () => CIE94GraphicArts$1, CIE94Textiles: () => CIE94Textiles$1, CIEDE2000: () => CIEDE2000$1, CMetric: () => CMetric$1, Euclidean: () => Euclidean$1, EuclideanBT709: () => EuclideanBT709$1, EuclideanBT709NoAlpha: () => EuclideanBT709NoAlpha$1, Manhattan: () => Manhattan$1, ManhattanBT709: () => ManhattanBT709$1, ManhattanNommyde: () => ManhattanNommyde$1, PNGQuant: () => PNGQuant$1 });
var AbstractDistanceCalculator$1 = class {
  constructor() {
    __publicField$3(this, "_maxDistance"), __publicField$3(this, "_whitePoint"), this._setDefaults(), this.setWhitePoint(255, 255, 255, 255);
  }
  setWhitePoint(d, m, g, w) {
    this._whitePoint = { r: d > 0 ? 255 / d : 0, g: m > 0 ? 255 / m : 0, b: g > 0 ? 255 / g : 0, a: w > 0 ? 255 / w : 0 }, this._maxDistance = this.calculateRaw(d, m, g, w, 0, 0, 0, 0);
  }
  calculateNormalized(d, m) {
    return this.calculateRaw(d.r, d.g, d.b, d.a, m.r, m.g, m.b, m.a) / this._maxDistance;
  }
}, AbstractCIE94$1 = class extends AbstractDistanceCalculator$1 {
  calculateRaw(d, m, g, w, I, P, F, D) {
    const U = rgb2lab$1(inRange0to255$1(d * this._whitePoint.r), inRange0to255$1(m * this._whitePoint.g), inRange0to255$1(g * this._whitePoint.b)), Z = rgb2lab$1(inRange0to255$1(I * this._whitePoint.r), inRange0to255$1(P * this._whitePoint.g), inRange0to255$1(F * this._whitePoint.b)), $ = U.L - Z.L, j = U.a - Z.a, G = U.b - Z.b, Q = Math.sqrt(U.a * U.a + U.b * U.b), H = Q - Math.sqrt(Z.a * Z.a + Z.b * Z.b);
    let W = j * j + G * G - H * H;
    W = W < 0 ? 0 : Math.sqrt(W);
    const q = (D - w) * this._whitePoint.a * this._kA;
    return Math.sqrt(($ / this._Kl) ** 2 + (H / (1 + this._K1 * Q)) ** 2 + (W / (1 + this._K2 * Q)) ** 2 + q ** 2);
  }
}, CIE94Textiles$1 = class extends AbstractCIE94$1 {
  _setDefaults() {
    this._Kl = 2, this._K1 = 0.048, this._K2 = 0.014, this._kA = 12.5 / 255;
  }
}, CIE94GraphicArts$1 = class extends AbstractCIE94$1 {
  _setDefaults() {
    this._Kl = 1, this._K1 = 0.045, this._K2 = 0.015, this._kA = 25 / 255;
  }
}, _CIEDE2000$1 = class extends AbstractDistanceCalculator$1 {
  _setDefaults() {
  }
  static _calculatehp(d, m) {
    const g = Math.atan2(d, m);
    return g >= 0 ? g : g + _CIEDE2000$1._deg360InRad;
  }
  static _calculateRT(d, m) {
    const g = m ** 7, w = 2 * Math.sqrt(g / (g + _CIEDE2000$1._pow25to7)), I = _CIEDE2000$1._deg30InRad * Math.exp(-(((d - _CIEDE2000$1._deg275InRad) / _CIEDE2000$1._deg25InRad) ** 2));
    return -Math.sin(2 * I) * w;
  }
  static _calculateT(d) {
    return 1 - 0.17 * Math.cos(d - _CIEDE2000$1._deg30InRad) + 0.24 * Math.cos(2 * d) + 0.32 * Math.cos(3 * d + _CIEDE2000$1._deg6InRad) - 0.2 * Math.cos(4 * d - _CIEDE2000$1._deg63InRad);
  }
  static _calculate_ahp(d, m, g, w) {
    const I = g + w;
    return d === 0 ? I : m <= _CIEDE2000$1._deg180InRad ? I / 2 : I < _CIEDE2000$1._deg360InRad ? (I + _CIEDE2000$1._deg360InRad) / 2 : (I - _CIEDE2000$1._deg360InRad) / 2;
  }
  static _calculate_dHp(d, m, g, w) {
    let I;
    return I = d === 0 ? 0 : m <= _CIEDE2000$1._deg180InRad ? g - w : g <= w ? g - w + _CIEDE2000$1._deg360InRad : g - w - _CIEDE2000$1._deg360InRad, 2 * Math.sqrt(d) * Math.sin(I / 2);
  }
  calculateRaw(d, m, g, w, I, P, F, D) {
    const U = rgb2lab$1(inRange0to255$1(d * this._whitePoint.r), inRange0to255$1(m * this._whitePoint.g), inRange0to255$1(g * this._whitePoint.b)), Z = rgb2lab$1(inRange0to255$1(I * this._whitePoint.r), inRange0to255$1(P * this._whitePoint.g), inRange0to255$1(F * this._whitePoint.b)), $ = (D - w) * this._whitePoint.a * _CIEDE2000$1._kA, j = this.calculateRawInLab(U, Z);
    return Math.sqrt(j + $ * $);
  }
  calculateRawInLab(d, m) {
    const g = d.L, w = d.a, I = d.b, P = m.L, F = m.a, D = m.b, U = ((Math.sqrt(w * w + I * I) + Math.sqrt(F * F + D * D)) / 2) ** 7, Z = 0.5 * (1 - Math.sqrt(U / (U + _CIEDE2000$1._pow25to7))), $ = (1 + Z) * w, j = (1 + Z) * F, G = Math.sqrt($ * $ + I * I), Q = Math.sqrt(j * j + D * D), H = G * Q, W = _CIEDE2000$1._calculatehp(I, $), q = _CIEDE2000$1._calculatehp(D, j), et = Math.abs(W - q), rt = P - g, tt = Q - G, V = _CIEDE2000$1._calculate_dHp(H, et, q, W), X = _CIEDE2000$1._calculate_ahp(H, et, W, q), ot = (G + Q) / 2, it = ((g + P) / 2 - 50) ** 2, st = tt / (1 + 0.045 * ot), at = V / (1 + 0.015 * _CIEDE2000$1._calculateT(X) * ot);
    return (rt / (1 + 0.015 * it / Math.sqrt(20 + it))) ** 2 + st ** 2 + at ** 2 + _CIEDE2000$1._calculateRT(X, ot) * st * at;
  }
}, CIEDE2000$1 = _CIEDE2000$1;
__publicField$3(CIEDE2000$1, "_kA", 25 / 255), __publicField$3(CIEDE2000$1, "_pow25to7", 25 ** 7), __publicField$3(CIEDE2000$1, "_deg360InRad", degrees2radians$1(360)), __publicField$3(CIEDE2000$1, "_deg180InRad", degrees2radians$1(180)), __publicField$3(CIEDE2000$1, "_deg30InRad", degrees2radians$1(30)), __publicField$3(CIEDE2000$1, "_deg6InRad", degrees2radians$1(6)), __publicField$3(CIEDE2000$1, "_deg63InRad", degrees2radians$1(63)), __publicField$3(CIEDE2000$1, "_deg275InRad", degrees2radians$1(275)), __publicField$3(CIEDE2000$1, "_deg25InRad", degrees2radians$1(25));
var CMetric$1 = class extends AbstractDistanceCalculator$1 {
  calculateRaw(d, m, g, w, I, P, F, D) {
    const U = (d + I) / 2 * this._whitePoint.r, Z = (d - I) * this._whitePoint.r, $ = (m - P) * this._whitePoint.g, j = (g - F) * this._whitePoint.b, G = ((512 + U) * Z * Z >> 8) + 4 * $ * $ + ((767 - U) * j * j >> 8), Q = (D - w) * this._whitePoint.a;
    return Math.sqrt(G + Q * Q);
  }
  _setDefaults() {
  }
}, AbstractEuclidean$1 = class extends AbstractDistanceCalculator$1 {
  calculateRaw(d, m, g, w, I, P, F, D) {
    const U = I - d, Z = P - m, $ = F - g, j = D - w;
    return Math.sqrt(this._kR * U * U + this._kG * Z * Z + this._kB * $ * $ + this._kA * j * j);
  }
}, Euclidean$1 = class extends AbstractEuclidean$1 {
  _setDefaults() {
    this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
  }
}, EuclideanBT709$1 = class extends AbstractEuclidean$1 {
  _setDefaults() {
    this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
  }
}, EuclideanBT709NoAlpha$1 = class extends AbstractEuclidean$1 {
  _setDefaults() {
    this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 0;
  }
}, AbstractManhattan$1 = class extends AbstractDistanceCalculator$1 {
  calculateRaw(d, m, g, w, I, P, F, D) {
    let U = I - d, Z = P - m, $ = F - g, j = D - w;
    return U < 0 && (U = 0 - U), Z < 0 && (Z = 0 - Z), $ < 0 && ($ = 0 - $), j < 0 && (j = 0 - j), this._kR * U + this._kG * Z + this._kB * $ + this._kA * j;
  }
}, Manhattan$1 = class extends AbstractManhattan$1 {
  _setDefaults() {
    this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
  }
}, ManhattanNommyde$1 = class extends AbstractManhattan$1 {
  _setDefaults() {
    this._kR = 0.4984, this._kG = 0.8625, this._kB = 0.2979, this._kA = 1;
  }
}, ManhattanBT709$1 = class extends AbstractManhattan$1 {
  _setDefaults() {
    this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
  }
}, PNGQuant$1 = class extends AbstractDistanceCalculator$1 {
  calculateRaw(d, m, g, w, I, P, F, D) {
    const U = (D - w) * this._whitePoint.a;
    return this._colordifferenceCh(d * this._whitePoint.r, I * this._whitePoint.r, U) + this._colordifferenceCh(m * this._whitePoint.g, P * this._whitePoint.g, U) + this._colordifferenceCh(g * this._whitePoint.b, F * this._whitePoint.b, U);
  }
  _colordifferenceCh(d, m, g) {
    const w = d - m, I = w + g;
    return w * w + I * I;
  }
  _setDefaults() {
  }
}, palette_exports$1 = {};
__export$1(palette_exports$1, { AbstractPaletteQuantizer: () => AbstractPaletteQuantizer$1, ColorHistogram: () => ColorHistogram$1, NeuQuant: () => NeuQuant$1, NeuQuantFloat: () => NeuQuantFloat$1, RGBQuant: () => RGBQuant$1, WuColorCube: () => WuColorCube$1, WuQuant: () => WuQuant$1 });
var AbstractPaletteQuantizer$1 = class {
  quantizeSync() {
    for (const d of this.quantize()) if (d.palette) return d.palette;
    throw new Error("unreachable");
  }
}, Point$1 = class {
  constructor() {
    __publicField$3(this, "r"), __publicField$3(this, "g"), __publicField$3(this, "b"), __publicField$3(this, "a"), __publicField$3(this, "uint32"), __publicField$3(this, "rgba"), this.uint32 = -1 >>> 0, this.r = this.g = this.b = this.a = 0, this.rgba = new Array(4), this.rgba[0] = 0, this.rgba[1] = 0, this.rgba[2] = 0, this.rgba[3] = 0;
  }
  static createByQuadruplet(d) {
    const m = new Point$1();
    return m.r = 0 | d[0], m.g = 0 | d[1], m.b = 0 | d[2], m.a = 0 | d[3], m._loadUINT32(), m._loadQuadruplet(), m;
  }
  static createByRGBA(d, m, g, w) {
    const I = new Point$1();
    return I.r = 0 | d, I.g = 0 | m, I.b = 0 | g, I.a = 0 | w, I._loadUINT32(), I._loadQuadruplet(), I;
  }
  static createByUint32(d) {
    const m = new Point$1();
    return m.uint32 = d >>> 0, m._loadRGBA(), m._loadQuadruplet(), m;
  }
  from(d) {
    this.r = d.r, this.g = d.g, this.b = d.b, this.a = d.a, this.uint32 = d.uint32, this.rgba[0] = d.r, this.rgba[1] = d.g, this.rgba[2] = d.b, this.rgba[3] = d.a;
  }
  getLuminosity(d) {
    let m = this.r, g = this.g, w = this.b;
    return d && (m = Math.min(255, 255 - this.a + this.a * m / 255), g = Math.min(255, 255 - this.a + this.a * g / 255), w = Math.min(255, 255 - this.a + this.a * w / 255)), 0.2126 * m + 0.7152 * g + 0.0722 * w;
  }
  _loadUINT32() {
    this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
  }
  _loadRGBA() {
    this.r = 255 & this.uint32, this.g = this.uint32 >>> 8 & 255, this.b = this.uint32 >>> 16 & 255, this.a = this.uint32 >>> 24 & 255;
  }
  _loadQuadruplet() {
    this.rgba[0] = this.r, this.rgba[1] = this.g, this.rgba[2] = this.b, this.rgba[3] = this.a;
  }
}, PointContainer$1 = class {
  constructor() {
    __publicField$3(this, "_pointArray"), __publicField$3(this, "_width"), __publicField$3(this, "_height"), this._width = 0, this._height = 0, this._pointArray = [];
  }
  getWidth() {
    return this._width;
  }
  getHeight() {
    return this._height;
  }
  setWidth(d) {
    this._width = d;
  }
  setHeight(d) {
    this._height = d;
  }
  getPointArray() {
    return this._pointArray;
  }
  clone() {
    const d = new PointContainer$1();
    d._width = this._width, d._height = this._height;
    for (let m = 0, g = this._pointArray.length; m < g; m++) d._pointArray[m] = Point$1.createByUint32(0 | this._pointArray[m].uint32);
    return d;
  }
  toUint32Array() {
    const d = this._pointArray.length, m = new Uint32Array(d);
    for (let g = 0; g < d; g++) m[g] = this._pointArray[g].uint32;
    return m;
  }
  toUint8Array() {
    return new Uint8Array(this.toUint32Array().buffer);
  }
  static fromHTMLImageElement(d) {
    const m = d.naturalWidth, g = d.naturalHeight, w = document.createElement("canvas");
    return w.width = m, w.height = g, w.getContext("2d").drawImage(d, 0, 0, m, g, 0, 0, m, g), PointContainer$1.fromHTMLCanvasElement(w);
  }
  static fromHTMLCanvasElement(d) {
    const m = d.width, g = d.height, w = d.getContext("2d").getImageData(0, 0, m, g);
    return PointContainer$1.fromImageData(w);
  }
  static fromImageData(d) {
    const m = d.width, g = d.height;
    return PointContainer$1.fromUint8Array(d.data, m, g);
  }
  static fromUint8Array(d, m, g) {
    switch (Object.prototype.toString.call(d)) {
      case "[object Uint8ClampedArray]":
      case "[object Uint8Array]":
        break;
      default:
        d = new Uint8Array(d);
    }
    const w = new Uint32Array(d.buffer);
    return PointContainer$1.fromUint32Array(w, m, g);
  }
  static fromUint32Array(d, m, g) {
    const w = new PointContainer$1();
    w._width = m, w._height = g;
    for (let I = 0, P = d.length; I < P; I++) w._pointArray[I] = Point$1.createByUint32(0 | d[I]);
    return w;
  }
  static fromBuffer(d, m, g) {
    const w = new Uint32Array(d.buffer, d.byteOffset, d.byteLength / Uint32Array.BYTES_PER_ELEMENT);
    return PointContainer$1.fromUint32Array(w, m, g);
  }
}, hueGroups$1 = 10;
function hueGroup$1(d, m) {
  const g = 360 / m;
  for (let w = 1, I = g - g / 2; w < m; w++, I += g) if (d >= I && d < I + g) return w;
  return 0;
}
var Palette$1 = class {
  constructor() {
    __publicField$3(this, "_pointContainer"), __publicField$3(this, "_pointArray", []), __publicField$3(this, "_i32idx", {}), this._pointContainer = new PointContainer$1(), this._pointContainer.setHeight(1), this._pointArray = this._pointContainer.getPointArray();
  }
  add(d) {
    this._pointArray.push(d), this._pointContainer.setWidth(this._pointArray.length);
  }
  has(d) {
    for (let m = this._pointArray.length - 1; m >= 0; m--) if (d.uint32 === this._pointArray[m].uint32) return !0;
    return !1;
  }
  getNearestColor(d, m) {
    return this._pointArray[0 | this._getNearestIndex(d, m)];
  }
  getPointContainer() {
    return this._pointContainer;
  }
  _nearestPointFromCache(d) {
    return typeof this._i32idx[d] == "number" ? this._i32idx[d] : -1;
  }
  _getNearestIndex(d, m) {
    let g = this._nearestPointFromCache("" + m.uint32);
    if (g >= 0) return g;
    let w = Number.MAX_VALUE;
    g = 0;
    for (let I = 0, P = this._pointArray.length; I < P; I++) {
      const F = this._pointArray[I], D = d.calculateRaw(m.r, m.g, m.b, m.a, F.r, F.g, F.b, F.a);
      D < w && (w = D, g = I);
    }
    return this._i32idx[m.uint32] = g, g;
  }
  sort() {
    this._i32idx = {}, this._pointArray.sort((d, m) => {
      const g = rgb2hsl$1(d.r, d.g, d.b), w = rgb2hsl$1(m.r, m.g, m.b), I = d.r === d.g && d.g === d.b ? 0 : 1 + hueGroup$1(g.h, hueGroups$1), P = (m.r === m.g && m.g === m.b ? 0 : 1 + hueGroup$1(w.h, hueGroups$1)) - I;
      if (P) return -P;
      const F = d.getLuminosity(!0), D = m.getLuminosity(!0);
      if (D - F != 0) return D - F;
      const U = (100 * w.s | 0) - (100 * g.s | 0);
      return U ? -U : 0;
    });
  }
}, utils_exports$1 = {};
__export$1(utils_exports$1, { HueStatistics: () => HueStatistics$1, Palette: () => Palette$1, Point: () => Point$1, PointContainer: () => PointContainer$1, ProgressTracker: () => ProgressTracker$1, arithmetic: () => arithmetic_exports$1 });
var HueGroup$1 = class {
  constructor() {
    __publicField$3(this, "num", 0), __publicField$3(this, "cols", []);
  }
}, HueStatistics$1 = class {
  constructor(d, m) {
    __publicField$3(this, "_numGroups"), __publicField$3(this, "_minCols"), __publicField$3(this, "_stats"), __publicField$3(this, "_groupsFull"), this._numGroups = d, this._minCols = m, this._stats = [];
    for (let g = 0; g <= d; g++) this._stats[g] = new HueGroup$1();
    this._groupsFull = 0;
  }
  check(d) {
    this._groupsFull === this._numGroups + 1 && (this.check = () => {
    });
    const m = 255 & d, g = d >>> 8 & 255, w = d >>> 16 & 255, I = m === g && g === w ? 0 : 1 + hueGroup$1(rgb2hsl$1(m, g, w).h, this._numGroups), P = this._stats[I], F = this._minCols;
    P.num++, P.num > F || (P.num === F && this._groupsFull++, P.num <= F && this._stats[I].cols.push(d));
  }
  injectIntoDictionary(d) {
    for (let m = 0; m <= this._numGroups; m++) this._stats[m].num <= this._minCols && this._stats[m].cols.forEach((g) => {
      d[g] ? d[g]++ : d[g] = 1;
    });
  }
  injectIntoArray(d) {
    for (let m = 0; m <= this._numGroups; m++) this._stats[m].num <= this._minCols && this._stats[m].cols.forEach((g) => {
      d.indexOf(g) === -1 && d.push(g);
    });
  }
}, _ProgressTracker$1 = class {
  constructor(d, m) {
    __publicField$3(this, "progress"), __publicField$3(this, "_step"), __publicField$3(this, "_range"), __publicField$3(this, "_last"), __publicField$3(this, "_progressRange"), this._range = d, this._progressRange = m, this._step = Math.max(1, this._range / (_ProgressTracker$1.steps + 1) | 0), this._last = -this._step, this.progress = 0;
  }
  shouldNotify(d) {
    return d - this._last >= this._step && (this._last = d, this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange), !0);
  }
}, ProgressTracker$1 = _ProgressTracker$1;
__publicField$3(ProgressTracker$1, "steps", 100);
var networkBiasShift$1 = 3, Neuron$1 = class {
  constructor(d) {
    __publicField$3(this, "r"), __publicField$3(this, "g"), __publicField$3(this, "b"), __publicField$3(this, "a"), this.r = this.g = this.b = this.a = d;
  }
  toPoint() {
    return Point$1.createByRGBA(this.r >> networkBiasShift$1, this.g >> networkBiasShift$1, this.b >> networkBiasShift$1, this.a >> networkBiasShift$1);
  }
  subtract(d, m, g, w) {
    this.r -= 0 | d, this.g -= 0 | m, this.b -= 0 | g, this.a -= 0 | w;
  }
}, _NeuQuant$1 = class extends AbstractPaletteQuantizer$1 {
  constructor(d, m = 256) {
    super(), __publicField$3(this, "_pointArray"), __publicField$3(this, "_networkSize"), __publicField$3(this, "_network"), __publicField$3(this, "_sampleFactor"), __publicField$3(this, "_radPower"), __publicField$3(this, "_freq"), __publicField$3(this, "_bias"), __publicField$3(this, "_distance"), this._distance = d, this._pointArray = [], this._sampleFactor = 1, this._networkSize = m, this._distance.setWhitePoint(255 << networkBiasShift$1, 255 << networkBiasShift$1, 255 << networkBiasShift$1, 255 << networkBiasShift$1);
  }
  sample(d) {
    this._pointArray = this._pointArray.concat(d.getPointArray());
  }
  *quantize() {
    this._init(), yield* this._learn(), yield { palette: this._buildPalette(), progress: 100 };
  }
  _init() {
    this._freq = [], this._bias = [], this._radPower = [], this._network = [];
    for (let d = 0; d < this._networkSize; d++) this._network[d] = new Neuron$1((d << networkBiasShift$1 + 8) / this._networkSize | 0), this._freq[d] = _NeuQuant$1._initialBias / this._networkSize | 0, this._bias[d] = 0;
  }
  *_learn() {
    let d = this._sampleFactor;
    const m = this._pointArray.length;
    m < _NeuQuant$1._minpicturebytes && (d = 1);
    const g = 30 + (d - 1) / 3 | 0, w = m / d | 0;
    let I, P = w / _NeuQuant$1._nCycles | 0, F = _NeuQuant$1._initAlpha, D = (this._networkSize >> 3) * _NeuQuant$1._radiusBias, U = D >> _NeuQuant$1._radiusBiasShift;
    U <= 1 && (U = 0);
    for (let $ = 0; $ < U; $++) this._radPower[$] = F * ((U * U - $ * $) * _NeuQuant$1._radBias / (U * U)) >>> 0;
    I = m < _NeuQuant$1._minpicturebytes ? 1 : m % _NeuQuant$1._prime1 != 0 ? _NeuQuant$1._prime1 : m % _NeuQuant$1._prime2 != 0 ? _NeuQuant$1._prime2 : m % _NeuQuant$1._prime3 != 0 ? _NeuQuant$1._prime3 : _NeuQuant$1._prime4;
    const Z = new ProgressTracker$1(w, 99);
    for (let $ = 0, j = 0; $ < w; ) {
      Z.shouldNotify($) && (yield { progress: Z.progress });
      const G = this._pointArray[j], Q = G.b << networkBiasShift$1, H = G.g << networkBiasShift$1, W = G.r << networkBiasShift$1, q = G.a << networkBiasShift$1, et = this._contest(Q, H, W, q);
      if (this._alterSingle(F, et, Q, H, W, q), U !== 0 && this._alterNeighbour(U, et, Q, H, W, q), j += I, j >= m && (j -= m), $++, P === 0 && (P = 1), $ % P == 0) {
        F -= F / g | 0, D -= D / _NeuQuant$1._radiusDecrease | 0, U = D >> _NeuQuant$1._radiusBiasShift, U <= 1 && (U = 0);
        for (let rt = 0; rt < U; rt++) this._radPower[rt] = F * ((U * U - rt * rt) * _NeuQuant$1._radBias / (U * U)) >>> 0;
      }
    }
  }
  _buildPalette() {
    const d = new Palette$1();
    return this._network.forEach((m) => {
      d.add(m.toPoint());
    }), d.sort(), d;
  }
  _alterNeighbour(d, m, g, w, I, P) {
    let F = m - d;
    F < -1 && (F = -1);
    let D = m + d;
    D > this._networkSize && (D = this._networkSize);
    let U = m + 1, Z = m - 1, $ = 1;
    for (; U < D || Z > F; ) {
      const j = this._radPower[$++] / _NeuQuant$1._alphaRadBias;
      if (U < D) {
        const G = this._network[U++];
        G.subtract(j * (G.r - I), j * (G.g - w), j * (G.b - g), j * (G.a - P));
      }
      if (Z > F) {
        const G = this._network[Z--];
        G.subtract(j * (G.r - I), j * (G.g - w), j * (G.b - g), j * (G.a - P));
      }
    }
  }
  _alterSingle(d, m, g, w, I, P) {
    d /= _NeuQuant$1._initAlpha;
    const F = this._network[m];
    F.subtract(d * (F.r - I), d * (F.g - w), d * (F.b - g), d * (F.a - P));
  }
  _contest(d, m, g, w) {
    const I = 1020 << networkBiasShift$1;
    let P = 2147483647, F = P, D = -1, U = D;
    for (let Z = 0; Z < this._networkSize; Z++) {
      const $ = this._network[Z], j = this._distance.calculateNormalized($, { r: g, g: m, b: d, a: w }) * I | 0;
      j < P && (P = j, D = Z);
      const G = j - (this._bias[Z] >> _NeuQuant$1._initialBiasShift - networkBiasShift$1);
      G < F && (F = G, U = Z);
      const Q = this._freq[Z] >> _NeuQuant$1._betaShift;
      this._freq[Z] -= Q, this._bias[Z] += Q << _NeuQuant$1._gammaShift;
    }
    return this._freq[D] += _NeuQuant$1._beta, this._bias[D] -= _NeuQuant$1._betaGamma, U;
  }
}, NeuQuant$1 = _NeuQuant$1;
__publicField$3(NeuQuant$1, "_prime1", 499), __publicField$3(NeuQuant$1, "_prime2", 491), __publicField$3(NeuQuant$1, "_prime3", 487), __publicField$3(NeuQuant$1, "_prime4", 503), __publicField$3(NeuQuant$1, "_minpicturebytes", _NeuQuant$1._prime4), __publicField$3(NeuQuant$1, "_nCycles", 100), __publicField$3(NeuQuant$1, "_initialBiasShift", 16), __publicField$3(NeuQuant$1, "_initialBias", 1 << _NeuQuant$1._initialBiasShift), __publicField$3(NeuQuant$1, "_gammaShift", 10), __publicField$3(NeuQuant$1, "_betaShift", 10), __publicField$3(NeuQuant$1, "_beta", _NeuQuant$1._initialBias >> _NeuQuant$1._betaShift), __publicField$3(NeuQuant$1, "_betaGamma", _NeuQuant$1._initialBias << _NeuQuant$1._gammaShift - _NeuQuant$1._betaShift), __publicField$3(NeuQuant$1, "_radiusBiasShift", 6), __publicField$3(NeuQuant$1, "_radiusBias", 1 << _NeuQuant$1._radiusBiasShift), __publicField$3(NeuQuant$1, "_radiusDecrease", 30), __publicField$3(NeuQuant$1, "_alphaBiasShift", 10), __publicField$3(NeuQuant$1, "_initAlpha", 1 << _NeuQuant$1._alphaBiasShift), __publicField$3(NeuQuant$1, "_radBiasShift", 8), __publicField$3(NeuQuant$1, "_radBias", 1 << _NeuQuant$1._radBiasShift), __publicField$3(NeuQuant$1, "_alphaRadBiasShift", _NeuQuant$1._alphaBiasShift + _NeuQuant$1._radBiasShift), __publicField$3(NeuQuant$1, "_alphaRadBias", 1 << _NeuQuant$1._alphaRadBiasShift);
var networkBiasShift2$1 = 3, NeuronFloat$1 = class {
  constructor(d) {
    __publicField$3(this, "r"), __publicField$3(this, "g"), __publicField$3(this, "b"), __publicField$3(this, "a"), this.r = this.g = this.b = this.a = d;
  }
  toPoint() {
    return Point$1.createByRGBA(this.r >> networkBiasShift2$1, this.g >> networkBiasShift2$1, this.b >> networkBiasShift2$1, this.a >> networkBiasShift2$1);
  }
  subtract(d, m, g, w) {
    this.r -= d, this.g -= m, this.b -= g, this.a -= w;
  }
}, _NeuQuantFloat$1 = class extends AbstractPaletteQuantizer$1 {
  constructor(d, m = 256) {
    super(), __publicField$3(this, "_pointArray"), __publicField$3(this, "_networkSize"), __publicField$3(this, "_network"), __publicField$3(this, "_sampleFactor"), __publicField$3(this, "_radPower"), __publicField$3(this, "_freq"), __publicField$3(this, "_bias"), __publicField$3(this, "_distance"), this._distance = d, this._pointArray = [], this._sampleFactor = 1, this._networkSize = m, this._distance.setWhitePoint(255 << networkBiasShift2$1, 255 << networkBiasShift2$1, 255 << networkBiasShift2$1, 255 << networkBiasShift2$1);
  }
  sample(d) {
    this._pointArray = this._pointArray.concat(d.getPointArray());
  }
  *quantize() {
    this._init(), yield* this._learn(), yield { palette: this._buildPalette(), progress: 100 };
  }
  _init() {
    this._freq = [], this._bias = [], this._radPower = [], this._network = [];
    for (let d = 0; d < this._networkSize; d++) this._network[d] = new NeuronFloat$1((d << networkBiasShift2$1 + 8) / this._networkSize), this._freq[d] = _NeuQuantFloat$1._initialBias / this._networkSize, this._bias[d] = 0;
  }
  *_learn() {
    let d = this._sampleFactor;
    const m = this._pointArray.length;
    m < _NeuQuantFloat$1._minpicturebytes && (d = 1);
    const g = 30 + (d - 1) / 3, w = m / d;
    let I, P = w / _NeuQuantFloat$1._nCycles | 0, F = _NeuQuantFloat$1._initAlpha, D = (this._networkSize >> 3) * _NeuQuantFloat$1._radiusBias, U = D >> _NeuQuantFloat$1._radiusBiasShift;
    U <= 1 && (U = 0);
    for (let $ = 0; $ < U; $++) this._radPower[$] = F * ((U * U - $ * $) * _NeuQuantFloat$1._radBias / (U * U));
    I = m < _NeuQuantFloat$1._minpicturebytes ? 1 : m % _NeuQuantFloat$1._prime1 != 0 ? _NeuQuantFloat$1._prime1 : m % _NeuQuantFloat$1._prime2 != 0 ? _NeuQuantFloat$1._prime2 : m % _NeuQuantFloat$1._prime3 != 0 ? _NeuQuantFloat$1._prime3 : _NeuQuantFloat$1._prime4;
    const Z = new ProgressTracker$1(w, 99);
    for (let $ = 0, j = 0; $ < w; ) {
      Z.shouldNotify($) && (yield { progress: Z.progress });
      const G = this._pointArray[j], Q = G.b << networkBiasShift2$1, H = G.g << networkBiasShift2$1, W = G.r << networkBiasShift2$1, q = G.a << networkBiasShift2$1, et = this._contest(Q, H, W, q);
      if (this._alterSingle(F, et, Q, H, W, q), U !== 0 && this._alterNeighbour(U, et, Q, H, W, q), j += I, j >= m && (j -= m), $++, P === 0 && (P = 1), $ % P == 0) {
        F -= F / g, D -= D / _NeuQuantFloat$1._radiusDecrease, U = D >> _NeuQuantFloat$1._radiusBiasShift, U <= 1 && (U = 0);
        for (let rt = 0; rt < U; rt++) this._radPower[rt] = F * ((U * U - rt * rt) * _NeuQuantFloat$1._radBias / (U * U));
      }
    }
  }
  _buildPalette() {
    const d = new Palette$1();
    return this._network.forEach((m) => {
      d.add(m.toPoint());
    }), d.sort(), d;
  }
  _alterNeighbour(d, m, g, w, I, P) {
    let F = m - d;
    F < -1 && (F = -1);
    let D = m + d;
    D > this._networkSize && (D = this._networkSize);
    let U = m + 1, Z = m - 1, $ = 1;
    for (; U < D || Z > F; ) {
      const j = this._radPower[$++] / _NeuQuantFloat$1._alphaRadBias;
      if (U < D) {
        const G = this._network[U++];
        G.subtract(j * (G.r - I), j * (G.g - w), j * (G.b - g), j * (G.a - P));
      }
      if (Z > F) {
        const G = this._network[Z--];
        G.subtract(j * (G.r - I), j * (G.g - w), j * (G.b - g), j * (G.a - P));
      }
    }
  }
  _alterSingle(d, m, g, w, I, P) {
    d /= _NeuQuantFloat$1._initAlpha;
    const F = this._network[m];
    F.subtract(d * (F.r - I), d * (F.g - w), d * (F.b - g), d * (F.a - P));
  }
  _contest(d, m, g, w) {
    const I = 1020 << networkBiasShift2$1;
    let P = 2147483647, F = P, D = -1, U = D;
    for (let Z = 0; Z < this._networkSize; Z++) {
      const $ = this._network[Z], j = this._distance.calculateNormalized($, { r: g, g: m, b: d, a: w }) * I;
      j < P && (P = j, D = Z);
      const G = j - (this._bias[Z] >> _NeuQuantFloat$1._initialBiasShift - networkBiasShift2$1);
      G < F && (F = G, U = Z);
      const Q = this._freq[Z] >> _NeuQuantFloat$1._betaShift;
      this._freq[Z] -= Q, this._bias[Z] += Q << _NeuQuantFloat$1._gammaShift;
    }
    return this._freq[D] += _NeuQuantFloat$1._beta, this._bias[D] -= _NeuQuantFloat$1._betaGamma, U;
  }
}, NeuQuantFloat$1 = _NeuQuantFloat$1;
__publicField$3(NeuQuantFloat$1, "_prime1", 499), __publicField$3(NeuQuantFloat$1, "_prime2", 491), __publicField$3(NeuQuantFloat$1, "_prime3", 487), __publicField$3(NeuQuantFloat$1, "_prime4", 503), __publicField$3(NeuQuantFloat$1, "_minpicturebytes", _NeuQuantFloat$1._prime4), __publicField$3(NeuQuantFloat$1, "_nCycles", 100), __publicField$3(NeuQuantFloat$1, "_initialBiasShift", 16), __publicField$3(NeuQuantFloat$1, "_initialBias", 1 << _NeuQuantFloat$1._initialBiasShift), __publicField$3(NeuQuantFloat$1, "_gammaShift", 10), __publicField$3(NeuQuantFloat$1, "_betaShift", 10), __publicField$3(NeuQuantFloat$1, "_beta", _NeuQuantFloat$1._initialBias >> _NeuQuantFloat$1._betaShift), __publicField$3(NeuQuantFloat$1, "_betaGamma", _NeuQuantFloat$1._initialBias << _NeuQuantFloat$1._gammaShift - _NeuQuantFloat$1._betaShift), __publicField$3(NeuQuantFloat$1, "_radiusBiasShift", 6), __publicField$3(NeuQuantFloat$1, "_radiusBias", 1 << _NeuQuantFloat$1._radiusBiasShift), __publicField$3(NeuQuantFloat$1, "_radiusDecrease", 30), __publicField$3(NeuQuantFloat$1, "_alphaBiasShift", 10), __publicField$3(NeuQuantFloat$1, "_initAlpha", 1 << _NeuQuantFloat$1._alphaBiasShift), __publicField$3(NeuQuantFloat$1, "_radBiasShift", 8), __publicField$3(NeuQuantFloat$1, "_radBias", 1 << _NeuQuantFloat$1._radBiasShift), __publicField$3(NeuQuantFloat$1, "_alphaRadBiasShift", _NeuQuantFloat$1._alphaBiasShift + _NeuQuantFloat$1._radBiasShift), __publicField$3(NeuQuantFloat$1, "_alphaRadBias", 1 << _NeuQuantFloat$1._alphaRadBiasShift);
var _ColorHistogram$1 = class {
  constructor(d, m) {
    __publicField$3(this, "_method"), __publicField$3(this, "_hueStats"), __publicField$3(this, "_histogram"), __publicField$3(this, "_initColors"), __publicField$3(this, "_minHueCols"), this._method = d, this._minHueCols = m << 2, this._initColors = m << 2, this._hueStats = new HueStatistics$1(_ColorHistogram$1._hueGroups, this._minHueCols), this._histogram = /* @__PURE__ */ Object.create(null);
  }
  sample(d) {
    switch (this._method) {
      case 1:
        this._colorStats1D(d);
        break;
      case 2:
        this._colorStats2D(d);
    }
  }
  getImportanceSortedColorsIDXI32() {
    const d = stableSort$1(Object.keys(this._histogram), (g, w) => this._histogram[w] - this._histogram[g]);
    if (d.length === 0) return [];
    let m;
    switch (this._method) {
      case 1:
        const g = Math.min(d.length, this._initColors), w = d[g - 1], I = this._histogram[w];
        m = d.slice(0, g);
        let P = g;
        const F = d.length;
        for (; P < F && this._histogram[d[P]] === I; ) m.push(d[P++]);
        this._hueStats.injectIntoArray(m);
        break;
      case 2:
        m = d;
        break;
      default:
        throw new Error("Incorrect method");
    }
    return m.map((g) => +g);
  }
  _colorStats1D(d) {
    const m = this._histogram, g = d.getPointArray(), w = g.length;
    for (let I = 0; I < w; I++) {
      const P = g[I].uint32;
      this._hueStats.check(P), P in m ? m[P]++ : m[P] = 1;
    }
  }
  _colorStats2D(d) {
    const m = d.getWidth(), g = d.getHeight(), w = d.getPointArray(), I = _ColorHistogram$1._boxSize[0], P = _ColorHistogram$1._boxSize[1], F = I * P, D = this._makeBoxes(m, g, I, P), U = this._histogram;
    D.forEach((Z) => {
      let $ = Math.round(Z.w * Z.h / F) * _ColorHistogram$1._boxPixels;
      $ < 2 && ($ = 2);
      const j = {};
      this._iterateBox(Z, m, (G) => {
        const Q = w[G].uint32;
        this._hueStats.check(Q), Q in U ? U[Q]++ : Q in j ? ++j[Q] >= $ && (U[Q] = j[Q]) : j[Q] = 1;
      });
    }), this._hueStats.injectIntoDictionary(U);
  }
  _iterateBox(d, m, g) {
    const w = d, I = w.y * m + w.x, P = (w.y + w.h - 1) * m + (w.x + w.w - 1), F = m - w.w + 1;
    let D = 0, U = I;
    do
      g.call(this, U), U += ++D % w.w == 0 ? F : 1;
    while (U <= P);
  }
  _makeBoxes(d, m, g, w) {
    const I = d % g, P = m % w, F = d - I, D = m - P, U = [];
    for (let Z = 0; Z < m; Z += w) for (let $ = 0; $ < d; $ += g) U.push({ x: $, y: Z, w: $ === F ? I : g, h: Z === D ? P : w });
    return U;
  }
}, ColorHistogram$1 = _ColorHistogram$1;
__publicField$3(ColorHistogram$1, "_boxSize", [64, 64]), __publicField$3(ColorHistogram$1, "_boxPixels", 2), __publicField$3(ColorHistogram$1, "_hueGroups", 10);
var RemovedColor$1 = class {
  constructor(d, m, g) {
    __publicField$3(this, "index"), __publicField$3(this, "color"), __publicField$3(this, "distance"), this.index = d, this.color = m, this.distance = g;
  }
}, RGBQuant$1 = class extends AbstractPaletteQuantizer$1 {
  constructor(d, m = 256, g = 2) {
    super(), __publicField$3(this, "_colors"), __publicField$3(this, "_initialDistance"), __publicField$3(this, "_distanceIncrement"), __publicField$3(this, "_histogram"), __publicField$3(this, "_distance"), this._distance = d, this._colors = m, this._histogram = new ColorHistogram$1(g, m), this._initialDistance = 0.01, this._distanceIncrement = 5e-3;
  }
  sample(d) {
    this._histogram.sample(d);
  }
  *quantize() {
    const d = this._histogram.getImportanceSortedColorsIDXI32();
    if (d.length === 0) throw new Error("No colors in image");
    yield* this._buildPalette(d);
  }
  *_buildPalette(d) {
    const m = new Palette$1(), g = m.getPointContainer().getPointArray(), w = new Array(d.length);
    for (let $ = 0; $ < d.length; $++) g.push(Point$1.createByUint32(d[$])), w[$] = 1;
    const I = g.length, P = [];
    let F = I, D = this._initialDistance;
    const U = new ProgressTracker$1(F - this._colors, 99);
    for (; F > this._colors; ) {
      P.length = 0;
      for (let $ = 0; $ < I; $++) {
        if (U.shouldNotify(I - F) && (yield { progress: U.progress }), w[$] === 0) continue;
        const j = g[$];
        for (let G = $ + 1; G < I; G++) {
          if (w[G] === 0) continue;
          const Q = g[G], H = this._distance.calculateNormalized(j, Q);
          H < D && (P.push(new RemovedColor$1(G, Q, H)), w[G] = 0, F--);
        }
      }
      D += F > 3 * this._colors ? this._initialDistance : this._distanceIncrement;
    }
    if (F < this._colors) {
      stableSort$1(P, (j, G) => G.distance - j.distance);
      let $ = 0;
      for (; F < this._colors && $ < P.length; )
        w[P[$].index] = 1, F++, $++;
    }
    let Z = g.length;
    for (let $ = Z - 1; $ >= 0; $--) w[$] === 0 && ($ !== Z - 1 && (g[$] = g[Z - 1]), --Z);
    g.length = Z, m.sort(), yield { palette: m, progress: 100 };
  }
};
function createArray1D$1(d) {
  const m = [];
  for (let g = 0; g < d; g++) m[g] = 0;
  return m;
}
function createArray4D$1(d, m, g, w) {
  const I = new Array(d);
  for (let P = 0; P < d; P++) {
    I[P] = new Array(m);
    for (let F = 0; F < m; F++) {
      I[P][F] = new Array(g);
      for (let D = 0; D < g; D++) {
        I[P][F][D] = new Array(w);
        for (let U = 0; U < w; U++) I[P][F][D][U] = 0;
      }
    }
  }
  return I;
}
function createArray3D$1(d, m, g) {
  const w = new Array(d);
  for (let I = 0; I < d; I++) {
    w[I] = new Array(m);
    for (let P = 0; P < m; P++) {
      w[I][P] = new Array(g);
      for (let F = 0; F < g; F++) w[I][P][F] = 0;
    }
  }
  return w;
}
function fillArray3D$1(d, m, g, w, I) {
  for (let P = 0; P < m; P++) {
    d[P] = [];
    for (let F = 0; F < g; F++) {
      d[P][F] = [];
      for (let D = 0; D < w; D++) d[P][F][D] = I;
    }
  }
}
function fillArray1D$1(d, m, g) {
  for (let w = 0; w < m; w++) d[w] = g;
}
var WuColorCube$1 = class {
  constructor() {
    __publicField$3(this, "redMinimum"), __publicField$3(this, "redMaximum"), __publicField$3(this, "greenMinimum"), __publicField$3(this, "greenMaximum"), __publicField$3(this, "blueMinimum"), __publicField$3(this, "blueMaximum"), __publicField$3(this, "volume"), __publicField$3(this, "alphaMinimum"), __publicField$3(this, "alphaMaximum");
  }
}, _WuQuant$1 = class extends AbstractPaletteQuantizer$1 {
  constructor(d, m = 256, g = 5) {
    super(), __publicField$3(this, "_reds"), __publicField$3(this, "_greens"), __publicField$3(this, "_blues"), __publicField$3(this, "_alphas"), __publicField$3(this, "_sums"), __publicField$3(this, "_weights"), __publicField$3(this, "_momentsRed"), __publicField$3(this, "_momentsGreen"), __publicField$3(this, "_momentsBlue"), __publicField$3(this, "_momentsAlpha"), __publicField$3(this, "_moments"), __publicField$3(this, "_table"), __publicField$3(this, "_pixels"), __publicField$3(this, "_cubes"), __publicField$3(this, "_colors"), __publicField$3(this, "_significantBitsPerChannel"), __publicField$3(this, "_maxSideIndex"), __publicField$3(this, "_alphaMaxSideIndex"), __publicField$3(this, "_sideSize"), __publicField$3(this, "_alphaSideSize"), __publicField$3(this, "_distance"), this._distance = d, this._setQuality(g), this._initialize(m);
  }
  sample(d) {
    const m = d.getPointArray();
    for (let g = 0, w = m.length; g < w; g++) this._addColor(m[g]);
    this._pixels = this._pixels.concat(m);
  }
  *quantize() {
    yield* this._preparePalette();
    const d = new Palette$1();
    for (let m = 0; m < this._colors; m++) if (this._sums[m] > 0) {
      const g = this._sums[m], w = this._reds[m] / g, I = this._greens[m] / g, P = this._blues[m] / g, F = this._alphas[m] / g, D = Point$1.createByRGBA(0 | w, 0 | I, 0 | P, 0 | F);
      d.add(D);
    }
    d.sort(), yield { palette: d, progress: 100 };
  }
  *_preparePalette() {
    yield* this._calculateMoments();
    let d = 0;
    const m = createArray1D$1(this._colors);
    for (let F = 1; F < this._colors; ++F) {
      this._cut(this._cubes[d], this._cubes[F]) ? (m[d] = this._cubes[d].volume > 1 ? this._calculateVariance(this._cubes[d]) : 0, m[F] = this._cubes[F].volume > 1 ? this._calculateVariance(this._cubes[F]) : 0) : (m[d] = 0, F--), d = 0;
      let D = m[0];
      for (let U = 1; U <= F; ++U) m[U] > D && (D = m[U], d = U);
      if (D <= 0) {
        this._colors = F + 1;
        break;
      }
    }
    const g = [], w = [], I = [], P = [];
    for (let F = 0; F < this._colors; ++F) {
      const D = _WuQuant$1._volume(this._cubes[F], this._weights);
      D > 0 ? (g[F] = _WuQuant$1._volume(this._cubes[F], this._momentsRed) / D | 0, w[F] = _WuQuant$1._volume(this._cubes[F], this._momentsGreen) / D | 0, I[F] = _WuQuant$1._volume(this._cubes[F], this._momentsBlue) / D | 0, P[F] = _WuQuant$1._volume(this._cubes[F], this._momentsAlpha) / D | 0) : (g[F] = 0, w[F] = 0, I[F] = 0, P[F] = 0);
    }
    this._reds = createArray1D$1(this._colors + 1), this._greens = createArray1D$1(this._colors + 1), this._blues = createArray1D$1(this._colors + 1), this._alphas = createArray1D$1(this._colors + 1), this._sums = createArray1D$1(this._colors + 1);
    for (let F = 0, D = this._pixels.length; F < D; F++) {
      const U = this._pixels[F];
      let Z = -1, $ = Number.MAX_VALUE;
      for (let j = 0; j < this._colors; j++) {
        const G = g[j], Q = w[j], H = I[j], W = P[j], q = this._distance.calculateRaw(G, Q, H, W, U.r, U.g, U.b, U.a);
        q < $ && ($ = q, Z = j);
      }
      this._reds[Z] += U.r, this._greens[Z] += U.g, this._blues[Z] += U.b, this._alphas[Z] += U.a, this._sums[Z]++;
    }
  }
  _addColor(d) {
    const m = 8 - this._significantBitsPerChannel, g = 1 + (d.r >> m), w = 1 + (d.g >> m), I = 1 + (d.b >> m), P = 1 + (d.a >> m);
    this._weights[P][g][w][I]++, this._momentsRed[P][g][w][I] += d.r, this._momentsGreen[P][g][w][I] += d.g, this._momentsBlue[P][g][w][I] += d.b, this._momentsAlpha[P][g][w][I] += d.a, this._moments[P][g][w][I] += this._table[d.r] + this._table[d.g] + this._table[d.b] + this._table[d.a];
  }
  *_calculateMoments() {
    const d = [], m = [], g = [], w = [], I = [], P = [], F = createArray3D$1(this._sideSize, this._sideSize, this._sideSize), D = createArray3D$1(this._sideSize, this._sideSize, this._sideSize), U = createArray3D$1(this._sideSize, this._sideSize, this._sideSize), Z = createArray3D$1(this._sideSize, this._sideSize, this._sideSize), $ = createArray3D$1(this._sideSize, this._sideSize, this._sideSize), j = createArray3D$1(this._sideSize, this._sideSize, this._sideSize);
    let G = 0;
    const Q = new ProgressTracker$1(this._alphaMaxSideIndex * this._maxSideIndex, 99);
    for (let H = 1; H <= this._alphaMaxSideIndex; ++H) {
      fillArray3D$1(F, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D$1(D, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D$1(U, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D$1(Z, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D$1($, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D$1(j, this._sideSize, this._sideSize, this._sideSize, 0);
      for (let W = 1; W <= this._maxSideIndex; ++W, ++G) {
        Q.shouldNotify(G) && (yield { progress: Q.progress }), fillArray1D$1(d, this._sideSize, 0), fillArray1D$1(m, this._sideSize, 0), fillArray1D$1(g, this._sideSize, 0), fillArray1D$1(w, this._sideSize, 0), fillArray1D$1(I, this._sideSize, 0), fillArray1D$1(P, this._sideSize, 0);
        for (let q = 1; q <= this._maxSideIndex; ++q) {
          let et = 0, rt = 0, tt = 0, V = 0, X = 0, ot = 0;
          for (let it = 1; it <= this._maxSideIndex; ++it) et += this._weights[H][W][q][it], rt += this._momentsRed[H][W][q][it], tt += this._momentsGreen[H][W][q][it], V += this._momentsBlue[H][W][q][it], X += this._momentsAlpha[H][W][q][it], ot += this._moments[H][W][q][it], d[it] += et, m[it] += rt, g[it] += tt, w[it] += V, I[it] += X, P[it] += ot, F[W][q][it] = F[W - 1][q][it] + d[it], D[W][q][it] = D[W - 1][q][it] + m[it], U[W][q][it] = U[W - 1][q][it] + g[it], Z[W][q][it] = Z[W - 1][q][it] + w[it], $[W][q][it] = $[W - 1][q][it] + I[it], j[W][q][it] = j[W - 1][q][it] + P[it], this._weights[H][W][q][it] = this._weights[H - 1][W][q][it] + F[W][q][it], this._momentsRed[H][W][q][it] = this._momentsRed[H - 1][W][q][it] + D[W][q][it], this._momentsGreen[H][W][q][it] = this._momentsGreen[H - 1][W][q][it] + U[W][q][it], this._momentsBlue[H][W][q][it] = this._momentsBlue[H - 1][W][q][it] + Z[W][q][it], this._momentsAlpha[H][W][q][it] = this._momentsAlpha[H - 1][W][q][it] + $[W][q][it], this._moments[H][W][q][it] = this._moments[H - 1][W][q][it] + j[W][q][it];
        }
      }
    }
  }
  static _volumeFloat(d, m) {
    return m[d.alphaMaximum][d.redMaximum][d.greenMaximum][d.blueMaximum] - m[d.alphaMaximum][d.redMaximum][d.greenMinimum][d.blueMaximum] - m[d.alphaMaximum][d.redMinimum][d.greenMaximum][d.blueMaximum] + m[d.alphaMaximum][d.redMinimum][d.greenMinimum][d.blueMaximum] - m[d.alphaMinimum][d.redMaximum][d.greenMaximum][d.blueMaximum] + m[d.alphaMinimum][d.redMaximum][d.greenMinimum][d.blueMaximum] + m[d.alphaMinimum][d.redMinimum][d.greenMaximum][d.blueMaximum] - m[d.alphaMinimum][d.redMinimum][d.greenMinimum][d.blueMaximum] - (m[d.alphaMaximum][d.redMaximum][d.greenMaximum][d.blueMinimum] - m[d.alphaMinimum][d.redMaximum][d.greenMaximum][d.blueMinimum] - m[d.alphaMaximum][d.redMaximum][d.greenMinimum][d.blueMinimum] + m[d.alphaMinimum][d.redMaximum][d.greenMinimum][d.blueMinimum] - m[d.alphaMaximum][d.redMinimum][d.greenMaximum][d.blueMinimum] + m[d.alphaMinimum][d.redMinimum][d.greenMaximum][d.blueMinimum] + m[d.alphaMaximum][d.redMinimum][d.greenMinimum][d.blueMinimum] - m[d.alphaMinimum][d.redMinimum][d.greenMinimum][d.blueMinimum]);
  }
  static _volume(d, m) {
    return 0 | _WuQuant$1._volumeFloat(d, m);
  }
  static _top(d, m, g, w) {
    let I;
    switch (m) {
      case _WuQuant$1._alpha:
        I = w[g][d.redMaximum][d.greenMaximum][d.blueMaximum] - w[g][d.redMaximum][d.greenMinimum][d.blueMaximum] - w[g][d.redMinimum][d.greenMaximum][d.blueMaximum] + w[g][d.redMinimum][d.greenMinimum][d.blueMaximum] - (w[g][d.redMaximum][d.greenMaximum][d.blueMinimum] - w[g][d.redMaximum][d.greenMinimum][d.blueMinimum] - w[g][d.redMinimum][d.greenMaximum][d.blueMinimum] + w[g][d.redMinimum][d.greenMinimum][d.blueMinimum]);
        break;
      case _WuQuant$1._red:
        I = w[d.alphaMaximum][g][d.greenMaximum][d.blueMaximum] - w[d.alphaMaximum][g][d.greenMinimum][d.blueMaximum] - w[d.alphaMinimum][g][d.greenMaximum][d.blueMaximum] + w[d.alphaMinimum][g][d.greenMinimum][d.blueMaximum] - (w[d.alphaMaximum][g][d.greenMaximum][d.blueMinimum] - w[d.alphaMaximum][g][d.greenMinimum][d.blueMinimum] - w[d.alphaMinimum][g][d.greenMaximum][d.blueMinimum] + w[d.alphaMinimum][g][d.greenMinimum][d.blueMinimum]);
        break;
      case _WuQuant$1._green:
        I = w[d.alphaMaximum][d.redMaximum][g][d.blueMaximum] - w[d.alphaMaximum][d.redMinimum][g][d.blueMaximum] - w[d.alphaMinimum][d.redMaximum][g][d.blueMaximum] + w[d.alphaMinimum][d.redMinimum][g][d.blueMaximum] - (w[d.alphaMaximum][d.redMaximum][g][d.blueMinimum] - w[d.alphaMaximum][d.redMinimum][g][d.blueMinimum] - w[d.alphaMinimum][d.redMaximum][g][d.blueMinimum] + w[d.alphaMinimum][d.redMinimum][g][d.blueMinimum]);
        break;
      case _WuQuant$1._blue:
        I = w[d.alphaMaximum][d.redMaximum][d.greenMaximum][g] - w[d.alphaMaximum][d.redMaximum][d.greenMinimum][g] - w[d.alphaMaximum][d.redMinimum][d.greenMaximum][g] + w[d.alphaMaximum][d.redMinimum][d.greenMinimum][g] - (w[d.alphaMinimum][d.redMaximum][d.greenMaximum][g] - w[d.alphaMinimum][d.redMaximum][d.greenMinimum][g] - w[d.alphaMinimum][d.redMinimum][d.greenMaximum][g] + w[d.alphaMinimum][d.redMinimum][d.greenMinimum][g]);
        break;
      default:
        throw new Error("impossible");
    }
    return 0 | I;
  }
  static _bottom(d, m, g) {
    switch (m) {
      case _WuQuant$1._alpha:
        return -g[d.alphaMinimum][d.redMaximum][d.greenMaximum][d.blueMaximum] + g[d.alphaMinimum][d.redMaximum][d.greenMinimum][d.blueMaximum] + g[d.alphaMinimum][d.redMinimum][d.greenMaximum][d.blueMaximum] - g[d.alphaMinimum][d.redMinimum][d.greenMinimum][d.blueMaximum] - (-g[d.alphaMinimum][d.redMaximum][d.greenMaximum][d.blueMinimum] + g[d.alphaMinimum][d.redMaximum][d.greenMinimum][d.blueMinimum] + g[d.alphaMinimum][d.redMinimum][d.greenMaximum][d.blueMinimum] - g[d.alphaMinimum][d.redMinimum][d.greenMinimum][d.blueMinimum]);
      case _WuQuant$1._red:
        return -g[d.alphaMaximum][d.redMinimum][d.greenMaximum][d.blueMaximum] + g[d.alphaMaximum][d.redMinimum][d.greenMinimum][d.blueMaximum] + g[d.alphaMinimum][d.redMinimum][d.greenMaximum][d.blueMaximum] - g[d.alphaMinimum][d.redMinimum][d.greenMinimum][d.blueMaximum] - (-g[d.alphaMaximum][d.redMinimum][d.greenMaximum][d.blueMinimum] + g[d.alphaMaximum][d.redMinimum][d.greenMinimum][d.blueMinimum] + g[d.alphaMinimum][d.redMinimum][d.greenMaximum][d.blueMinimum] - g[d.alphaMinimum][d.redMinimum][d.greenMinimum][d.blueMinimum]);
      case _WuQuant$1._green:
        return -g[d.alphaMaximum][d.redMaximum][d.greenMinimum][d.blueMaximum] + g[d.alphaMaximum][d.redMinimum][d.greenMinimum][d.blueMaximum] + g[d.alphaMinimum][d.redMaximum][d.greenMinimum][d.blueMaximum] - g[d.alphaMinimum][d.redMinimum][d.greenMinimum][d.blueMaximum] - (-g[d.alphaMaximum][d.redMaximum][d.greenMinimum][d.blueMinimum] + g[d.alphaMaximum][d.redMinimum][d.greenMinimum][d.blueMinimum] + g[d.alphaMinimum][d.redMaximum][d.greenMinimum][d.blueMinimum] - g[d.alphaMinimum][d.redMinimum][d.greenMinimum][d.blueMinimum]);
      case _WuQuant$1._blue:
        return -g[d.alphaMaximum][d.redMaximum][d.greenMaximum][d.blueMinimum] + g[d.alphaMaximum][d.redMaximum][d.greenMinimum][d.blueMinimum] + g[d.alphaMaximum][d.redMinimum][d.greenMaximum][d.blueMinimum] - g[d.alphaMaximum][d.redMinimum][d.greenMinimum][d.blueMinimum] - (-g[d.alphaMinimum][d.redMaximum][d.greenMaximum][d.blueMinimum] + g[d.alphaMinimum][d.redMaximum][d.greenMinimum][d.blueMinimum] + g[d.alphaMinimum][d.redMinimum][d.greenMaximum][d.blueMinimum] - g[d.alphaMinimum][d.redMinimum][d.greenMinimum][d.blueMinimum]);
      default:
        return 0;
    }
  }
  _calculateVariance(d) {
    const m = _WuQuant$1._volume(d, this._momentsRed), g = _WuQuant$1._volume(d, this._momentsGreen), w = _WuQuant$1._volume(d, this._momentsBlue), I = _WuQuant$1._volume(d, this._momentsAlpha);
    return _WuQuant$1._volumeFloat(d, this._moments) - (m * m + g * g + w * w + I * I) / _WuQuant$1._volume(d, this._weights);
  }
  _maximize(d, m, g, w, I, P, F, D, U) {
    const Z = 0 | _WuQuant$1._bottom(d, m, this._momentsRed), $ = 0 | _WuQuant$1._bottom(d, m, this._momentsGreen), j = 0 | _WuQuant$1._bottom(d, m, this._momentsBlue), G = 0 | _WuQuant$1._bottom(d, m, this._momentsAlpha), Q = 0 | _WuQuant$1._bottom(d, m, this._weights);
    let H = 0, W = -1;
    for (let q = g; q < w; ++q) {
      let et = Z + _WuQuant$1._top(d, m, q, this._momentsRed), rt = $ + _WuQuant$1._top(d, m, q, this._momentsGreen), tt = j + _WuQuant$1._top(d, m, q, this._momentsBlue), V = G + _WuQuant$1._top(d, m, q, this._momentsAlpha), X = Q + _WuQuant$1._top(d, m, q, this._weights);
      if (X !== 0) {
        let ot = et * et + rt * rt + tt * tt + V * V, it = ot / X;
        et = I - et, rt = P - rt, tt = F - tt, V = D - V, X = U - X, X !== 0 && (ot = et * et + rt * rt + tt * tt + V * V, it += ot / X, it > H && (H = it, W = q));
      }
    }
    return { max: H, position: W };
  }
  _cut(d, m) {
    let g;
    const w = _WuQuant$1._volume(d, this._momentsRed), I = _WuQuant$1._volume(d, this._momentsGreen), P = _WuQuant$1._volume(d, this._momentsBlue), F = _WuQuant$1._volume(d, this._momentsAlpha), D = _WuQuant$1._volume(d, this._weights), U = this._maximize(d, _WuQuant$1._red, d.redMinimum + 1, d.redMaximum, w, I, P, F, D), Z = this._maximize(d, _WuQuant$1._green, d.greenMinimum + 1, d.greenMaximum, w, I, P, F, D), $ = this._maximize(d, _WuQuant$1._blue, d.blueMinimum + 1, d.blueMaximum, w, I, P, F, D), j = this._maximize(d, _WuQuant$1._alpha, d.alphaMinimum + 1, d.alphaMaximum, w, I, P, F, D);
    if (j.max >= U.max && j.max >= Z.max && j.max >= $.max) {
      if (g = _WuQuant$1._alpha, j.position < 0) return !1;
    } else g = U.max >= j.max && U.max >= Z.max && U.max >= $.max ? _WuQuant$1._red : Z.max >= j.max && Z.max >= U.max && Z.max >= $.max ? _WuQuant$1._green : _WuQuant$1._blue;
    switch (m.redMaximum = d.redMaximum, m.greenMaximum = d.greenMaximum, m.blueMaximum = d.blueMaximum, m.alphaMaximum = d.alphaMaximum, g) {
      case _WuQuant$1._red:
        m.redMinimum = d.redMaximum = U.position, m.greenMinimum = d.greenMinimum, m.blueMinimum = d.blueMinimum, m.alphaMinimum = d.alphaMinimum;
        break;
      case _WuQuant$1._green:
        m.greenMinimum = d.greenMaximum = Z.position, m.redMinimum = d.redMinimum, m.blueMinimum = d.blueMinimum, m.alphaMinimum = d.alphaMinimum;
        break;
      case _WuQuant$1._blue:
        m.blueMinimum = d.blueMaximum = $.position, m.redMinimum = d.redMinimum, m.greenMinimum = d.greenMinimum, m.alphaMinimum = d.alphaMinimum;
        break;
      case _WuQuant$1._alpha:
        m.alphaMinimum = d.alphaMaximum = j.position, m.blueMinimum = d.blueMinimum, m.redMinimum = d.redMinimum, m.greenMinimum = d.greenMinimum;
    }
    return d.volume = (d.redMaximum - d.redMinimum) * (d.greenMaximum - d.greenMinimum) * (d.blueMaximum - d.blueMinimum) * (d.alphaMaximum - d.alphaMinimum), m.volume = (m.redMaximum - m.redMinimum) * (m.greenMaximum - m.greenMinimum) * (m.blueMaximum - m.blueMinimum) * (m.alphaMaximum - m.alphaMinimum), !0;
  }
  _initialize(d) {
    this._colors = d, this._cubes = [];
    for (let m = 0; m < d; m++) this._cubes[m] = new WuColorCube$1();
    this._cubes[0].redMinimum = 0, this._cubes[0].greenMinimum = 0, this._cubes[0].blueMinimum = 0, this._cubes[0].alphaMinimum = 0, this._cubes[0].redMaximum = this._maxSideIndex, this._cubes[0].greenMaximum = this._maxSideIndex, this._cubes[0].blueMaximum = this._maxSideIndex, this._cubes[0].alphaMaximum = this._alphaMaxSideIndex, this._weights = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsRed = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsGreen = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsBlue = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsAlpha = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._moments = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._table = [];
    for (let m = 0; m < 256; ++m) this._table[m] = m * m;
    this._pixels = [];
  }
  _setQuality(d = 5) {
    this._significantBitsPerChannel = d, this._maxSideIndex = 1 << this._significantBitsPerChannel, this._alphaMaxSideIndex = this._maxSideIndex, this._sideSize = this._maxSideIndex + 1, this._alphaSideSize = this._alphaMaxSideIndex + 1;
  }
}, WuQuant$1 = _WuQuant$1;
__publicField$3(WuQuant$1, "_alpha", 3), __publicField$3(WuQuant$1, "_red", 2), __publicField$3(WuQuant$1, "_green", 1), __publicField$3(WuQuant$1, "_blue", 0);
var image_exports$1 = {};
__export$1(image_exports$1, { AbstractImageQuantizer: () => AbstractImageQuantizer$1, ErrorDiffusionArray: () => ErrorDiffusionArray$1, ErrorDiffusionArrayKernel: () => ErrorDiffusionArrayKernel$1, ErrorDiffusionRiemersma: () => ErrorDiffusionRiemersma$1, NearestColor: () => NearestColor$1 });
var AbstractImageQuantizer$1 = class {
  quantizeSync(d, m) {
    for (const g of this.quantize(d, m)) if (g.pointContainer) return g.pointContainer;
    throw new Error("unreachable");
  }
}, NearestColor$1 = class extends AbstractImageQuantizer$1 {
  constructor(d) {
    super(), __publicField$3(this, "_distance"), this._distance = d;
  }
  *quantize(d, m) {
    const g = d.getPointArray(), w = d.getWidth(), I = d.getHeight(), P = new ProgressTracker$1(I, 99);
    for (let F = 0; F < I; F++) {
      P.shouldNotify(F) && (yield { progress: P.progress });
      for (let D = 0, U = F * w; D < w; D++, U++) {
        const Z = g[U];
        Z.from(m.getNearestColor(this._distance, Z));
      }
    }
    yield { pointContainer: d, progress: 100 };
  }
}, ErrorDiffusionArrayKernel$1 = ((d) => (d[d.FloydSteinberg = 0] = "FloydSteinberg", d[d.FalseFloydSteinberg = 1] = "FalseFloydSteinberg", d[d.Stucki = 2] = "Stucki", d[d.Atkinson = 3] = "Atkinson", d[d.Jarvis = 4] = "Jarvis", d[d.Burkes = 5] = "Burkes", d[d.Sierra = 6] = "Sierra", d[d.TwoSierra = 7] = "TwoSierra", d[d.SierraLite = 8] = "SierraLite", d))(ErrorDiffusionArrayKernel$1 || {}), ErrorDiffusionArray$1 = class extends AbstractImageQuantizer$1 {
  constructor(d, m, g = !0, w = 0, I = !1) {
    super(), __publicField$3(this, "_minColorDistance"), __publicField$3(this, "_serpentine"), __publicField$3(this, "_kernel"), __publicField$3(this, "_calculateErrorLikeGIMP"), __publicField$3(this, "_distance"), this._setKernel(m), this._distance = d, this._minColorDistance = w, this._serpentine = g, this._calculateErrorLikeGIMP = I;
  }
  *quantize(d, m) {
    const g = d.getPointArray(), w = new Point$1(), I = d.getWidth(), P = d.getHeight(), F = [];
    let D = 1, U = 1;
    for (const $ of this._kernel) {
      const j = $[2] + 1;
      U < j && (U = j);
    }
    for (let $ = 0; $ < U; $++) this._fillErrorLine(F[$] = [], I);
    const Z = new ProgressTracker$1(P, 99);
    for (let $ = 0; $ < P; $++) {
      Z.shouldNotify($) && (yield { progress: Z.progress }), this._serpentine && (D *= -1);
      const j = $ * I, G = D === 1 ? 0 : I - 1, Q = D === 1 ? I : -1;
      this._fillErrorLine(F[0], I), F.push(F.shift());
      const H = F[0];
      for (let W = G, q = j + G; W !== Q; W += D, q += D) {
        const et = g[q], rt = H[W];
        w.from(et);
        const tt = Point$1.createByRGBA(inRange0to255Rounded$1(et.r + rt[0]), inRange0to255Rounded$1(et.g + rt[1]), inRange0to255Rounded$1(et.b + rt[2]), inRange0to255Rounded$1(et.a + rt[3])), V = m.getNearestColor(this._distance, tt);
        if (et.from(V), this._minColorDistance && this._distance.calculateNormalized(w, V) < this._minColorDistance)
          continue;
        let X, ot, it, st;
        this._calculateErrorLikeGIMP ? (X = tt.r - V.r, ot = tt.g - V.g, it = tt.b - V.b, st = tt.a - V.a) : (X = w.r - V.r, ot = w.g - V.g, it = w.b - V.b, st = w.a - V.a);
        const at = D === 1 ? 0 : this._kernel.length - 1, ct = D === 1 ? this._kernel.length : -1;
        for (let K = at; K !== ct; K += D) {
          const lt = this._kernel[K][1] * D, vt = this._kernel[K][2];
          if (lt + W >= 0 && lt + W < I && vt + $ >= 0 && vt + $ < P) {
            const dt = this._kernel[K][0], ht = F[vt][lt + W];
            ht[0] += X * dt, ht[1] += ot * dt, ht[2] += it * dt, ht[3] += st * dt;
          }
        }
      }
    }
    yield { pointContainer: d, progress: 100 };
  }
  _fillErrorLine(d, m) {
    d.length > m && (d.length = m);
    const g = d.length;
    for (let w = 0; w < g; w++) {
      const I = d[w];
      I[0] = I[1] = I[2] = I[3] = 0;
    }
    for (let w = g; w < m; w++) d[w] = [0, 0, 0, 0];
  }
  _setKernel(d) {
    switch (d) {
      case 0:
        this._kernel = [[7 / 16, 1, 0], [3 / 16, -1, 1], [5 / 16, 0, 1], [1 / 16, 1, 1]];
        break;
      case 1:
        this._kernel = [[3 / 8, 1, 0], [3 / 8, 0, 1], [2 / 8, 1, 1]];
        break;
      case 2:
        this._kernel = [[8 / 42, 1, 0], [4 / 42, 2, 0], [2 / 42, -2, 1], [4 / 42, -1, 1], [8 / 42, 0, 1], [4 / 42, 1, 1], [2 / 42, 2, 1], [1 / 42, -2, 2], [2 / 42, -1, 2], [4 / 42, 0, 2], [2 / 42, 1, 2], [1 / 42, 2, 2]];
        break;
      case 3:
        this._kernel = [[1 / 8, 1, 0], [1 / 8, 2, 0], [1 / 8, -1, 1], [1 / 8, 0, 1], [1 / 8, 1, 1], [1 / 8, 0, 2]];
        break;
      case 4:
        this._kernel = [[7 / 48, 1, 0], [5 / 48, 2, 0], [3 / 48, -2, 1], [5 / 48, -1, 1], [7 / 48, 0, 1], [5 / 48, 1, 1], [3 / 48, 2, 1], [1 / 48, -2, 2], [3 / 48, -1, 2], [5 / 48, 0, 2], [3 / 48, 1, 2], [1 / 48, 2, 2]];
        break;
      case 5:
        this._kernel = [[0.25, 1, 0], [4 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [0.25, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1]];
        break;
      case 6:
        this._kernel = [[5 / 32, 1, 0], [3 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [5 / 32, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1], [2 / 32, -1, 2], [3 / 32, 0, 2], [2 / 32, 1, 2]];
        break;
      case 7:
        this._kernel = [[0.25, 1, 0], [3 / 16, 2, 0], [1 / 16, -2, 1], [2 / 16, -1, 1], [3 / 16, 0, 1], [2 / 16, 1, 1], [1 / 16, 2, 1]];
        break;
      case 8:
        this._kernel = [[0.5, 1, 0], [1 / 4, -1, 1], [1 / 4, 0, 1]];
        break;
      default:
        throw new Error(`ErrorDiffusionArray: unknown kernel = ${d}`);
    }
  }
};
function* hilbertCurve$1(d, m, g) {
  const w = Math.max(d, m), I = { width: d, height: m, level: Math.floor(Math.log(w) / Math.log(2) + 1), callback: g, tracker: new ProgressTracker$1(d * m, 99), index: 0, x: 0, y: 0 };
  yield* walkHilbert$1(I, 1), visit$1(I, 0);
}
function* walkHilbert$1(d, m) {
  if (!(d.level < 1)) {
    switch (d.tracker.shouldNotify(d.index) && (yield { progress: d.tracker.progress }), d.level--, m) {
      case 2:
        yield* walkHilbert$1(d, 1), visit$1(d, 3), yield* walkHilbert$1(d, 2), visit$1(d, 4), yield* walkHilbert$1(d, 2), visit$1(d, 2), yield* walkHilbert$1(d, 4);
        break;
      case 3:
        yield* walkHilbert$1(d, 4), visit$1(d, 2), yield* walkHilbert$1(d, 3), visit$1(d, 1), yield* walkHilbert$1(d, 3), visit$1(d, 3), yield* walkHilbert$1(d, 1);
        break;
      case 1:
        yield* walkHilbert$1(d, 2), visit$1(d, 4), yield* walkHilbert$1(d, 1), visit$1(d, 3), yield* walkHilbert$1(d, 1), visit$1(d, 1), yield* walkHilbert$1(d, 3);
        break;
      case 4:
        yield* walkHilbert$1(d, 3), visit$1(d, 1), yield* walkHilbert$1(d, 4), visit$1(d, 2), yield* walkHilbert$1(d, 4), visit$1(d, 4), yield* walkHilbert$1(d, 2);
    }
    d.level++;
  }
}
function visit$1(d, m) {
  switch (d.x >= 0 && d.x < d.width && d.y >= 0 && d.y < d.height && (d.callback(d.x, d.y), d.index++), m) {
    case 2:
      d.x--;
      break;
    case 3:
      d.x++;
      break;
    case 1:
      d.y--;
      break;
    case 4:
      d.y++;
  }
}
var ErrorDiffusionRiemersma$1 = class extends AbstractImageQuantizer$1 {
  constructor(d, m = 16, g = 1) {
    super(), __publicField$3(this, "_distance"), __publicField$3(this, "_weights"), __publicField$3(this, "_errorQueueSize"), this._distance = d, this._errorQueueSize = m, this._weights = ErrorDiffusionRiemersma$1._createWeights(g, m);
  }
  *quantize(d, m) {
    const g = d.getPointArray(), w = d.getWidth(), I = d.getHeight(), P = [];
    let F = 0;
    for (let D = 0; D < this._errorQueueSize; D++) P[D] = { r: 0, g: 0, b: 0, a: 0 };
    yield* hilbertCurve$1(w, I, (D, U) => {
      const Z = g[D + U * w];
      let { r: $, g: j, b: G, a: Q } = Z;
      for (let et = 0; et < this._errorQueueSize; et++) {
        const rt = this._weights[et], tt = P[(et + F) % this._errorQueueSize];
        $ += tt.r * rt, j += tt.g * rt, G += tt.b * rt, Q += tt.a * rt;
      }
      const H = Point$1.createByRGBA(inRange0to255Rounded$1($), inRange0to255Rounded$1(j), inRange0to255Rounded$1(G), inRange0to255Rounded$1(Q)), W = m.getNearestColor(this._distance, H);
      F = (F + 1) % this._errorQueueSize;
      const q = (F + this._errorQueueSize - 1) % this._errorQueueSize;
      P[q].r = Z.r - W.r, P[q].g = Z.g - W.g, P[q].b = Z.b - W.b, P[q].a = Z.a - W.a, Z.from(W);
    }), yield { pointContainer: d, progress: 100 };
  }
  static _createWeights(d, m) {
    const g = [], w = Math.exp(Math.log(m) / (m - 1));
    for (let I = 0, P = 1; I < m; I++) g[I] = (P + 0.5 | 0) / m * d, P *= w;
    return g;
  }
}, quality_exports$1 = {};
__export$1(quality_exports$1, { ssim: () => ssim$1 });
var K1$1 = 0.01, K2$1 = 0.03;
function ssim$1(d, m) {
  if (d.getHeight() !== m.getHeight() || d.getWidth() !== m.getWidth()) throw new Error("Images have different sizes!");
  const g = (255 * K1$1) ** 2, w = (255 * K2$1) ** 2;
  let I = 0, P = 0;
  return iterate$1(d, m, (F, D, U, Z) => {
    let $ = 0, j = 0, G = 0;
    for (let H = 0; H < F.length; H++) j += (F[H] - U) ** 2, G += (D[H] - Z) ** 2, $ += (F[H] - U) * (D[H] - Z);
    const Q = F.length - 1;
    j /= Q, G /= Q, $ /= Q, P += (2 * U * Z + g) * (2 * $ + w) / ((U ** 2 + Z ** 2 + g) * (j + G + w)), I++;
  }), P / I;
}
function iterate$1(d, m, g) {
  const w = d.getWidth(), I = d.getHeight();
  for (let P = 0; P < I; P += 8) for (let F = 0; F < w; F += 8) {
    const D = Math.min(8, w - F), U = Math.min(8, I - P), Z = calculateLumaValuesForWindow$1(d, F, P, D, U), $ = calculateLumaValuesForWindow$1(m, F, P, D, U);
    g(Z, $, calculateAverageLuma$1(Z), calculateAverageLuma$1($));
  }
}
function calculateLumaValuesForWindow$1(d, m, g, w, I) {
  const P = d.getPointArray(), F = [];
  let D = 0;
  for (let U = g; U < g + I; U++) {
    const Z = U * d.getWidth();
    for (let $ = m; $ < m + w; $++) {
      const j = P[Z + $];
      F[D] = 0.2126 * j.r + 0.7152 * j.g + 0.0722 * j.b, D++;
    }
  }
  return F;
}
function calculateAverageLuma$1(d) {
  let m = 0;
  for (const g of d) m += g;
  return m / d.length;
}
var setImmediateImpl = typeof setImmediate == "function" ? setImmediate : typeof process < "u" && typeof (process == null ? void 0 : process.nextTick) == "function" ? (d) => process.nextTick(d) : (d) => setTimeout(d, 0);
function buildPaletteSync$1(d, { colorDistanceFormula: m, paletteQuantization: g, colors: w } = {}) {
  const I = paletteQuantizationToPaletteQuantizer$1(colorDistanceFormulaToColorDistance$1(m), g, w);
  return d.forEach((P) => I.sample(P)), I.quantizeSync();
}
async function buildPalette(d, { colorDistanceFormula: m, paletteQuantization: g, colors: w, onProgress: I } = {}) {
  return new Promise((P, F) => {
    const D = paletteQuantizationToPaletteQuantizer$1(colorDistanceFormulaToColorDistance$1(m), g, w);
    let U;
    d.forEach((j) => D.sample(j));
    const Z = D.quantize(), $ = () => {
      try {
        const j = Z.next();
        j.done ? P(U) : (j.value.palette && (U = j.value.palette), I && I(j.value.progress), setImmediateImpl($));
      } catch (j) {
        F(j);
      }
    };
    setImmediateImpl($);
  });
}
function applyPaletteSync$1(d, m, { colorDistanceFormula: g, imageQuantization: w } = {}) {
  return imageQuantizationToImageQuantizer$1(colorDistanceFormulaToColorDistance$1(g), w).quantizeSync(d, m);
}
async function applyPalette(d, m, { colorDistanceFormula: g, imageQuantization: w, onProgress: I } = {}) {
  return new Promise((P, F) => {
    let D;
    const U = imageQuantizationToImageQuantizer$1(colorDistanceFormulaToColorDistance$1(g), w).quantize(d, m), Z = () => {
      try {
        const $ = U.next();
        $.done ? P(D) : ($.value.pointContainer && (D = $.value.pointContainer), I && I($.value.progress), setImmediateImpl(Z));
      } catch ($) {
        F($);
      }
    };
    setImmediateImpl(Z);
  });
}
function colorDistanceFormulaToColorDistance$1(d = "euclidean-bt709") {
  switch (d) {
    case "cie94-graphic-arts":
      return new CIE94GraphicArts$1();
    case "cie94-textiles":
      return new CIE94Textiles$1();
    case "ciede2000":
      return new CIEDE2000$1();
    case "color-metric":
      return new CMetric$1();
    case "euclidean":
      return new Euclidean$1();
    case "euclidean-bt709":
      return new EuclideanBT709$1();
    case "euclidean-bt709-noalpha":
      return new EuclideanBT709NoAlpha$1();
    case "manhattan":
      return new Manhattan$1();
    case "manhattan-bt709":
      return new ManhattanBT709$1();
    case "manhattan-nommyde":
      return new ManhattanNommyde$1();
    case "pngquant":
      return new PNGQuant$1();
    default:
      throw new Error(`Unknown colorDistanceFormula ${d}`);
  }
}
function imageQuantizationToImageQuantizer$1(d, m = "floyd-steinberg") {
  switch (m) {
    case "nearest":
      return new NearestColor$1(d);
    case "riemersma":
      return new ErrorDiffusionRiemersma$1(d);
    case "floyd-steinberg":
      return new ErrorDiffusionArray$1(d, 0);
    case "false-floyd-steinberg":
      return new ErrorDiffusionArray$1(d, 1);
    case "stucki":
      return new ErrorDiffusionArray$1(d, 2);
    case "atkinson":
      return new ErrorDiffusionArray$1(d, 3);
    case "jarvis":
      return new ErrorDiffusionArray$1(d, 4);
    case "burkes":
      return new ErrorDiffusionArray$1(d, 5);
    case "sierra":
      return new ErrorDiffusionArray$1(d, 6);
    case "two-sierra":
      return new ErrorDiffusionArray$1(d, 7);
    case "sierra-lite":
      return new ErrorDiffusionArray$1(d, 8);
    default:
      throw new Error(`Unknown imageQuantization ${m}`);
  }
}
function paletteQuantizationToPaletteQuantizer$1(d, m = "wuquant", g = 256) {
  switch (m) {
    case "neuquant":
      return new NeuQuant$1(d, g);
    case "rgbquant":
      return new RGBQuant$1(d, g);
    case "wuquant":
      return new WuQuant$1(d, g);
    case "neuquant-float":
      return new NeuQuantFloat$1(d, g);
    default:
      throw new Error(`Unknown paletteQuantization ${m}`);
  }
}
var imageQ = __toCommonJS(src_exports), gifframe = {};
const BitmapImage$1 = bitmapimage;
let GifFrame$1 = class Qe extends BitmapImage$1 {
  constructor(...m) {
    if (super(...m), m[0] instanceof Qe) {
      const g = m[0];
      this.xOffset = g.xOffset, this.yOffset = g.yOffset, this.disposalMethod = g.disposalMethod, this.delayCentisecs = g.delayCentisecs, this.interlaced = g.interlaced;
    } else {
      const g = m[m.length - 1];
      let w = {};
      typeof g != "object" || g instanceof BitmapImage$1 || (w = g), this.xOffset = w.xOffset || 0, this.yOffset = w.yOffset || 0, this.disposalMethod = w.disposalMethod !== void 0 ? w.disposalMethod : Qe.DisposeToBackgroundColor, this.delayCentisecs = w.delayCentisecs || 8, this.interlaced = w.interlaced || !1;
    }
  }
  getPalette() {
    const m = /* @__PURE__ */ new Set(), g = this.bitmap.data;
    let w = 0, I = !1;
    for (; w < g.length; ) {
      if (g[w + 3] === 0) I = !0;
      else {
        const U = g.readUInt32BE(w, !0) >> 8 & 16777215;
        m.add(U);
      }
      w += 4;
    }
    const P = new Array(m.size), F = m.values();
    for (w = 0; w < P.length; ++w) P[w] = F.next().value;
    P.sort((U, Z) => U - Z);
    let D = P.length;
    return I && ++D, { colors: P, usesTransparency: I, indexCount: D };
  }
};
var hasRequiredGifutil, hasRequiredGifcodec;
function requireGifutil() {
  return hasRequiredGifutil || (hasRequiredGifutil = 1, function(d) {
    const m = require$$0, g = imageQ, w = bitmapimage, { GifFrame: I } = gifframe, { GifError: P } = gif$1, { GifCodec: F } = requireGifcodec(), D = [".jpg", ".jpeg", ".png", ".bmp"], U = new F();
    function Z($, j, G, Q, H) {
      const W = Array.isArray($) ? $ : [$];
      if (H) {
        if (["FloydSteinberg", "FalseFloydSteinberg", "Stucki", "Atkinson", "Jarvis", "Burkes", "Sierra", "TwoSierra", "SierraLite"].indexOf(H.ditherAlgorithm) < 0) throw new Error(`Invalid ditherAlgorithm '${H.ditherAlgorithm}'`);
        H.serpentine === void 0 && (H.serpentine = !0), H.minimumColorDistanceToDither === void 0 && (H.minimumColorDistanceToDither = 0), H.calculateErrorLikeGIMP === void 0 && (H.calculateErrorLikeGIMP = !1);
      }
      const q = new g.distance.Euclidean(), et = new g.palette[j](q, G, Q);
      let rt;
      rt = H ? new g.image.ErrorDiffusionArray(q, g.image.ErrorDiffusionArrayKernel[H.ditherAlgorithm], H.serpentine, H.minimumColorDistanceToDither, H.calculateErrorLikeGIMP) : new g.image.NearestColor(q);
      const tt = [];
      W.forEach((X) => {
        const ot = X.bitmap.data, it = new ArrayBuffer(ot.length), st = new Uint32Array(it);
        for (let ct = 0, K = 0; ct < ot.length; ct += 4, ++K) st[K] = ot.readUInt32LE(ct, !0);
        const at = g.utils.PointContainer.fromUint32Array(st, X.bitmap.width, X.bitmap.height);
        et.sample(at), tt.push(at);
      });
      const V = et.quantizeSync();
      for (let X = 0; X < W.length; ++X) {
        const ot = W[X].bitmap.data, it = rt.quantizeSync(tt[X], V).toUint32Array();
        for (let st = 0, at = 0; st < ot.length; st += 4, ++at) ot.writeUInt32LE(it[at], st);
      }
    }
    d.cloneFrames = function($) {
      let j = [];
      return $.forEach((G) => {
        j.push(new I(G));
      }), j;
    }, d.getColorInfo = function($, j) {
      let G = !1;
      const Q = [];
      for (let rt = 0; rt < $.length; ++rt) {
        let tt = $[rt].getPalette();
        if (tt.usesTransparency && (G = !0), tt.indexCount > 256) throw new P(`Frame ${rt} uses more than 256 color indexes`);
        Q.push(tt);
      }
      if (j === 0) return { usesTransparency: G, palettes: Q };
      const H = /* @__PURE__ */ new Set();
      Q.forEach((rt) => {
        rt.colors.forEach((tt) => {
          H.add(tt);
        });
      });
      let W = H.size;
      if (G && ++W, j && W > j) return { usesTransparency: G, palettes: Q };
      const q = new Array(H.size), et = H.values();
      for (let rt = 0; rt < q.length; ++rt) q[rt] = et.next().value;
      return q.sort((rt, tt) => rt - tt), { colors: q, indexCount: W, usesTransparency: G, palettes: Q };
    }, d.copyAsJimp = function($, j) {
      return d.shareAsJimp($, new w(j));
    }, d.getMaxDimensions = function($) {
      let j = 0, G = 0;
      return $.forEach((Q) => {
        const H = Q.xOffset + Q.bitmap.width;
        H > j && (j = H);
        const W = Q.yOffset + Q.bitmap.height;
        W > G && (G = W);
      }), { maxWidth: j, maxHeight: G };
    }, d.quantizeDekker = function($, j, G) {
      Z($, "NeuQuantFloat", j = j || 256, 0, G);
    }, d.quantizeSorokin = function($, j, G, Q) {
      let H;
      switch (j = j || 256, G = G || "min-pop") {
        case "min-pop":
          H = 2;
          break;
        case "top-pop":
          H = 1;
          break;
        default:
          throw new Error(`Invalid quantizeSorokin histogram '${G}'`);
      }
      Z($, "RGBQuant", j, H, Q);
    }, d.quantizeWu = function($, j, G, Q) {
      if (j = j || 256, (G = G || 5) < 1 || G > 8) throw new Error("Invalid quantization quality");
      Z($, "WuQuant", j, G, Q);
    }, d.read = function($, j) {
      return j = j || U, Buffer.isBuffer($) ? j.decodeGif($) : function(G) {
        return new Promise((Q, H) => {
          m.readFile(G, (W, q) => W ? H(W) : Q(q));
        });
      }($).then((G) => j.decodeGif(G));
    }, d.shareAsJimp = function($, j) {
      const G = new $(j.bitmap.width, j.bitmap.height, 0);
      return G.bitmap.data = j.bitmap.data, G;
    }, d.write = function($, j, G, Q) {
      Q = Q || U;
      const H = $.match(/\.[a-zA-Z]+$/);
      if (H !== null && D.includes(H[0].toLowerCase())) throw new Error(`GIF '${$}' has an unexpected suffix`);
      return Q.encodeGif(j, G).then((W) => function(q, et) {
        return new Promise((rt, tt) => {
          m.writeFile(q, et, (V) => V ? tt(V) : rt());
        });
      }($, W.buffer).then(() => W));
    };
  }(gifutil)), gifutil;
}
function requireGifcodec() {
  if (hasRequiredGifcodec) return gifcodec;
  hasRequiredGifcodec = 1;
  const d = omggif, { Gif: m, GifError: g } = gif$1;
  function w() {
    const j = requireGifutil();
    return w = function() {
      return j;
    }, j;
  }
  const { GifFrame: I } = gifframe;
  function P(j, G) {
    const Q = j.indexOf(G);
    return Q === -1 ? null : Q;
  }
  function F(j, G) {
    for (var Q, H = 0, W = j.length - 1; H <= W; ) if (j[Q = Math.floor((H + W) / 2)] > G) W = Q - 1;
    else {
      if (!(j[Q] < G)) return Q;
      H = Q + 1;
    }
    return null;
  }
  function D(j) {
    const G = j.colors;
    j.usesTransparency && G.push(0);
    const Q = G.length;
    let H = 2;
    for (; Q > H; ) H <<= 1;
    G.length = H, G.fill(0, Q);
  }
  function U(j, G) {
    let Q = j.bitmap.width * j.bitmap.height;
    return Q = Math.ceil(Q * G / 8), Q += Math.ceil(Q / 255), 100 + Q + 768;
  }
  function Z(j) {
    let G = j.indexCount, Q = 0;
    for (--G; G; ) ++Q, G >>= 1;
    return Q > 0 ? Q : 1;
  }
  function $(j, G, Q, H, W) {
    if (Q.interlaced) throw new g("writing interlaced GIFs is not supported");
    const q = function(rt, tt, V) {
      const X = V.colors, ot = X.length <= 8 ? P : F, it = tt.bitmap.data, st = new Buffer(it.length / 4);
      let at = X.length, ct = 0, K = 0;
      for (; ct < it.length; ) {
        if (it[ct + 3] !== 0) {
          const lt = it.readUInt32BE(ct, !0) >> 8 & 16777215;
          st[K] = ot(X, lt);
        } else st[K] = at;
        ct += 4, ++K;
      }
      if (V.usesTransparency) {
        if (at === 256) throw new g(`Frame ${rt} already has 256 colorsand so can't use transparency`);
      } else at = null;
      return { buffer: st, transparentIndex: at };
    }(G, Q, H), et = { delay: Q.delayCentisecs, disposal: Q.disposalMethod, transparent: q.transparentIndex };
    W && (D(H), et.palette = H.colors);
    try {
      let rt, tt = j.getOutputBuffer(), V = j.getOutputBufferPosition(), X = !0;
      for (; X; ) if (rt = j.addFrame(Q.xOffset, Q.yOffset, Q.bitmap.width, Q.bitmap.height, q.buffer, et), X = !1, rt >= tt.length - 1) {
        const ot = new Buffer(1.5 * tt.length);
        tt.copy(ot), j.setOutputBuffer(ot), j.setOutputBufferPosition(V), tt = ot, X = !0;
      }
      return tt;
    } catch (rt) {
      throw new g(rt);
    }
  }
  return gifcodec.GifCodec = class {
    constructor(j = {}) {
      this._transparentRGB = null, typeof j.transparentRGB == "number" && j.transparentRGB !== 0 && (this._transparentRGBA = 256 * j.transparentRGB), this._testInitialBufferSize = 0;
    }
    decodeGif(j) {
      try {
        let G;
        try {
          G = new d.GifReader(j);
        } catch (q) {
          throw new g(q);
        }
        const Q = G.numFrames(), H = [], W = { width: G.width, height: G.height, loops: G.loopCount(), usesTransparency: !1 };
        for (let q = 0; q < Q; ++q) {
          const et = this._decodeFrame(G, q, W.usesTransparency);
          H.push(et.frame), et.usesTransparency && (W.usesTransparency = !0);
        }
        return Promise.resolve(new m(j, H, W));
      } catch (G) {
        return Promise.reject(G);
      }
    }
    encodeGif(j, G = {}) {
      try {
        if (j === null || j.length === 0) throw new g("there are no frames");
        const Q = w().getMaxDimensions(j);
        return (G = Object.assign({}, G)).width = Q.maxWidth, G.height = Q.maxHeight, G.loops === void 0 && (G.loops = 0), G.colorScope = G.colorScope || m.GlobalColorsPreferred, Promise.resolve(this._encodeGif(j, G));
      } catch (Q) {
        return Promise.reject(Q);
      }
    }
    _decodeFrame(j, G, Q) {
      let H, W;
      try {
        if (H = j.frameInfo(G), W = new Buffer(j.width * j.height * 4), j.decodeAndBlitFrameRGBA(G, W), H.width !== j.width || H.height !== j.height) {
          if (H.y && (W = W.slice(H.y * j.width * 4)), j.width > H.width) for (let et = 0; et < H.height; ++et) W.copy(W, et * H.width * 4, 4 * (H.x + et * j.width), 4 * (H.x + et * j.width) + 4 * H.width);
          W = W.slice(0, H.width * H.height * 4);
        }
      } catch (et) {
        throw new g(et);
      }
      let q = !1;
      if (this._transparentRGBA === null) {
        if (!Q) for (let et = 3; et < W.length; et += 4) W[et] === 0 && (q = !0, et = W.length);
      } else for (let et = 3; et < W.length; et += 4) W[et] === 0 && (W.writeUInt32BE(this._transparentRGBA, et - 3), q = !0);
      return { frame: new I(H.width, H.height, W, { xOffset: H.x, yOffset: H.y, disposalMethod: H.disposal, interlaced: H.interlaced, delayCentisecs: H.delay }), usesTransparency: q };
    }
    _encodeGif(j, G) {
      let Q;
      if (G.colorScope === m.LocalColorsOnly) Q = w().getColorInfo(j, 0);
      else if (Q = w().getColorInfo(j, 256), !Q.colors) {
        if (G.colorScope === m.GlobalColorsOnly) throw new g("Too many color indexes for global color table");
        G.colorScope = m.LocalColorsOnly;
      }
      G.usesTransparency = Q.usesTransparency;
      const H = Q.palettes;
      return G.colorScope === m.LocalColorsOnly ? function(W, q, et, rt) {
        const tt = { loop: q.loops };
        let V, X = new Buffer(et);
        try {
          V = new d.GifWriter(X, q.width, q.height, tt);
        } catch (ot) {
          throw new g(ot);
        }
        for (let ot = 0; ot < W.length; ++ot) X = $(V, ot, W[ot], rt[ot], !0);
        return new m(X.slice(0, V.end()), W, q);
      }(j, G, 2e3, H) : function(W, q, et, rt) {
        const tt = { colors: rt.colors.slice(), usesTransparency: rt.usesTransparency };
        D(tt);
        const V = { palette: tt.colors, loop: q.loops };
        let X, ot = new Buffer(et);
        try {
          X = new d.GifWriter(ot, q.width, q.height, V);
        } catch (it) {
          throw new g(it);
        }
        for (let it = 0; it < W.length; ++it) ot = $(X, it, W[it], rt, !1);
        return new m(ot.slice(0, X.end()), W, q);
      }(j, G, 2e3, Q);
    }
    _getSizeEstimateGlobal(j, G) {
      if (this._testInitialBufferSize > 0) return this._testInitialBufferSize;
      let Q = 968;
      const H = Z(j);
      return G.forEach((W) => {
        Q += U(W, H);
      }), Q;
    }
    _getSizeEstimateLocal(j, G) {
      if (this._testInitialBufferSize > 0) return this._testInitialBufferSize;
      let Q = 200;
      for (let H = 0; H < G.length; ++H) {
        const W = Z(j[H]);
        Q += U(G[H], W);
      }
      return Q;
    }
  }, gifcodec;
}
GifFrame$1.DisposeToAnything = 0, GifFrame$1.DisposeNothing = 1, GifFrame$1.DisposeToBackgroundColor = 2, GifFrame$1.DisposeToPrevious = 3, gifframe.GifFrame = GifFrame$1;
const BitmapImage = bitmapimage, { GifCodec } = requireGifcodec(), { GifFrame } = gifframe, GifUtil = requireGifutil();
var src = { BitmapImage, GifCodec, GifFrame, GifUtil };
function gif() {
  return { mime: "image/gif", encode: async (d) => {
    const m = new src.BitmapImage(d);
    src.GifUtil.quantizeDekker(m, 256);
    const g = new src.GifFrame(d);
    return (await new src.GifCodec().encodeGif([g], {})).buffer;
  }, decode: (d) => {
    const m = new omggif.GifReader(d), g = Buffer.alloc(m.width * m.height * 4);
    return m.decodeAndBlitFrameRGBA(0, g), { data: g, width: m.width, height: m.height };
  } };
}
var encoder = { exports: {} };
(function(d) {
  function m(g) {
    var w, I, P, F, D, U = Math.floor, Z = new Array(64), $ = new Array(64), j = new Array(64), G = new Array(64), Q = new Array(65535), H = new Array(65535), W = new Array(64), q = new Array(64), et = [], rt = 0, tt = 7, V = new Array(64), X = new Array(64), ot = new Array(64), it = new Array(256), st = new Array(2048), at = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], ct = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], K = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], lt = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], vt = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], dt = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], ht = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], pt = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], Ct = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
    function St(Bt, kt) {
      for (var Tt = 0, Dt = 0, Zt = new Array(), $t = 1; $t <= 16; $t++) {
        for (var Mt = 1; Mt <= Bt[$t]; Mt++) Zt[kt[Dt]] = [], Zt[kt[Dt]][0] = Tt, Zt[kt[Dt]][1] = $t, Dt++, Tt++;
        Tt *= 2;
      }
      return Zt;
    }
    function At(Bt) {
      for (var kt = Bt[0], Tt = Bt[1] - 1; Tt >= 0; ) kt & 1 << Tt && (rt |= 1 << tt), Tt--, --tt < 0 && (rt == 255 ? (Ft(255), Ft(0)) : Ft(rt), tt = 7, rt = 0);
    }
    function Ft(Bt) {
      et.push(Bt);
    }
    function xt(Bt) {
      Ft(Bt >> 8 & 255), Ft(255 & Bt);
    }
    function Pt(Bt, kt, Tt, Dt, Zt) {
      for (var $t, Mt = Zt[0], nt = Zt[240], It = function(yt, Lt) {
        var jt, Kt, te, Vt, ee, Jt, le, ae, se, fe, ne = 0;
        for (se = 0; se < 8; ++se) {
          jt = yt[ne], Kt = yt[ne + 1], te = yt[ne + 2], Vt = yt[ne + 3], ee = yt[ne + 4], Jt = yt[ne + 5], le = yt[ne + 6];
          var Nt = jt + (ae = yt[ne + 7]), Xt = jt - ae, Ut = Kt + le, Wt = Kt - le, Et = te + Jt, Yt = te - Jt, ce = Vt + ee, ft = Vt - ee, qt = Nt + ce, Gt = Nt - ce, zt = Ut + Et, Qt = Ut - Et;
          yt[ne] = qt + zt, yt[ne + 4] = qt - zt;
          var Ht = 0.707106781 * (Qt + Gt);
          yt[ne + 2] = Gt + Ht, yt[ne + 6] = Gt - Ht;
          var ue = 0.382683433 * ((qt = ft + Yt) - (Qt = Wt + Xt)), ie = 0.5411961 * qt + ue, oe = 1.306562965 * Qt + ue, he = 0.707106781 * (zt = Yt + Wt), Ee = Xt + he, de = Xt - he;
          yt[ne + 5] = de + ie, yt[ne + 3] = de - ie, yt[ne + 1] = Ee + oe, yt[ne + 7] = Ee - oe, ne += 8;
        }
        for (ne = 0, se = 0; se < 8; ++se) {
          jt = yt[ne], Kt = yt[ne + 8], te = yt[ne + 16], Vt = yt[ne + 24], ee = yt[ne + 32], Jt = yt[ne + 40], le = yt[ne + 48];
          var me = jt + (ae = yt[ne + 56]), be = jt - ae, ye = Kt + le, Ie = Kt - le, Se = te + Jt, _e = te - Jt, we = Vt + ee, ke = Vt - ee, Ae = me + we, ve = me - we, ge = ye + Se, Te = ye - Se;
          yt[ne] = Ae + ge, yt[ne + 32] = Ae - ge;
          var He = 0.707106781 * (Te + ve);
          yt[ne + 16] = ve + He, yt[ne + 48] = ve - He;
          var We = 0.382683433 * ((Ae = ke + _e) - (Te = Ie + be)), qe = 0.5411961 * Ae + We, Ve = 1.306562965 * Te + We, Ye = 0.707106781 * (ge = _e + Ie), Ke = be + Ye, Je = be - Ye;
          yt[ne + 40] = Je + qe, yt[ne + 24] = Je - qe, yt[ne + 8] = Ke + Ve, yt[ne + 56] = Ke - Ve, ne++;
        }
        for (se = 0; se < 64; ++se) fe = yt[se] * Lt[se], W[se] = fe > 0 ? fe + 0.5 | 0 : fe - 0.5 | 0;
        return W;
      }(Bt, kt), mt = 0; mt < 64; ++mt) q[at[mt]] = It[mt];
      var gt = q[0] - Tt;
      Tt = q[0], gt == 0 ? At(Dt[0]) : (At(Dt[H[$t = 32767 + gt]]), At(Q[$t]));
      for (var _t = 63; _t > 0 && q[_t] == 0; _t--) ;
      if (_t == 0) return At(Mt), Tt;
      for (var wt, Rt = 1; Rt <= _t; ) {
        for (var J = Rt; q[Rt] == 0 && Rt <= _t; ++Rt) ;
        var ut = Rt - J;
        if (ut >= 16) {
          wt = ut >> 4;
          for (var bt = 1; bt <= wt; ++bt) At(nt);
          ut &= 15;
        }
        $t = 32767 + q[Rt], At(Zt[(ut << 4) + H[$t]]), At(Q[$t]), Rt++;
      }
      return _t != 63 && At(Mt), Tt;
    }
    function Ot(Bt) {
      Bt <= 0 && (Bt = 1), Bt > 100 && (Bt = 100), D != Bt && (function(kt) {
        for (var Tt = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], Dt = 0; Dt < 64; Dt++) {
          var Zt = U((Tt[Dt] * kt + 50) / 100);
          Zt < 1 ? Zt = 1 : Zt > 255 && (Zt = 255), Z[at[Dt]] = Zt;
        }
        for (var $t = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], Mt = 0; Mt < 64; Mt++) {
          var nt = U(($t[Mt] * kt + 50) / 100);
          nt < 1 ? nt = 1 : nt > 255 && (nt = 255), $[at[Mt]] = nt;
        }
        for (var It = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], mt = 0, gt = 0; gt < 8; gt++) for (var _t = 0; _t < 8; _t++) j[mt] = 1 / (Z[at[mt]] * It[gt] * It[_t] * 8), G[mt] = 1 / ($[at[mt]] * It[gt] * It[_t] * 8), mt++;
      }(Bt < 50 ? Math.floor(5e3 / Bt) : Math.floor(200 - 2 * Bt)), D = Bt);
    }
    this.encode = function(Bt, kt) {
      var Tt;
      (/* @__PURE__ */ new Date()).getTime(), kt && Ot(kt), et = new Array(), rt = 0, tt = 7, xt(65496), xt(65504), xt(16), Ft(74), Ft(70), Ft(73), Ft(70), Ft(0), Ft(1), Ft(1), Ft(0), xt(1), xt(1), Ft(0), Ft(0), (Tt = Bt.comments) !== void 0 && Tt.constructor === Array && Tt.forEach((te) => {
        if (typeof te == "string") {
          xt(65534);
          var Vt, ee = te.length;
          for (xt(ee + 2), Vt = 0; Vt < ee; Vt++) Ft(te.charCodeAt(Vt));
        }
      }), function(te) {
        if (te) {
          xt(65505), te[0] === 69 && te[1] === 120 && te[2] === 105 && te[3] === 102 ? xt(te.length + 2) : (xt(te.length + 5 + 2), Ft(69), Ft(120), Ft(105), Ft(102), Ft(0));
          for (var Vt = 0; Vt < te.length; Vt++) Ft(te[Vt]);
        }
      }(Bt.exifBuffer), function() {
        xt(65499), xt(132), Ft(0);
        for (var te = 0; te < 64; te++) Ft(Z[te]);
        Ft(1);
        for (var Vt = 0; Vt < 64; Vt++) Ft($[Vt]);
      }(), function(te, Vt) {
        xt(65472), xt(17), Ft(8), xt(Vt), xt(te), Ft(3), Ft(1), Ft(17), Ft(0), Ft(2), Ft(17), Ft(1), Ft(3), Ft(17), Ft(1);
      }(Bt.width, Bt.height), function() {
        xt(65476), xt(418), Ft(0);
        for (var te = 0; te < 16; te++) Ft(ct[te + 1]);
        for (var Vt = 0; Vt <= 11; Vt++) Ft(K[Vt]);
        Ft(16);
        for (var ee = 0; ee < 16; ee++) Ft(lt[ee + 1]);
        for (var Jt = 0; Jt <= 161; Jt++) Ft(vt[Jt]);
        Ft(1);
        for (var le = 0; le < 16; le++) Ft(dt[le + 1]);
        for (var ae = 0; ae <= 11; ae++) Ft(ht[ae]);
        Ft(17);
        for (var se = 0; se < 16; se++) Ft(pt[se + 1]);
        for (var fe = 0; fe <= 161; fe++) Ft(Ct[fe]);
      }(), xt(65498), xt(12), Ft(3), Ft(1), Ft(0), Ft(2), Ft(17), Ft(3), Ft(17), Ft(0), Ft(63), Ft(0);
      var Dt = 0, Zt = 0, $t = 0;
      rt = 0, tt = 7, this.encode.displayName = "_encode_";
      for (var Mt, nt, It, mt, gt, _t, wt, Rt, J, ut = Bt.data, bt = Bt.width, yt = Bt.height, Lt = 4 * bt, jt = 0; jt < yt; ) {
        for (Mt = 0; Mt < Lt; ) {
          for (_t = gt = Lt * jt + Mt, wt = -1, Rt = 0, J = 0; J < 64; J++) _t = gt + (Rt = J >> 3) * Lt + (wt = 4 * (7 & J)), jt + Rt >= yt && (_t -= Lt * (jt + 1 + Rt - yt)), Mt + wt >= Lt && (_t -= Mt + wt - Lt + 4), nt = ut[_t++], It = ut[_t++], mt = ut[_t++], V[J] = (st[nt] + st[It + 256 | 0] + st[mt + 512 | 0] >> 16) - 128, X[J] = (st[nt + 768 | 0] + st[It + 1024 | 0] + st[mt + 1280 | 0] >> 16) - 128, ot[J] = (st[nt + 1280 | 0] + st[It + 1536 | 0] + st[mt + 1792 | 0] >> 16) - 128;
          Dt = Pt(V, j, Dt, w, P), Zt = Pt(X, G, Zt, I, F), $t = Pt(ot, G, $t, I, F), Mt += 32;
        }
        jt += 8;
      }
      if (tt >= 0) {
        var Kt = [];
        Kt[1] = tt + 1, Kt[0] = (1 << tt + 1) - 1, At(Kt);
      }
      return xt(65497), Buffer.from(et);
    }, (/* @__PURE__ */ new Date()).getTime(), g || (g = 50), function() {
      for (var Bt = String.fromCharCode, kt = 0; kt < 256; kt++) it[kt] = Bt(kt);
    }(), w = St(ct, K), I = St(dt, ht), P = St(lt, vt), F = St(pt, Ct), function() {
      for (var Bt = 1, kt = 2, Tt = 1; Tt <= 15; Tt++) {
        for (var Dt = Bt; Dt < kt; Dt++) H[32767 + Dt] = Tt, Q[32767 + Dt] = [], Q[32767 + Dt][1] = Tt, Q[32767 + Dt][0] = Dt;
        for (var Zt = -(kt - 1); Zt <= -Bt; Zt++) H[32767 + Zt] = Tt, Q[32767 + Zt] = [], Q[32767 + Zt][1] = Tt, Q[32767 + Zt][0] = kt - 1 + Zt;
        Bt <<= 1, kt <<= 1;
      }
    }(), function() {
      for (var Bt = 0; Bt < 256; Bt++) st[Bt] = 19595 * Bt, st[Bt + 256 | 0] = 38470 * Bt, st[Bt + 512 | 0] = 7471 * Bt + 32768, st[Bt + 768 | 0] = -11059 * Bt, st[Bt + 1024 | 0] = -21709 * Bt, st[Bt + 1280 | 0] = 32768 * Bt + 8421375, st[Bt + 1536 | 0] = -27439 * Bt, st[Bt + 1792 | 0] = -5329 * Bt;
    }(), Ot(g), (/* @__PURE__ */ new Date()).getTime();
  }
  encoder.exports = function(g, w) {
    w === void 0 && (w = 50);
    var I = new m(w), P = I.encode(g, w);
    return { data: P, width: g.width, height: g.height };
  };
})();
var encoderExports = encoder.exports, decoder = { exports: {} }, module, JpegImage;
module = decoder, JpegImage = function() {
  var d = new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), m = 4017, g = 799, w = 3406, I = 2276, P = 1567, F = 3784, D = 5793, U = 2896;
  function Z() {
  }
  function $(et, rt) {
    for (var tt, V, X = 0, ot = [], it = 16; it > 0 && !et[it - 1]; ) it--;
    ot.push({ children: [], index: 0 });
    var st, at = ot[0];
    for (tt = 0; tt < it; tt++) {
      for (V = 0; V < et[tt]; V++) {
        for ((at = ot.pop()).children[at.index] = rt[X]; at.index > 0; ) {
          if (ot.length === 0) throw new Error("Could not recreate Huffman Table");
          at = ot.pop();
        }
        for (at.index++, ot.push(at); ot.length <= tt; ) ot.push(st = { children: [], index: 0 }), at.children[at.index] = st.children, at = st;
        X++;
      }
      tt + 1 < it && (ot.push(st = { children: [], index: 0 }), at.children[at.index] = st.children, at = st);
    }
    return ot[0].children;
  }
  function j(et, rt, tt, V, X, ot, it, st, at, ct) {
    tt.precision, tt.samplesPerLine, tt.scanLines;
    var K = tt.mcusPerLine, lt = tt.progressive;
    tt.maxH, tt.maxV;
    var vt = rt, dt = 0, ht = 0;
    function pt() {
      if (ht > 0) return ht--, dt >> ht & 1;
      if ((dt = et[rt++]) == 255) {
        var Rt = et[rt++];
        if (Rt) throw new Error("unexpected marker: " + (dt << 8 | Rt).toString(16));
      }
      return ht = 7, dt >>> 7;
    }
    function Ct(Rt) {
      for (var J, ut = Rt; (J = pt()) !== null; ) {
        if (typeof (ut = ut[J]) == "number") return ut;
        if (typeof ut != "object") throw new Error("invalid huffman sequence");
      }
      return null;
    }
    function St(Rt) {
      for (var J = 0; Rt > 0; ) {
        var ut = pt();
        if (ut === null) return;
        J = J << 1 | ut, Rt--;
      }
      return J;
    }
    function At(Rt) {
      var J = St(Rt);
      return J >= 1 << Rt - 1 ? J : J + (-1 << Rt) + 1;
    }
    var Ft, xt = 0, Pt = 0;
    function Ot(Rt, J, ut, bt, yt) {
      var Lt = ut % K, jt = (ut / K | 0) * Rt.v + bt, Kt = Lt * Rt.h + yt;
      Rt.blocks[jt] === void 0 && ct.tolerantDecoding || J(Rt, Rt.blocks[jt][Kt]);
    }
    function Bt(Rt, J, ut) {
      var bt = ut / Rt.blocksPerLine | 0, yt = ut % Rt.blocksPerLine;
      Rt.blocks[bt] === void 0 && ct.tolerantDecoding || J(Rt, Rt.blocks[bt][yt]);
    }
    var kt, Tt, Dt, Zt, $t, Mt, nt = V.length;
    Mt = lt ? ot === 0 ? st === 0 ? function(Rt, J) {
      var ut = Ct(Rt.huffmanTableDC), bt = ut === 0 ? 0 : At(ut) << at;
      J[0] = Rt.pred += bt;
    } : function(Rt, J) {
      J[0] |= pt() << at;
    } : st === 0 ? function(Rt, J) {
      if (xt > 0) xt--;
      else for (var ut = ot, bt = it; ut <= bt; ) {
        var yt = Ct(Rt.huffmanTableAC), Lt = 15 & yt, jt = yt >> 4;
        if (Lt !== 0) J[d[ut += jt]] = At(Lt) * (1 << at), ut++;
        else {
          if (jt < 15) {
            xt = St(jt) + (1 << jt) - 1;
            break;
          }
          ut += 16;
        }
      }
    } : function(Rt, J) {
      for (var ut = ot, bt = it, yt = 0; ut <= bt; ) {
        var Lt = d[ut], jt = J[Lt] < 0 ? -1 : 1;
        switch (Pt) {
          case 0:
            var Kt = Ct(Rt.huffmanTableAC), te = 15 & Kt;
            if (yt = Kt >> 4, te === 0) yt < 15 ? (xt = St(yt) + (1 << yt), Pt = 4) : (yt = 16, Pt = 1);
            else {
              if (te !== 1) throw new Error("invalid ACn encoding");
              Ft = At(te), Pt = yt ? 2 : 3;
            }
            continue;
          case 1:
          case 2:
            J[Lt] ? J[Lt] += (pt() << at) * jt : --yt == 0 && (Pt = Pt == 2 ? 3 : 0);
            break;
          case 3:
            J[Lt] ? J[Lt] += (pt() << at) * jt : (J[Lt] = Ft << at, Pt = 0);
            break;
          case 4:
            J[Lt] && (J[Lt] += (pt() << at) * jt);
        }
        ut++;
      }
      Pt === 4 && --xt == 0 && (Pt = 0);
    } : function(Rt, J) {
      var ut = Ct(Rt.huffmanTableDC), bt = ut === 0 ? 0 : At(ut);
      J[0] = Rt.pred += bt;
      for (var yt = 1; yt < 64; ) {
        var Lt = Ct(Rt.huffmanTableAC), jt = 15 & Lt, Kt = Lt >> 4;
        if (jt !== 0) J[d[yt += Kt]] = At(jt), yt++;
        else {
          if (Kt < 15) break;
          yt += 16;
        }
      }
    };
    var It, mt, gt, _t, wt = 0;
    for (mt = nt == 1 ? V[0].blocksPerLine * V[0].blocksPerColumn : K * tt.mcusPerColumn, X || (X = mt); wt < mt; ) {
      for (Tt = 0; Tt < nt; Tt++) V[Tt].pred = 0;
      if (xt = 0, nt == 1) for (kt = V[0], $t = 0; $t < X; $t++) Bt(kt, Mt, wt), wt++;
      else for ($t = 0; $t < X; $t++) {
        for (Tt = 0; Tt < nt; Tt++) for (gt = (kt = V[Tt]).h, _t = kt.v, Dt = 0; Dt < _t; Dt++) for (Zt = 0; Zt < gt; Zt++) Ot(kt, Mt, wt, Dt, Zt);
        if (++wt === mt) break;
      }
      if (wt === mt) do {
        if (et[rt] === 255 && et[rt + 1] !== 0) break;
        rt += 1;
      } while (rt < et.length - 2);
      if (ht = 0, (It = et[rt] << 8 | et[rt + 1]) < 65280) throw new Error("marker was not found");
      if (!(It >= 65488 && It <= 65495)) break;
      rt += 2;
    }
    return rt - vt;
  }
  function G(et, rt) {
    var tt, V, X = [], ot = rt.blocksPerLine, it = rt.blocksPerColumn, st = ot << 3, at = new Int32Array(64), ct = new Uint8Array(64);
    function K(St, At, Ft) {
      var xt, Pt, Ot, Bt, kt, Tt, Dt, Zt, $t, Mt, nt = rt.quantizationTable, It = Ft;
      for (Mt = 0; Mt < 64; Mt++) It[Mt] = St[Mt] * nt[Mt];
      for (Mt = 0; Mt < 8; ++Mt) {
        var mt = 8 * Mt;
        It[1 + mt] != 0 || It[2 + mt] != 0 || It[3 + mt] != 0 || It[4 + mt] != 0 || It[5 + mt] != 0 || It[6 + mt] != 0 || It[7 + mt] != 0 ? (xt = D * It[0 + mt] + 128 >> 8, Pt = D * It[4 + mt] + 128 >> 8, Ot = It[2 + mt], Bt = It[6 + mt], kt = U * (It[1 + mt] - It[7 + mt]) + 128 >> 8, Zt = U * (It[1 + mt] + It[7 + mt]) + 128 >> 8, Tt = It[3 + mt] << 4, Dt = It[5 + mt] << 4, $t = xt - Pt + 1 >> 1, xt = xt + Pt + 1 >> 1, Pt = $t, $t = Ot * F + Bt * P + 128 >> 8, Ot = Ot * P - Bt * F + 128 >> 8, Bt = $t, $t = kt - Dt + 1 >> 1, kt = kt + Dt + 1 >> 1, Dt = $t, $t = Zt + Tt + 1 >> 1, Tt = Zt - Tt + 1 >> 1, Zt = $t, $t = xt - Bt + 1 >> 1, xt = xt + Bt + 1 >> 1, Bt = $t, $t = Pt - Ot + 1 >> 1, Pt = Pt + Ot + 1 >> 1, Ot = $t, $t = kt * I + Zt * w + 2048 >> 12, kt = kt * w - Zt * I + 2048 >> 12, Zt = $t, $t = Tt * g + Dt * m + 2048 >> 12, Tt = Tt * m - Dt * g + 2048 >> 12, Dt = $t, It[0 + mt] = xt + Zt, It[7 + mt] = xt - Zt, It[1 + mt] = Pt + Dt, It[6 + mt] = Pt - Dt, It[2 + mt] = Ot + Tt, It[5 + mt] = Ot - Tt, It[3 + mt] = Bt + kt, It[4 + mt] = Bt - kt) : ($t = D * It[0 + mt] + 512 >> 10, It[0 + mt] = $t, It[1 + mt] = $t, It[2 + mt] = $t, It[3 + mt] = $t, It[4 + mt] = $t, It[5 + mt] = $t, It[6 + mt] = $t, It[7 + mt] = $t);
      }
      for (Mt = 0; Mt < 8; ++Mt) {
        var gt = Mt;
        It[8 + gt] != 0 || It[16 + gt] != 0 || It[24 + gt] != 0 || It[32 + gt] != 0 || It[40 + gt] != 0 || It[48 + gt] != 0 || It[56 + gt] != 0 ? (xt = D * It[0 + gt] + 2048 >> 12, Pt = D * It[32 + gt] + 2048 >> 12, Ot = It[16 + gt], Bt = It[48 + gt], kt = U * (It[8 + gt] - It[56 + gt]) + 2048 >> 12, Zt = U * (It[8 + gt] + It[56 + gt]) + 2048 >> 12, Tt = It[24 + gt], Dt = It[40 + gt], $t = xt - Pt + 1 >> 1, xt = xt + Pt + 1 >> 1, Pt = $t, $t = Ot * F + Bt * P + 2048 >> 12, Ot = Ot * P - Bt * F + 2048 >> 12, Bt = $t, $t = kt - Dt + 1 >> 1, kt = kt + Dt + 1 >> 1, Dt = $t, $t = Zt + Tt + 1 >> 1, Tt = Zt - Tt + 1 >> 1, Zt = $t, $t = xt - Bt + 1 >> 1, xt = xt + Bt + 1 >> 1, Bt = $t, $t = Pt - Ot + 1 >> 1, Pt = Pt + Ot + 1 >> 1, Ot = $t, $t = kt * I + Zt * w + 2048 >> 12, kt = kt * w - Zt * I + 2048 >> 12, Zt = $t, $t = Tt * g + Dt * m + 2048 >> 12, Tt = Tt * m - Dt * g + 2048 >> 12, Dt = $t, It[0 + gt] = xt + Zt, It[56 + gt] = xt - Zt, It[8 + gt] = Pt + Dt, It[48 + gt] = Pt - Dt, It[16 + gt] = Ot + Tt, It[40 + gt] = Ot - Tt, It[24 + gt] = Bt + kt, It[32 + gt] = Bt - kt) : ($t = D * Ft[Mt + 0] + 8192 >> 14, It[0 + gt] = $t, It[8 + gt] = $t, It[16 + gt] = $t, It[24 + gt] = $t, It[32 + gt] = $t, It[40 + gt] = $t, It[48 + gt] = $t, It[56 + gt] = $t);
      }
      for (Mt = 0; Mt < 64; ++Mt) {
        var _t = 128 + (It[Mt] + 8 >> 4);
        At[Mt] = _t < 0 ? 0 : _t > 255 ? 255 : _t;
      }
    }
    q(st * it * 8);
    for (var lt = 0; lt < it; lt++) {
      var vt = lt << 3;
      for (tt = 0; tt < 8; tt++) X.push(new Uint8Array(st));
      for (var dt = 0; dt < ot; dt++) {
        K(rt.blocks[lt][dt], ct, at);
        var ht = 0, pt = dt << 3;
        for (V = 0; V < 8; V++) {
          var Ct = X[vt + V];
          for (tt = 0; tt < 8; tt++) Ct[pt + tt] = ct[ht++];
        }
      }
    }
    return X;
  }
  function Q(et) {
    return et < 0 ? 0 : et > 255 ? 255 : et;
  }
  Z.prototype = { load: function(et) {
    var rt = new XMLHttpRequest();
    rt.open("GET", et, !0), rt.responseType = "arraybuffer", rt.onload = (function() {
      var tt = new Uint8Array(rt.response || rt.mozResponseArrayBuffer);
      this.parse(tt), this.onload && this.onload();
    }).bind(this), rt.send(null);
  }, parse: function(et) {
    var rt = 1e3 * this.opts.maxResolutionInMP * 1e3, tt = 0;
    function V() {
      var Vt = et[tt] << 8 | et[tt + 1];
      return tt += 2, Vt;
    }
    function X(Vt) {
      var ee, Jt, le = 1, ae = 1;
      for (Jt in Vt.components) Vt.components.hasOwnProperty(Jt) && (le < (ee = Vt.components[Jt]).h && (le = ee.h), ae < ee.v && (ae = ee.v));
      var se = Math.ceil(Vt.samplesPerLine / 8 / le), fe = Math.ceil(Vt.scanLines / 8 / ae);
      for (Jt in Vt.components) if (Vt.components.hasOwnProperty(Jt)) {
        ee = Vt.components[Jt];
        var ne = Math.ceil(Math.ceil(Vt.samplesPerLine / 8) * ee.h / le), Nt = Math.ceil(Math.ceil(Vt.scanLines / 8) * ee.v / ae), Xt = se * ee.h, Ut = fe * ee.v, Wt = [];
        q(Ut * Xt * 256);
        for (var Et = 0; Et < Ut; Et++) {
          for (var Yt = [], ce = 0; ce < Xt; ce++) Yt.push(new Int32Array(64));
          Wt.push(Yt);
        }
        ee.blocksPerLine = ne, ee.blocksPerColumn = Nt, ee.blocks = Wt;
      }
      Vt.maxH = le, Vt.maxV = ae, Vt.mcusPerLine = se, Vt.mcusPerColumn = fe;
    }
    et.length;
    var ot, it, st, at, ct = null, K = null, lt = [], vt = [], dt = [], ht = [], pt = V(), Ct = -1;
    if (this.comments = [], pt != 65496) throw new Error("SOI not found");
    for (pt = V(); pt != 65497; ) {
      switch (pt) {
        case 65280:
          break;
        case 65504:
        case 65505:
        case 65506:
        case 65507:
        case 65508:
        case 65509:
        case 65510:
        case 65511:
        case 65512:
        case 65513:
        case 65514:
        case 65515:
        case 65516:
        case 65517:
        case 65518:
        case 65519:
        case 65534:
          var St = (st = void 0, at = void 0, st = V(), at = et.subarray(tt, tt + st - 2), tt += at.length, at);
          if (pt === 65534) {
            var At = String.fromCharCode.apply(null, St);
            this.comments.push(At);
          }
          pt === 65504 && St[0] === 74 && St[1] === 70 && St[2] === 73 && St[3] === 70 && St[4] === 0 && (ct = { version: { major: St[5], minor: St[6] }, densityUnits: St[7], xDensity: St[8] << 8 | St[9], yDensity: St[10] << 8 | St[11], thumbWidth: St[12], thumbHeight: St[13], thumbData: St.subarray(14, 14 + 3 * St[12] * St[13]) }), pt === 65505 && St[0] === 69 && St[1] === 120 && St[2] === 105 && St[3] === 102 && St[4] === 0 && (this.exifBuffer = St.subarray(5, St.length)), pt === 65518 && St[0] === 65 && St[1] === 100 && St[2] === 111 && St[3] === 98 && St[4] === 101 && St[5] === 0 && (K = { version: St[6], flags0: St[7] << 8 | St[8], flags1: St[9] << 8 | St[10], transformCode: St[11] });
          break;
        case 65499:
          for (var Ft = V() + tt - 2; tt < Ft; ) {
            var xt = et[tt++];
            q(256);
            var Pt = new Int32Array(64);
            if (xt >> 4) {
              if (xt >> 4 != 1) throw new Error("DQT: invalid table spec");
              for (Kt = 0; Kt < 64; Kt++) Pt[d[Kt]] = V();
            } else for (Kt = 0; Kt < 64; Kt++) Pt[d[Kt]] = et[tt++];
            lt[15 & xt] = Pt;
          }
          break;
        case 65472:
        case 65473:
        case 65474:
          V(), (ot = {}).extended = pt === 65473, ot.progressive = pt === 65474, ot.precision = et[tt++], ot.scanLines = V(), ot.samplesPerLine = V(), ot.components = {}, ot.componentsOrder = [];
          var Ot = ot.scanLines * ot.samplesPerLine;
          if (Ot > rt) {
            var Bt = Math.ceil((Ot - rt) / 1e6);
            throw new Error(`maxResolutionInMP limit exceeded by ${Bt}MP`);
          }
          var kt, Tt = et[tt++];
          for (Lt = 0; Lt < Tt; Lt++) {
            kt = et[tt];
            var Dt = et[tt + 1] >> 4, Zt = 15 & et[tt + 1], $t = et[tt + 2];
            if (Dt <= 0 || Zt <= 0) throw new Error("Invalid sampling factor, expected values above 0");
            ot.componentsOrder.push(kt), ot.components[kt] = { h: Dt, v: Zt, quantizationIdx: $t }, tt += 3;
          }
          X(ot), vt.push(ot);
          break;
        case 65476:
          var Mt = V();
          for (Lt = 2; Lt < Mt; ) {
            var nt = et[tt++], It = new Uint8Array(16), mt = 0;
            for (Kt = 0; Kt < 16; Kt++, tt++) mt += It[Kt] = et[tt];
            q(16 + mt);
            var gt = new Uint8Array(mt);
            for (Kt = 0; Kt < mt; Kt++, tt++) gt[Kt] = et[tt];
            Lt += 17 + mt, (nt >> 4 ? dt : ht)[15 & nt] = $(It, gt);
          }
          break;
        case 65501:
          V(), it = V();
          break;
        case 65500:
          V(), V();
          break;
        case 65498:
          V();
          var _t = et[tt++], wt = [];
          for (Lt = 0; Lt < _t; Lt++) {
            te = ot.components[et[tt++]];
            var Rt = et[tt++];
            te.huffmanTableDC = ht[Rt >> 4], te.huffmanTableAC = dt[15 & Rt], wt.push(te);
          }
          var J = et[tt++], ut = et[tt++], bt = et[tt++], yt = j(et, tt, ot, wt, it, J, ut, bt >> 4, 15 & bt, this.opts);
          tt += yt;
          break;
        case 65535:
          et[tt] !== 255 && tt--;
          break;
        default:
          if (et[tt - 3] == 255 && et[tt - 2] >= 192 && et[tt - 2] <= 254) {
            tt -= 3;
            break;
          }
          if (pt === 224 || pt == 225) {
            if (Ct !== -1) throw new Error(`first unknown JPEG marker at offset ${Ct.toString(16)}, second unknown JPEG marker ${pt.toString(16)} at offset ${(tt - 1).toString(16)}`);
            Ct = tt - 1;
            const Vt = V();
            if (et[tt + Vt - 2] === 255) {
              tt += Vt - 2;
              break;
            }
          }
          throw new Error("unknown JPEG marker " + pt.toString(16));
      }
      pt = V();
    }
    if (vt.length != 1) throw new Error("only single frame JPEGs supported");
    for (var Lt = 0; Lt < vt.length; Lt++) {
      var jt = vt[Lt].components;
      for (var Kt in jt) jt[Kt].quantizationTable = lt[jt[Kt].quantizationIdx], delete jt[Kt].quantizationIdx;
    }
    for (this.width = ot.samplesPerLine, this.height = ot.scanLines, this.jfif = ct, this.adobe = K, this.components = [], Lt = 0; Lt < ot.componentsOrder.length; Lt++) {
      var te = ot.components[ot.componentsOrder[Lt]];
      this.components.push({ lines: G(0, te), scaleX: te.h / ot.maxH, scaleY: te.v / ot.maxV });
    }
  }, getData: function(et, rt) {
    var tt, V, X, ot, it, st, at, ct, K, lt, vt, dt, ht, pt, Ct, St, At, Ft, xt, Pt, Ot, Bt = this.width / et, kt = this.height / rt, Tt = 0, Dt = et * rt * this.components.length;
    q(Dt);
    var Zt = new Uint8Array(Dt);
    switch (this.components.length) {
      case 1:
        for (tt = this.components[0], lt = 0; lt < rt; lt++) for (it = tt.lines[0 | lt * tt.scaleY * kt], K = 0; K < et; K++) vt = it[0 | K * tt.scaleX * Bt], Zt[Tt++] = vt;
        break;
      case 2:
        for (tt = this.components[0], V = this.components[1], lt = 0; lt < rt; lt++) for (it = tt.lines[0 | lt * tt.scaleY * kt], st = V.lines[0 | lt * V.scaleY * kt], K = 0; K < et; K++) vt = it[0 | K * tt.scaleX * Bt], Zt[Tt++] = vt, vt = st[0 | K * V.scaleX * Bt], Zt[Tt++] = vt;
        break;
      case 3:
        for (Ot = !0, this.adobe && this.adobe.transformCode ? Ot = !0 : this.opts.colorTransform !== void 0 && (Ot = !!this.opts.colorTransform), tt = this.components[0], V = this.components[1], X = this.components[2], lt = 0; lt < rt; lt++) for (it = tt.lines[0 | lt * tt.scaleY * kt], st = V.lines[0 | lt * V.scaleY * kt], at = X.lines[0 | lt * X.scaleY * kt], K = 0; K < et; K++) Ot ? (vt = it[0 | K * tt.scaleX * Bt], dt = st[0 | K * V.scaleX * Bt], Ft = Q(vt + 1.402 * ((ht = at[0 | K * X.scaleX * Bt]) - 128)), xt = Q(vt - 0.3441363 * (dt - 128) - 0.71413636 * (ht - 128)), Pt = Q(vt + 1.772 * (dt - 128))) : (Ft = it[0 | K * tt.scaleX * Bt], xt = st[0 | K * V.scaleX * Bt], Pt = at[0 | K * X.scaleX * Bt]), Zt[Tt++] = Ft, Zt[Tt++] = xt, Zt[Tt++] = Pt;
        break;
      case 4:
        if (!this.adobe) throw new Error("Unsupported color mode (4 components)");
        for (Ot = !1, this.adobe && this.adobe.transformCode ? Ot = !0 : this.opts.colorTransform !== void 0 && (Ot = !!this.opts.colorTransform), tt = this.components[0], V = this.components[1], X = this.components[2], ot = this.components[3], lt = 0; lt < rt; lt++) for (it = tt.lines[0 | lt * tt.scaleY * kt], st = V.lines[0 | lt * V.scaleY * kt], at = X.lines[0 | lt * X.scaleY * kt], ct = ot.lines[0 | lt * ot.scaleY * kt], K = 0; K < et; K++) Ot ? (vt = it[0 | K * tt.scaleX * Bt], dt = st[0 | K * V.scaleX * Bt], ht = at[0 | K * X.scaleX * Bt], pt = ct[0 | K * ot.scaleX * Bt], Ct = 255 - Q(vt + 1.402 * (ht - 128)), St = 255 - Q(vt - 0.3441363 * (dt - 128) - 0.71413636 * (ht - 128)), At = 255 - Q(vt + 1.772 * (dt - 128))) : (Ct = it[0 | K * tt.scaleX * Bt], St = st[0 | K * V.scaleX * Bt], At = at[0 | K * X.scaleX * Bt], pt = ct[0 | K * ot.scaleX * Bt]), Zt[Tt++] = 255 - Ct, Zt[Tt++] = 255 - St, Zt[Tt++] = 255 - At, Zt[Tt++] = 255 - pt;
        break;
      default:
        throw new Error("Unsupported color mode");
    }
    return Zt;
  }, copyToImageData: function(et, rt) {
    var tt, V, X, ot, it, st, at, ct, K, lt = et.width, vt = et.height, dt = et.data, ht = this.getData(lt, vt), pt = 0, Ct = 0;
    switch (this.components.length) {
      case 1:
        for (V = 0; V < vt; V++) for (tt = 0; tt < lt; tt++) X = ht[pt++], dt[Ct++] = X, dt[Ct++] = X, dt[Ct++] = X, rt && (dt[Ct++] = 255);
        break;
      case 3:
        for (V = 0; V < vt; V++) for (tt = 0; tt < lt; tt++) at = ht[pt++], ct = ht[pt++], K = ht[pt++], dt[Ct++] = at, dt[Ct++] = ct, dt[Ct++] = K, rt && (dt[Ct++] = 255);
        break;
      case 4:
        for (V = 0; V < vt; V++) for (tt = 0; tt < lt; tt++) it = ht[pt++], st = ht[pt++], X = ht[pt++], at = 255 - Q(it * (1 - (ot = ht[pt++]) / 255) + ot), ct = 255 - Q(st * (1 - ot / 255) + ot), K = 255 - Q(X * (1 - ot / 255) + ot), dt[Ct++] = at, dt[Ct++] = ct, dt[Ct++] = K, rt && (dt[Ct++] = 255);
        break;
      default:
        throw new Error("Unsupported color mode");
    }
  } };
  var H = 0, W = 0;
  function q(et = 0) {
    var rt = H + et;
    if (rt > W) {
      var tt = Math.ceil((rt - W) / 1024 / 1024);
      throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${tt}MB`);
    }
    H = rt;
  }
  return Z.resetMaxMemoryUsage = function(et) {
    H = 0, W = et;
  }, Z.getBytesAllocated = function() {
    return H;
  }, Z.requestMemoryAllocation = q, Z;
}(), module.exports = function(d, m = {}) {
  var g = { colorTransform: void 0, useTArray: !1, formatAsRGBA: !0, tolerantDecoding: !0, maxResolutionInMP: 100, maxMemoryUsageInMB: 512, ...m }, w = new Uint8Array(d), I = new JpegImage();
  I.opts = g, JpegImage.resetMaxMemoryUsage(1024 * g.maxMemoryUsageInMB * 1024), I.parse(w);
  var P = g.formatAsRGBA ? 4 : 3, F = I.width * I.height * P;
  try {
    JpegImage.requestMemoryAllocation(F);
    var D = { width: I.width, height: I.height, exifBuffer: I.exifBuffer, data: g.useTArray ? new Uint8Array(F) : Buffer.alloc(F) };
    I.comments.length > 0 && (D.comments = I.comments);
  } catch (U) {
    throw U instanceof RangeError ? new Error("Could not allocate enough memory for the image. Required: " + F) : U instanceof ReferenceError && U.message === "Buffer is not defined" ? new Error("Buffer is not globally defined in this environment. Consider setting useTArray to true") : U;
  }
  return I.copyToImageData(D, g.formatAsRGBA), D;
};
var decoderExports = decoder.exports, encode = encoderExports, decode = decoderExports, jpegJs = { encode, decode }, JPEG = getDefaultExportFromCjs(jpegJs);
function jpeg$2() {
  return { mime: "image/jpeg", encode: (d, { quality: m = 100 } = {}) => JPEG.encode(d, m).data, decode: (d, m) => JPEG.decode(d, m) };
}
function commonjsRequire(d) {
  throw new Error('Could not dynamically require "' + d + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var browser$1 = { exports: {} };
browser$1.exports = (/* @__PURE__ */ function() {
  function d(m, g, w) {
    function I(D, U) {
      if (!g[D]) {
        if (!m[D]) {
          var Z = typeof commonjsRequire == "function" && commonjsRequire;
          if (!U && Z) return Z(D, !0);
          if (P) return P(D, !0);
          var $ = new Error("Cannot find module '" + D + "'");
          throw $.code = "MODULE_NOT_FOUND", $;
        }
        var j = g[D] = { exports: {} };
        m[D][0].call(j.exports, function(G) {
          return I(m[D][1][G] || G);
        }, j, j.exports, d, m, g, w);
      }
      return g[D].exports;
    }
    for (var P = typeof commonjsRequire == "function" && commonjsRequire, F = 0; F < w.length; F++) I(w[F]);
    return I;
  }
  return d;
}())({ 1: [function(d, m, g) {
  (function(w) {
    (function() {
      let I = d("./interlace"), P = [function() {
      }, function($, j, G, Q) {
        if (Q === j.length) throw new Error("Ran out of data");
        let H = j[Q];
        $[G] = H, $[G + 1] = H, $[G + 2] = H, $[G + 3] = 255;
      }, function($, j, G, Q) {
        if (Q + 1 >= j.length) throw new Error("Ran out of data");
        let H = j[Q];
        $[G] = H, $[G + 1] = H, $[G + 2] = H, $[G + 3] = j[Q + 1];
      }, function($, j, G, Q) {
        if (Q + 2 >= j.length) throw new Error("Ran out of data");
        $[G] = j[Q], $[G + 1] = j[Q + 1], $[G + 2] = j[Q + 2], $[G + 3] = 255;
      }, function($, j, G, Q) {
        if (Q + 3 >= j.length) throw new Error("Ran out of data");
        $[G] = j[Q], $[G + 1] = j[Q + 1], $[G + 2] = j[Q + 2], $[G + 3] = j[Q + 3];
      }], F = [function() {
      }, function($, j, G, Q) {
        let H = j[0];
        $[G] = H, $[G + 1] = H, $[G + 2] = H, $[G + 3] = Q;
      }, function($, j, G) {
        let Q = j[0];
        $[G] = Q, $[G + 1] = Q, $[G + 2] = Q, $[G + 3] = j[1];
      }, function($, j, G, Q) {
        $[G] = j[0], $[G + 1] = j[1], $[G + 2] = j[2], $[G + 3] = Q;
      }, function($, j, G) {
        $[G] = j[0], $[G + 1] = j[1], $[G + 2] = j[2], $[G + 3] = j[3];
      }];
      function D($, j) {
        let G = [], Q = 0;
        function H() {
          if (Q === $.length) throw new Error("Ran out of data");
          let W, q, et, rt, tt, V, X, ot, it = $[Q];
          switch (Q++, j) {
            default:
              throw new Error("unrecognised depth");
            case 16:
              X = $[Q], Q++, G.push((it << 8) + X);
              break;
            case 4:
              X = 15 & it, ot = it >> 4, G.push(ot, X);
              break;
            case 2:
              tt = 3 & it, V = it >> 2 & 3, X = it >> 4 & 3, ot = it >> 6 & 3, G.push(ot, X, V, tt);
              break;
            case 1:
              W = 1 & it, q = it >> 1 & 1, et = it >> 2 & 1, rt = it >> 3 & 1, tt = it >> 4 & 1, V = it >> 5 & 1, X = it >> 6 & 1, ot = it >> 7 & 1, G.push(ot, X, V, tt, rt, et, q, W);
          }
        }
        return { get: function(W) {
          for (; G.length < W; ) H();
          let q = G.slice(0, W);
          return G = G.slice(W), q;
        }, resetAfterLine: function() {
          G.length = 0;
        }, end: function() {
          if (Q !== $.length) throw new Error("extra data found");
        } };
      }
      function U($, j, G, Q, H, W) {
        let q = $.width, et = $.height, rt = $.index;
        for (let tt = 0; tt < et; tt++) for (let V = 0; V < q; V++) {
          let X = G(V, tt, rt);
          P[Q](j, H, X, W), W += Q;
        }
        return W;
      }
      function Z($, j, G, Q, H, W) {
        let q = $.width, et = $.height, rt = $.index;
        for (let tt = 0; tt < et; tt++) {
          for (let V = 0; V < q; V++) {
            let X = H.get(Q), ot = G(V, tt, rt);
            F[Q](j, X, ot, W);
          }
          H.resetAfterLine();
        }
      }
      g.dataToBitMap = function($, j) {
        let G, Q, H = j.width, W = j.height, q = j.depth, et = j.bpp, rt = j.interlace;
        q !== 8 && (G = D($, q)), Q = q <= 8 ? w.alloc(H * W * 4) : new Uint16Array(H * W * 4);
        let tt, V, X = Math.pow(2, q) - 1, ot = 0;
        if (rt) tt = I.getImagePasses(H, W), V = I.getInterlaceIterator(H, W);
        else {
          let it = 0;
          V = function() {
            let st = it;
            return it += 4, st;
          }, tt = [{ width: H, height: W }];
        }
        for (let it = 0; it < tt.length; it++) q === 8 ? ot = U(tt[it], Q, V, et, $, ot) : Z(tt[it], Q, V, et, G, X);
        if (q === 8) {
          if (ot !== $.length) throw new Error("extra data found");
        } else G.end();
        return Q;
      };
    }).call(this);
  }).call(this, d("buffer").Buffer);
}, { "./interlace": 11, buffer: 32 }], 2: [function(d, m, g) {
  (function(w) {
    (function() {
      let I = d("./constants");
      m.exports = function(P, F, D, U) {
        let Z = [I.COLORTYPE_COLOR_ALPHA, I.COLORTYPE_ALPHA].indexOf(U.colorType) !== -1;
        if (U.colorType === U.inputColorType) {
          let tt = function() {
            let V = new ArrayBuffer(2);
            return new DataView(V).setInt16(0, 256, !0), new Int16Array(V)[0] !== 256;
          }();
          if (U.bitDepth === 8 || U.bitDepth === 16 && tt) return P;
        }
        let $ = U.bitDepth !== 16 ? P : new Uint16Array(P.buffer), j = 255, G = I.COLORTYPE_TO_BPP_MAP[U.inputColorType];
        G !== 4 || U.inputHasAlpha || (G = 3);
        let Q = I.COLORTYPE_TO_BPP_MAP[U.colorType];
        U.bitDepth === 16 && (j = 65535, Q *= 2);
        let H = w.alloc(F * D * Q), W = 0, q = 0, et = U.bgColor || {};
        function rt() {
          let tt, V, X, ot = j;
          switch (U.inputColorType) {
            case I.COLORTYPE_COLOR_ALPHA:
              ot = $[W + 3], tt = $[W], V = $[W + 1], X = $[W + 2];
              break;
            case I.COLORTYPE_COLOR:
              tt = $[W], V = $[W + 1], X = $[W + 2];
              break;
            case I.COLORTYPE_ALPHA:
              ot = $[W + 1], tt = $[W], V = tt, X = tt;
              break;
            case I.COLORTYPE_GRAYSCALE:
              tt = $[W], V = tt, X = tt;
              break;
            default:
              throw new Error("input color type:" + U.inputColorType + " is not supported at present");
          }
          return U.inputHasAlpha && (Z || (ot /= j, tt = Math.min(Math.max(Math.round((1 - ot) * et.red + ot * tt), 0), j), V = Math.min(Math.max(Math.round((1 - ot) * et.green + ot * V), 0), j), X = Math.min(Math.max(Math.round((1 - ot) * et.blue + ot * X), 0), j))), { red: tt, green: V, blue: X, alpha: ot };
        }
        et.red === void 0 && (et.red = j), et.green === void 0 && (et.green = j), et.blue === void 0 && (et.blue = j);
        for (let tt = 0; tt < D; tt++) for (let V = 0; V < F; V++) {
          let X = rt();
          switch (U.colorType) {
            case I.COLORTYPE_COLOR_ALPHA:
            case I.COLORTYPE_COLOR:
              U.bitDepth === 8 ? (H[q] = X.red, H[q + 1] = X.green, H[q + 2] = X.blue, Z && (H[q + 3] = X.alpha)) : (H.writeUInt16BE(X.red, q), H.writeUInt16BE(X.green, q + 2), H.writeUInt16BE(X.blue, q + 4), Z && H.writeUInt16BE(X.alpha, q + 6));
              break;
            case I.COLORTYPE_ALPHA:
            case I.COLORTYPE_GRAYSCALE: {
              let ot = (X.red + X.green + X.blue) / 3;
              U.bitDepth === 8 ? (H[q] = ot, Z && (H[q + 1] = X.alpha)) : (H.writeUInt16BE(ot, q), Z && H.writeUInt16BE(X.alpha, q + 2));
              break;
            }
            default:
              throw new Error("unrecognised color Type " + U.colorType);
          }
          W += G, q += Q;
        }
        return H;
      };
    }).call(this);
  }).call(this, d("buffer").Buffer);
}, { "./constants": 4, buffer: 32 }], 3: [function(d, m, g) {
  (function(w, I) {
    (function() {
      let P = d("util"), F = d("stream"), D = m.exports = function() {
        F.call(this), this._buffers = [], this._buffered = 0, this._reads = [], this._paused = !1, this._encoding = "utf8", this.writable = !0;
      };
      P.inherits(D, F), D.prototype.read = function(U, Z) {
        this._reads.push({ length: Math.abs(U), allowLess: U < 0, func: Z }), w.nextTick((function() {
          this._process(), this._paused && this._reads && this._reads.length > 0 && (this._paused = !1, this.emit("drain"));
        }).bind(this));
      }, D.prototype.write = function(U, Z) {
        if (!this.writable) return this.emit("error", new Error("Stream not writable")), !1;
        let $;
        return $ = I.isBuffer(U) ? U : I.from(U, Z || this._encoding), this._buffers.push($), this._buffered += $.length, this._process(), this._reads && this._reads.length === 0 && (this._paused = !0), this.writable && !this._paused;
      }, D.prototype.end = function(U, Z) {
        U && this.write(U, Z), this.writable = !1, this._buffers && (this._buffers.length === 0 ? this._end() : (this._buffers.push(null), this._process()));
      }, D.prototype.destroySoon = D.prototype.end, D.prototype._end = function() {
        this._reads.length > 0 && this.emit("error", new Error("Unexpected end of input")), this.destroy();
      }, D.prototype.destroy = function() {
        this._buffers && (this.writable = !1, this._reads = null, this._buffers = null, this.emit("close"));
      }, D.prototype._processReadAllowingLess = function(U) {
        this._reads.shift();
        let Z = this._buffers[0];
        Z.length > U.length ? (this._buffered -= U.length, this._buffers[0] = Z.slice(U.length), U.func.call(this, Z.slice(0, U.length))) : (this._buffered -= Z.length, this._buffers.shift(), U.func.call(this, Z));
      }, D.prototype._processRead = function(U) {
        this._reads.shift();
        let Z = 0, $ = 0, j = I.alloc(U.length);
        for (; Z < U.length; ) {
          let G = this._buffers[$++], Q = Math.min(G.length, U.length - Z);
          G.copy(j, Z, 0, Q), Z += Q, Q !== G.length && (this._buffers[--$] = G.slice(Q));
        }
        $ > 0 && this._buffers.splice(0, $), this._buffered -= U.length, U.func.call(this, j);
      }, D.prototype._process = function() {
        try {
          for (; this._buffered > 0 && this._reads && this._reads.length > 0; ) {
            let U = this._reads[0];
            if (U.allowLess) this._processReadAllowingLess(U);
            else {
              if (!(this._buffered >= U.length)) break;
              this._processRead(U);
            }
          }
          this._buffers && !this.writable && this._end();
        } catch (U) {
          this.emit("error", U);
        }
      };
    }).call(this);
  }).call(this, d("_process"), d("buffer").Buffer);
}, { _process: 63, buffer: 32, stream: 65, util: 84 }], 4: [function(d, m, g) {
  m.exports = { PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10], TYPE_IHDR: 1229472850, TYPE_IEND: 1229278788, TYPE_IDAT: 1229209940, TYPE_PLTE: 1347179589, TYPE_tRNS: 1951551059, TYPE_gAMA: 1732332865, COLORTYPE_GRAYSCALE: 0, COLORTYPE_PALETTE: 1, COLORTYPE_COLOR: 2, COLORTYPE_ALPHA: 4, COLORTYPE_PALETTE_COLOR: 3, COLORTYPE_COLOR_ALPHA: 6, COLORTYPE_TO_BPP_MAP: { 0: 1, 2: 3, 3: 1, 4: 2, 6: 4 }, GAMMA_DIVISION: 1e5 };
}, {}], 5: [function(d, m, g) {
  let w = [];
  (function() {
    for (let P = 0; P < 256; P++) {
      let F = P;
      for (let D = 0; D < 8; D++) 1 & F ? F = 3988292384 ^ F >>> 1 : F >>>= 1;
      w[P] = F;
    }
  })();
  let I = m.exports = function() {
    this._crc = -1;
  };
  I.prototype.write = function(P) {
    for (let F = 0; F < P.length; F++) this._crc = w[255 & (this._crc ^ P[F])] ^ this._crc >>> 8;
    return !0;
  }, I.prototype.crc32 = function() {
    return ~this._crc;
  }, I.crc32 = function(P) {
    let F = -1;
    for (let D = 0; D < P.length; D++) F = w[255 & (F ^ P[D])] ^ F >>> 8;
    return ~F;
  };
}, {}], 6: [function(d, m, g) {
  (function(w) {
    (function() {
      let I = d("./paeth-predictor");
      function P(et, rt, tt, V, X) {
        for (let ot = 0; ot < tt; ot++) V[X + ot] = et[rt + ot];
      }
      function F(et, rt, tt) {
        let V = 0, X = rt + tt;
        for (let ot = rt; ot < X; ot++) V += Math.abs(et[ot]);
        return V;
      }
      function D(et, rt, tt, V, X, ot) {
        for (let it = 0; it < tt; it++) {
          let st = it >= ot ? et[rt + it - ot] : 0, at = et[rt + it] - st;
          V[X + it] = at;
        }
      }
      function U(et, rt, tt, V) {
        let X = 0;
        for (let ot = 0; ot < tt; ot++) {
          let it = ot >= V ? et[rt + ot - V] : 0, st = et[rt + ot] - it;
          X += Math.abs(st);
        }
        return X;
      }
      function Z(et, rt, tt, V, X) {
        for (let ot = 0; ot < tt; ot++) {
          let it = rt > 0 ? et[rt + ot - tt] : 0, st = et[rt + ot] - it;
          V[X + ot] = st;
        }
      }
      function $(et, rt, tt) {
        let V = 0, X = rt + tt;
        for (let ot = rt; ot < X; ot++) {
          let it = rt > 0 ? et[ot - tt] : 0, st = et[ot] - it;
          V += Math.abs(st);
        }
        return V;
      }
      function j(et, rt, tt, V, X, ot) {
        for (let it = 0; it < tt; it++) {
          let st = it >= ot ? et[rt + it - ot] : 0, at = rt > 0 ? et[rt + it - tt] : 0, ct = et[rt + it] - (st + at >> 1);
          V[X + it] = ct;
        }
      }
      function G(et, rt, tt, V) {
        let X = 0;
        for (let ot = 0; ot < tt; ot++) {
          let it = ot >= V ? et[rt + ot - V] : 0, st = rt > 0 ? et[rt + ot - tt] : 0, at = et[rt + ot] - (it + st >> 1);
          X += Math.abs(at);
        }
        return X;
      }
      function Q(et, rt, tt, V, X, ot) {
        for (let it = 0; it < tt; it++) {
          let st = it >= ot ? et[rt + it - ot] : 0, at = rt > 0 ? et[rt + it - tt] : 0, ct = rt > 0 && it >= ot ? et[rt + it - (tt + ot)] : 0, K = et[rt + it] - I(st, at, ct);
          V[X + it] = K;
        }
      }
      function H(et, rt, tt, V) {
        let X = 0;
        for (let ot = 0; ot < tt; ot++) {
          let it = ot >= V ? et[rt + ot - V] : 0, st = rt > 0 ? et[rt + ot - tt] : 0, at = rt > 0 && ot >= V ? et[rt + ot - (tt + V)] : 0, ct = et[rt + ot] - I(it, st, at);
          X += Math.abs(ct);
        }
        return X;
      }
      let W = { 0: P, 1: D, 2: Z, 3: j, 4: Q }, q = { 0: F, 1: U, 2: $, 3: G, 4: H };
      m.exports = function(et, rt, tt, V, X) {
        let ot;
        if ("filterType" in V && V.filterType !== -1) {
          if (typeof V.filterType != "number") throw new Error("unrecognised filter types");
          ot = [V.filterType];
        } else ot = [0, 1, 2, 3, 4];
        V.bitDepth === 16 && (X *= 2);
        let it = rt * X, st = 0, at = 0, ct = w.alloc((it + 1) * tt), K = ot[0];
        for (let lt = 0; lt < tt; lt++) {
          if (ot.length > 1) {
            let vt = 1 / 0;
            for (let dt = 0; dt < ot.length; dt++) {
              let ht = q[ot[dt]](et, at, it, X);
              ht < vt && (K = ot[dt], vt = ht);
            }
          }
          ct[st] = K, st++, W[K](et, at, it, ct, st, X), st += it, at += it;
        }
        return ct;
      };
    }).call(this);
  }).call(this, d("buffer").Buffer);
}, { "./paeth-predictor": 15, buffer: 32 }], 7: [function(d, m, g) {
  (function(w) {
    (function() {
      let I = d("util"), P = d("./chunkstream"), F = d("./filter-parse"), D = m.exports = function(U) {
        P.call(this);
        let Z = [], $ = this;
        this._filter = new F(U, { read: this.read.bind(this), write: function(j) {
          Z.push(j);
        }, complete: function() {
          $.emit("complete", w.concat(Z));
        } }), this._filter.start();
      };
      I.inherits(D, P);
    }).call(this);
  }).call(this, d("buffer").Buffer);
}, { "./chunkstream": 3, "./filter-parse": 9, buffer: 32, util: 84 }], 8: [function(d, m, g) {
  (function(w) {
    (function() {
      let I = d("./sync-reader"), P = d("./filter-parse");
      g.process = function(F, D) {
        let U = [], Z = new I(F);
        return new P(D, { read: Z.read.bind(Z), write: function($) {
          U.push($);
        }, complete: function() {
        } }).start(), Z.process(), w.concat(U);
      };
    }).call(this);
  }).call(this, d("buffer").Buffer);
}, { "./filter-parse": 9, "./sync-reader": 22, buffer: 32 }], 9: [function(d, m, g) {
  (function(w) {
    (function() {
      let I = d("./interlace"), P = d("./paeth-predictor");
      function F(U, Z, $) {
        let j = U * Z;
        return $ !== 8 && (j = Math.ceil(j / (8 / $))), j;
      }
      let D = m.exports = function(U, Z) {
        let $ = U.width, j = U.height, G = U.interlace, Q = U.bpp, H = U.depth;
        if (this.read = Z.read, this.write = Z.write, this.complete = Z.complete, this._imageIndex = 0, this._images = [], G) {
          let W = I.getImagePasses($, j);
          for (let q = 0; q < W.length; q++) this._images.push({ byteWidth: F(W[q].width, Q, H), height: W[q].height, lineIndex: 0 });
        } else this._images.push({ byteWidth: F($, Q, H), height: j, lineIndex: 0 });
        this._xComparison = H === 8 ? Q : H === 16 ? 2 * Q : 1;
      };
      D.prototype.start = function() {
        this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
      }, D.prototype._unFilterType1 = function(U, Z, $) {
        let j = this._xComparison, G = j - 1;
        for (let Q = 0; Q < $; Q++) {
          let H = U[1 + Q], W = Q > G ? Z[Q - j] : 0;
          Z[Q] = H + W;
        }
      }, D.prototype._unFilterType2 = function(U, Z, $) {
        let j = this._lastLine;
        for (let G = 0; G < $; G++) {
          let Q = U[1 + G], H = j ? j[G] : 0;
          Z[G] = Q + H;
        }
      }, D.prototype._unFilterType3 = function(U, Z, $) {
        let j = this._xComparison, G = j - 1, Q = this._lastLine;
        for (let H = 0; H < $; H++) {
          let W = U[1 + H], q = Q ? Q[H] : 0, et = H > G ? Z[H - j] : 0, rt = Math.floor((et + q) / 2);
          Z[H] = W + rt;
        }
      }, D.prototype._unFilterType4 = function(U, Z, $) {
        let j = this._xComparison, G = j - 1, Q = this._lastLine;
        for (let H = 0; H < $; H++) {
          let W = U[1 + H], q = Q ? Q[H] : 0, et = H > G ? Z[H - j] : 0, rt = H > G && Q ? Q[H - j] : 0, tt = P(et, q, rt);
          Z[H] = W + tt;
        }
      }, D.prototype._reverseFilterLine = function(U) {
        let Z, $ = U[0], j = this._images[this._imageIndex], G = j.byteWidth;
        if ($ === 0) Z = U.slice(1, G + 1);
        else switch (Z = w.alloc(G), $) {
          case 1:
            this._unFilterType1(U, Z, G);
            break;
          case 2:
            this._unFilterType2(U, Z, G);
            break;
          case 3:
            this._unFilterType3(U, Z, G);
            break;
          case 4:
            this._unFilterType4(U, Z, G);
            break;
          default:
            throw new Error("Unrecognised filter type - " + $);
        }
        this.write(Z), j.lineIndex++, j.lineIndex >= j.height ? (this._lastLine = null, this._imageIndex++, j = this._images[this._imageIndex]) : this._lastLine = Z, j ? this.read(j.byteWidth + 1, this._reverseFilterLine.bind(this)) : (this._lastLine = null, this.complete());
      };
    }).call(this);
  }).call(this, d("buffer").Buffer);
}, { "./interlace": 11, "./paeth-predictor": 15, buffer: 32 }], 10: [function(d, m, g) {
  (function(w) {
    (function() {
      function I(D, U, Z, $, j) {
        let G = 0;
        for (let Q = 0; Q < $; Q++) for (let H = 0; H < Z; H++) {
          let W = j[D[G]];
          if (!W) throw new Error("index " + D[G] + " not in palette");
          for (let q = 0; q < 4; q++) U[G + q] = W[q];
          G += 4;
        }
      }
      function P(D, U, Z, $, j) {
        let G = 0;
        for (let Q = 0; Q < $; Q++) for (let H = 0; H < Z; H++) {
          let W = !1;
          if (j.length === 1 ? j[0] === D[G] && (W = !0) : j[0] === D[G] && j[1] === D[G + 1] && j[2] === D[G + 2] && (W = !0), W) for (let q = 0; q < 4; q++) U[G + q] = 0;
          G += 4;
        }
      }
      function F(D, U, Z, $, j) {
        let G = 255, Q = Math.pow(2, j) - 1, H = 0;
        for (let W = 0; W < $; W++) for (let q = 0; q < Z; q++) {
          for (let et = 0; et < 4; et++) U[H + et] = Math.floor(D[H + et] * G / Q + 0.5);
          H += 4;
        }
      }
      m.exports = function(D, U, Z = !1) {
        let $ = U.depth, j = U.width, G = U.height, Q = U.colorType, H = U.transColor, W = U.palette, q = D;
        return Q === 3 ? I(D, q, j, G, W) : (H && P(D, q, j, G, H), $ === 8 || Z || ($ === 16 && (q = w.alloc(j * G * 4)), F(D, q, j, G, $))), q;
      };
    }).call(this);
  }).call(this, d("buffer").Buffer);
}, { buffer: 32 }], 11: [function(d, m, g) {
  let w = [{ x: [0], y: [0] }, { x: [4], y: [0] }, { x: [0, 4], y: [4] }, { x: [2, 6], y: [0, 4] }, { x: [0, 2, 4, 6], y: [2, 6] }, { x: [1, 3, 5, 7], y: [0, 2, 4, 6] }, { x: [0, 1, 2, 3, 4, 5, 6, 7], y: [1, 3, 5, 7] }];
  g.getImagePasses = function(I, P) {
    let F = [], D = I % 8, U = P % 8, Z = (I - D) / 8, $ = (P - U) / 8;
    for (let j = 0; j < w.length; j++) {
      let G = w[j], Q = Z * G.x.length, H = $ * G.y.length;
      for (let W = 0; W < G.x.length && G.x[W] < D; W++) Q++;
      for (let W = 0; W < G.y.length && G.y[W] < U; W++) H++;
      Q > 0 && H > 0 && F.push({ width: Q, height: H, index: j });
    }
    return F;
  }, g.getInterlaceIterator = function(I) {
    return function(P, F, D) {
      let U = P % w[D].x.length, Z = (P - U) / w[D].x.length * 8 + w[D].x[U], $ = F % w[D].y.length;
      return 4 * Z + ((F - $) / w[D].y.length * 8 + w[D].y[$]) * I * 4;
    };
  };
}, {}], 12: [function(d, m, g) {
  (function(w) {
    (function() {
      let I = d("util"), P = d("stream"), F = d("./constants"), D = d("./packer"), U = m.exports = function(Z) {
        P.call(this);
        let $ = Z || {};
        this._packer = new D($), this._deflate = this._packer.createDeflate(), this.readable = !0;
      };
      I.inherits(U, P), U.prototype.pack = function(Z, $, j, G) {
        this.emit("data", w.from(F.PNG_SIGNATURE)), this.emit("data", this._packer.packIHDR($, j)), G && this.emit("data", this._packer.packGAMA(G));
        let Q = this._packer.filterData(Z, $, j);
        this._deflate.on("error", this.emit.bind(this, "error")), this._deflate.on("data", (function(H) {
          this.emit("data", this._packer.packIDAT(H));
        }).bind(this)), this._deflate.on("end", (function() {
          this.emit("data", this._packer.packIEND()), this.emit("end");
        }).bind(this)), this._deflate.end(Q);
      };
    }).call(this);
  }).call(this, d("buffer").Buffer);
}, { "./constants": 4, "./packer": 14, buffer: 32, stream: 65, util: 84 }], 13: [function(d, m, g) {
  (function(w) {
    (function() {
      let I = !0, P = d("zlib");
      P.deflateSync || (I = !1);
      let F = d("./constants"), D = d("./packer");
      m.exports = function(U, Z) {
        if (!I) throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
        let $ = new D(Z || {}), j = [];
        j.push(w.from(F.PNG_SIGNATURE)), j.push($.packIHDR(U.width, U.height)), U.gamma && j.push($.packGAMA(U.gamma));
        let G = $.filterData(U.data, U.width, U.height), Q = P.deflateSync(G, $.getDeflateOptions());
        if (G = null, !Q || !Q.length) throw new Error("bad png - invalid compressed data response");
        return j.push($.packIDAT(Q)), j.push($.packIEND()), w.concat(j);
      };
    }).call(this);
  }).call(this, d("buffer").Buffer);
}, { "./constants": 4, "./packer": 14, buffer: 32, zlib: 31 }], 14: [function(d, m, g) {
  (function(w) {
    (function() {
      let I = d("./constants"), P = d("./crc"), F = d("./bitpacker"), D = d("./filter-pack"), U = d("zlib"), Z = m.exports = function($) {
        if (this._options = $, $.deflateChunkSize = $.deflateChunkSize || 32768, $.deflateLevel = $.deflateLevel != null ? $.deflateLevel : 9, $.deflateStrategy = $.deflateStrategy != null ? $.deflateStrategy : 3, $.inputHasAlpha = $.inputHasAlpha == null || $.inputHasAlpha, $.deflateFactory = $.deflateFactory || U.createDeflate, $.bitDepth = $.bitDepth || 8, $.colorType = typeof $.colorType == "number" ? $.colorType : I.COLORTYPE_COLOR_ALPHA, $.inputColorType = typeof $.inputColorType == "number" ? $.inputColorType : I.COLORTYPE_COLOR_ALPHA, [I.COLORTYPE_GRAYSCALE, I.COLORTYPE_COLOR, I.COLORTYPE_COLOR_ALPHA, I.COLORTYPE_ALPHA].indexOf($.colorType) === -1) throw new Error("option color type:" + $.colorType + " is not supported at present");
        if ([I.COLORTYPE_GRAYSCALE, I.COLORTYPE_COLOR, I.COLORTYPE_COLOR_ALPHA, I.COLORTYPE_ALPHA].indexOf($.inputColorType) === -1) throw new Error("option input color type:" + $.inputColorType + " is not supported at present");
        if ($.bitDepth !== 8 && $.bitDepth !== 16) throw new Error("option bit depth:" + $.bitDepth + " is not supported at present");
      };
      Z.prototype.getDeflateOptions = function() {
        return { chunkSize: this._options.deflateChunkSize, level: this._options.deflateLevel, strategy: this._options.deflateStrategy };
      }, Z.prototype.createDeflate = function() {
        return this._options.deflateFactory(this.getDeflateOptions());
      }, Z.prototype.filterData = function($, j, G) {
        let Q = F($, j, G, this._options), H = I.COLORTYPE_TO_BPP_MAP[this._options.colorType];
        return D(Q, j, G, this._options, H);
      }, Z.prototype._packChunk = function($, j) {
        let G = j ? j.length : 0, Q = w.alloc(G + 12);
        return Q.writeUInt32BE(G, 0), Q.writeUInt32BE($, 4), j && j.copy(Q, 8), Q.writeInt32BE(P.crc32(Q.slice(4, Q.length - 4)), Q.length - 4), Q;
      }, Z.prototype.packGAMA = function($) {
        let j = w.alloc(4);
        return j.writeUInt32BE(Math.floor($ * I.GAMMA_DIVISION), 0), this._packChunk(I.TYPE_gAMA, j);
      }, Z.prototype.packIHDR = function($, j) {
        let G = w.alloc(13);
        return G.writeUInt32BE($, 0), G.writeUInt32BE(j, 4), G[8] = this._options.bitDepth, G[9] = this._options.colorType, G[10] = 0, G[11] = 0, G[12] = 0, this._packChunk(I.TYPE_IHDR, G);
      }, Z.prototype.packIDAT = function($) {
        return this._packChunk(I.TYPE_IDAT, $);
      }, Z.prototype.packIEND = function() {
        return this._packChunk(I.TYPE_IEND, null);
      };
    }).call(this);
  }).call(this, d("buffer").Buffer);
}, { "./bitpacker": 2, "./constants": 4, "./crc": 5, "./filter-pack": 6, buffer: 32, zlib: 31 }], 15: [function(d, m, g) {
  m.exports = function(w, I, P) {
    let F = w + I - P, D = Math.abs(F - w), U = Math.abs(F - I), Z = Math.abs(F - P);
    return D <= U && D <= Z ? w : U <= Z ? I : P;
  };
}, {}], 16: [function(d, m, g) {
  let w = d("util"), I = d("zlib"), P = d("./chunkstream"), F = d("./filter-parse-async"), D = d("./parser"), U = d("./bitmapper"), Z = d("./format-normaliser"), $ = m.exports = function(j) {
    P.call(this), this._parser = new D(j, { read: this.read.bind(this), error: this._handleError.bind(this), metadata: this._handleMetaData.bind(this), gamma: this.emit.bind(this, "gamma"), palette: this._handlePalette.bind(this), transColor: this._handleTransColor.bind(this), finished: this._finished.bind(this), inflateData: this._inflateData.bind(this), simpleTransparency: this._simpleTransparency.bind(this), headersFinished: this._headersFinished.bind(this) }), this._options = j, this.writable = !0, this._parser.start();
  };
  w.inherits($, P), $.prototype._handleError = function(j) {
    this.emit("error", j), this.writable = !1, this.destroy(), this._inflate && this._inflate.destroy && this._inflate.destroy(), this._filter && (this._filter.destroy(), this._filter.on("error", function() {
    })), this.errord = !0;
  }, $.prototype._inflateData = function(j) {
    if (!this._inflate) if (this._bitmapInfo.interlace) this._inflate = I.createInflate(), this._inflate.on("error", this.emit.bind(this, "error")), this._filter.on("complete", this._complete.bind(this)), this._inflate.pipe(this._filter);
    else {
      let G = (1 + (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3)) * this._bitmapInfo.height, Q = Math.max(G, I.Z_MIN_CHUNK);
      this._inflate = I.createInflate({ chunkSize: Q });
      let H = G, W = this.emit.bind(this, "error");
      this._inflate.on("error", function(et) {
        H && W(et);
      }), this._filter.on("complete", this._complete.bind(this));
      let q = this._filter.write.bind(this._filter);
      this._inflate.on("data", function(et) {
        H && (et.length > H && (et = et.slice(0, H)), H -= et.length, q(et));
      }), this._inflate.on("end", this._filter.end.bind(this._filter));
    }
    this._inflate.write(j);
  }, $.prototype._handleMetaData = function(j) {
    this._metaData = j, this._bitmapInfo = Object.create(j), this._filter = new F(this._bitmapInfo);
  }, $.prototype._handleTransColor = function(j) {
    this._bitmapInfo.transColor = j;
  }, $.prototype._handlePalette = function(j) {
    this._bitmapInfo.palette = j;
  }, $.prototype._simpleTransparency = function() {
    this._metaData.alpha = !0;
  }, $.prototype._headersFinished = function() {
    this.emit("metadata", this._metaData);
  }, $.prototype._finished = function() {
    this.errord || (this._inflate ? this._inflate.end() : this.emit("error", "No Inflate block"));
  }, $.prototype._complete = function(j) {
    if (this.errord) return;
    let G;
    try {
      let Q = U.dataToBitMap(j, this._bitmapInfo);
      G = Z(Q, this._bitmapInfo, this._options.skipRescale), Q = null;
    } catch (Q) {
      return void this._handleError(Q);
    }
    this.emit("parsed", G);
  };
}, { "./bitmapper": 1, "./chunkstream": 3, "./filter-parse-async": 7, "./format-normaliser": 10, "./parser": 18, util: 84, zlib: 31 }], 17: [function(d, m, g) {
  (function(w) {
    (function() {
      let I = !0, P = d("zlib"), F = d("./sync-inflate");
      P.deflateSync || (I = !1);
      let D = d("./sync-reader"), U = d("./filter-parse-sync"), Z = d("./parser"), $ = d("./bitmapper"), j = d("./format-normaliser");
      m.exports = function(G, Q) {
        if (!I) throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
        let H, W, q;
        function et(ht) {
          H = ht;
        }
        function rt(ht) {
          W = ht;
        }
        function tt(ht) {
          W.transColor = ht;
        }
        function V(ht) {
          W.palette = ht;
        }
        function X() {
          W.alpha = !0;
        }
        function ot(ht) {
          q = ht;
        }
        let it = [];
        function st(ht) {
          it.push(ht);
        }
        let at = new D(G);
        if (new Z(Q, { read: at.read.bind(at), error: et, metadata: rt, gamma: ot, palette: V, transColor: tt, inflateData: st, simpleTransparency: X }).start(), at.process(), H) throw H;
        let ct, K = w.concat(it);
        if (it.length = 0, W.interlace) ct = P.inflateSync(K);
        else {
          let ht = (1 + (W.width * W.bpp * W.depth + 7 >> 3)) * W.height;
          ct = F(K, { chunkSize: ht, maxLength: ht });
        }
        if (K = null, !ct || !ct.length) throw new Error("bad png - invalid inflate data response");
        let lt = U.process(ct, W);
        K = null;
        let vt = $.dataToBitMap(lt, W);
        lt = null;
        let dt = j(vt, W, Q.skipRescale);
        return W.data = dt, W.gamma = q || 0, W;
      };
    }).call(this);
  }).call(this, d("buffer").Buffer);
}, { "./bitmapper": 1, "./filter-parse-sync": 8, "./format-normaliser": 10, "./parser": 18, "./sync-inflate": 21, "./sync-reader": 22, buffer: 32, zlib: 31 }], 18: [function(d, m, g) {
  (function(w) {
    (function() {
      let I = d("./constants"), P = d("./crc"), F = m.exports = function(D, U) {
        this._options = D, D.checkCRC = D.checkCRC !== !1, this._hasIHDR = !1, this._hasIEND = !1, this._emittedHeadersFinished = !1, this._palette = [], this._colorType = 0, this._chunks = {}, this._chunks[I.TYPE_IHDR] = this._handleIHDR.bind(this), this._chunks[I.TYPE_IEND] = this._handleIEND.bind(this), this._chunks[I.TYPE_IDAT] = this._handleIDAT.bind(this), this._chunks[I.TYPE_PLTE] = this._handlePLTE.bind(this), this._chunks[I.TYPE_tRNS] = this._handleTRNS.bind(this), this._chunks[I.TYPE_gAMA] = this._handleGAMA.bind(this), this.read = U.read, this.error = U.error, this.metadata = U.metadata, this.gamma = U.gamma, this.transColor = U.transColor, this.palette = U.palette, this.parsed = U.parsed, this.inflateData = U.inflateData, this.finished = U.finished, this.simpleTransparency = U.simpleTransparency, this.headersFinished = U.headersFinished || function() {
        };
      };
      F.prototype.start = function() {
        this.read(I.PNG_SIGNATURE.length, this._parseSignature.bind(this));
      }, F.prototype._parseSignature = function(D) {
        let U = I.PNG_SIGNATURE;
        for (let Z = 0; Z < U.length; Z++) if (D[Z] !== U[Z]) return void this.error(new Error("Invalid file signature"));
        this.read(8, this._parseChunkBegin.bind(this));
      }, F.prototype._parseChunkBegin = function(D) {
        let U = D.readUInt32BE(0), Z = D.readUInt32BE(4), $ = "";
        for (let G = 4; G < 8; G++) $ += String.fromCharCode(D[G]);
        let j = !!(32 & D[4]);
        if (this._hasIHDR || Z === I.TYPE_IHDR) {
          if (this._crc = new P(), this._crc.write(w.from($)), this._chunks[Z]) return this._chunks[Z](U);
          j ? this.read(U + 4, this._skipChunk.bind(this)) : this.error(new Error("Unsupported critical chunk type " + $));
        } else this.error(new Error("Expected IHDR on beggining"));
      }, F.prototype._skipChunk = function() {
        this.read(8, this._parseChunkBegin.bind(this));
      }, F.prototype._handleChunkEnd = function() {
        this.read(4, this._parseChunkEnd.bind(this));
      }, F.prototype._parseChunkEnd = function(D) {
        let U = D.readInt32BE(0), Z = this._crc.crc32();
        this._options.checkCRC && Z !== U ? this.error(new Error("Crc error - " + U + " - " + Z)) : this._hasIEND || this.read(8, this._parseChunkBegin.bind(this));
      }, F.prototype._handleIHDR = function(D) {
        this.read(D, this._parseIHDR.bind(this));
      }, F.prototype._parseIHDR = function(D) {
        this._crc.write(D);
        let U = D.readUInt32BE(0), Z = D.readUInt32BE(4), $ = D[8], j = D[9], G = D[10], Q = D[11], H = D[12];
        if ($ !== 8 && $ !== 4 && $ !== 2 && $ !== 1 && $ !== 16) return void this.error(new Error("Unsupported bit depth " + $));
        if (!(j in I.COLORTYPE_TO_BPP_MAP)) return void this.error(new Error("Unsupported color type"));
        if (G !== 0) return void this.error(new Error("Unsupported compression method"));
        if (Q !== 0) return void this.error(new Error("Unsupported filter method"));
        if (H !== 0 && H !== 1) return void this.error(new Error("Unsupported interlace method"));
        this._colorType = j;
        let W = I.COLORTYPE_TO_BPP_MAP[this._colorType];
        this._hasIHDR = !0, this.metadata({ width: U, height: Z, depth: $, interlace: !!H, palette: !!(j & I.COLORTYPE_PALETTE), color: !!(j & I.COLORTYPE_COLOR), alpha: !!(j & I.COLORTYPE_ALPHA), bpp: W, colorType: j }), this._handleChunkEnd();
      }, F.prototype._handlePLTE = function(D) {
        this.read(D, this._parsePLTE.bind(this));
      }, F.prototype._parsePLTE = function(D) {
        this._crc.write(D);
        let U = Math.floor(D.length / 3);
        for (let Z = 0; Z < U; Z++) this._palette.push([D[3 * Z], D[3 * Z + 1], D[3 * Z + 2], 255]);
        this.palette(this._palette), this._handleChunkEnd();
      }, F.prototype._handleTRNS = function(D) {
        this.simpleTransparency(), this.read(D, this._parseTRNS.bind(this));
      }, F.prototype._parseTRNS = function(D) {
        if (this._crc.write(D), this._colorType === I.COLORTYPE_PALETTE_COLOR) {
          if (this._palette.length === 0) return void this.error(new Error("Transparency chunk must be after palette"));
          if (D.length > this._palette.length) return void this.error(new Error("More transparent colors than palette size"));
          for (let U = 0; U < D.length; U++) this._palette[U][3] = D[U];
          this.palette(this._palette);
        }
        this._colorType === I.COLORTYPE_GRAYSCALE && this.transColor([D.readUInt16BE(0)]), this._colorType === I.COLORTYPE_COLOR && this.transColor([D.readUInt16BE(0), D.readUInt16BE(2), D.readUInt16BE(4)]), this._handleChunkEnd();
      }, F.prototype._handleGAMA = function(D) {
        this.read(D, this._parseGAMA.bind(this));
      }, F.prototype._parseGAMA = function(D) {
        this._crc.write(D), this.gamma(D.readUInt32BE(0) / I.GAMMA_DIVISION), this._handleChunkEnd();
      }, F.prototype._handleIDAT = function(D) {
        this._emittedHeadersFinished || (this._emittedHeadersFinished = !0, this.headersFinished()), this.read(-D, this._parseIDAT.bind(this, D));
      }, F.prototype._parseIDAT = function(D, U) {
        if (this._crc.write(U), this._colorType === I.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) throw new Error("Expected palette not found");
        this.inflateData(U);
        let Z = D - U.length;
        Z > 0 ? this._handleIDAT(Z) : this._handleChunkEnd();
      }, F.prototype._handleIEND = function(D) {
        this.read(D, this._parseIEND.bind(this));
      }, F.prototype._parseIEND = function(D) {
        this._crc.write(D), this._hasIEND = !0, this._handleChunkEnd(), this.finished && this.finished();
      };
    }).call(this);
  }).call(this, d("buffer").Buffer);
}, { "./constants": 4, "./crc": 5, buffer: 32 }], 19: [function(d, m, g) {
  let w = d("./parser-sync"), I = d("./packer-sync");
  g.read = function(P, F) {
    return w(P, F || {});
  }, g.write = function(P, F) {
    return I(P, F);
  };
}, { "./packer-sync": 13, "./parser-sync": 17 }], 20: [function(d, m, g) {
  (function(w, I) {
    (function() {
      let P = d("util"), F = d("stream"), D = d("./parser-async"), U = d("./packer-async"), Z = d("./png-sync"), $ = g.PNG = function(j) {
        F.call(this), j = j || {}, this.width = 0 | j.width, this.height = 0 | j.height, this.data = this.width > 0 && this.height > 0 ? I.alloc(4 * this.width * this.height) : null, j.fill && this.data && this.data.fill(0), this.gamma = 0, this.readable = this.writable = !0, this._parser = new D(j), this._parser.on("error", this.emit.bind(this, "error")), this._parser.on("close", this._handleClose.bind(this)), this._parser.on("metadata", this._metadata.bind(this)), this._parser.on("gamma", this._gamma.bind(this)), this._parser.on("parsed", (function(G) {
          this.data = G, this.emit("parsed", G);
        }).bind(this)), this._packer = new U(j), this._packer.on("data", this.emit.bind(this, "data")), this._packer.on("end", this.emit.bind(this, "end")), this._parser.on("close", this._handleClose.bind(this)), this._packer.on("error", this.emit.bind(this, "error"));
      };
      P.inherits($, F), $.sync = Z, $.prototype.pack = function() {
        return this.data && this.data.length ? (w.nextTick((function() {
          this._packer.pack(this.data, this.width, this.height, this.gamma);
        }).bind(this)), this) : (this.emit("error", "No data provided"), this);
      }, $.prototype.parse = function(j, G) {
        if (G) {
          let Q, H;
          Q = (function(W) {
            this.removeListener("error", H), this.data = W, G(null, this);
          }).bind(this), H = (function(W) {
            this.removeListener("parsed", Q), G(W, null);
          }).bind(this), this.once("parsed", Q), this.once("error", H);
        }
        return this.end(j), this;
      }, $.prototype.write = function(j) {
        return this._parser.write(j), !0;
      }, $.prototype.end = function(j) {
        this._parser.end(j);
      }, $.prototype._metadata = function(j) {
        this.width = j.width, this.height = j.height, this.emit("metadata", j);
      }, $.prototype._gamma = function(j) {
        this.gamma = j;
      }, $.prototype._handleClose = function() {
        this._parser.writable || this._packer.readable || this.emit("close");
      }, $.bitblt = function(j, G, Q, H, W, q, et, rt) {
        if (H |= 0, W |= 0, q |= 0, et |= 0, rt |= 0, (Q |= 0) > j.width || H > j.height || Q + W > j.width || H + q > j.height) throw new Error("bitblt reading outside image");
        if (et > G.width || rt > G.height || et + W > G.width || rt + q > G.height) throw new Error("bitblt writing outside image");
        for (let tt = 0; tt < q; tt++) j.data.copy(G.data, (rt + tt) * G.width + et << 2, (H + tt) * j.width + Q << 2, (H + tt) * j.width + Q + W << 2);
      }, $.prototype.bitblt = function(j, G, Q, H, W, q, et) {
        return $.bitblt(this, j, G, Q, H, W, q, et), this;
      }, $.adjustGamma = function(j) {
        if (j.gamma) {
          for (let G = 0; G < j.height; G++) for (let Q = 0; Q < j.width; Q++) {
            let H = j.width * G + Q << 2;
            for (let W = 0; W < 3; W++) {
              let q = j.data[H + W] / 255;
              q = Math.pow(q, 1 / 2.2 / j.gamma), j.data[H + W] = Math.round(255 * q);
            }
          }
          j.gamma = 0;
        }
      }, $.prototype.adjustGamma = function() {
        $.adjustGamma(this);
      };
    }).call(this);
  }).call(this, d("_process"), d("buffer").Buffer);
}, { "./packer-async": 12, "./parser-async": 16, "./png-sync": 19, _process: 63, buffer: 32, stream: 65, util: 84 }], 21: [function(d, m, g) {
  (function(w, I) {
    (function() {
      let P = d("assert").ok, F = d("zlib"), D = d("util"), U = d("buffer").kMaxLength;
      function Z(H) {
        if (!(this instanceof Z)) return new Z(H);
        H && H.chunkSize < F.Z_MIN_CHUNK && (H.chunkSize = F.Z_MIN_CHUNK), F.Inflate.call(this, H), this._offset = this._offset === void 0 ? this._outOffset : this._offset, this._buffer = this._buffer || this._outBuffer, H && H.maxLength != null && (this._maxLength = H.maxLength);
      }
      function $(H) {
        return new Z(H);
      }
      function j(H, W) {
        H._handle && (H._handle.close(), H._handle = null);
      }
      function G(H, W) {
        if (typeof W == "string" && (W = I.from(W)), !(W instanceof I)) throw new TypeError("Not a string or buffer");
        let q = H._finishFlushFlag;
        return q == null && (q = F.Z_FINISH), H._processChunk(W, q);
      }
      function Q(H, W) {
        return G(new Z(W), H);
      }
      Z.prototype._processChunk = function(H, W, q) {
        if (typeof q == "function") return F.Inflate._processChunk.call(this, H, W, q);
        let et, rt, tt = this, V = H && H.length, X = this._chunkSize - this._offset, ot = this._maxLength, it = 0, st = [], at = 0;
        function ct(lt, vt) {
          if (tt._hadError) return;
          let dt = X - vt;
          if (P(dt >= 0, "have should not go down"), dt > 0) {
            let ht = tt._buffer.slice(tt._offset, tt._offset + dt);
            if (tt._offset += dt, ht.length > ot && (ht = ht.slice(0, ot)), st.push(ht), at += ht.length, ot -= ht.length, ot === 0) return !1;
          }
          return (vt === 0 || tt._offset >= tt._chunkSize) && (X = tt._chunkSize, tt._offset = 0, tt._buffer = I.allocUnsafe(tt._chunkSize)), vt === 0 && (it += V - lt, V = lt, !0);
        }
        this.on("error", function(lt) {
          et = lt;
        }), P(this._handle, "zlib binding closed");
        do
          rt = this._handle.writeSync(W, H, it, V, this._buffer, this._offset, X), rt = rt || this._writeState;
        while (!this._hadError && ct(rt[0], rt[1]));
        if (this._hadError) throw et;
        if (at >= U) throw j(this), new RangeError("Cannot create final Buffer. It would be larger than 0x" + U.toString(16) + " bytes");
        let K = I.concat(st, at);
        return j(this), K;
      }, D.inherits(Z, F.Inflate), m.exports = g = Q, g.Inflate = Z, g.createInflate = $, g.inflateSync = Q;
    }).call(this);
  }).call(this, d("_process"), d("buffer").Buffer);
}, { _process: 63, assert: 23, buffer: 32, util: 84, zlib: 31 }], 22: [function(d, m, g) {
  let w = m.exports = function(I) {
    this._buffer = I, this._reads = [];
  };
  w.prototype.read = function(I, P) {
    this._reads.push({ length: Math.abs(I), allowLess: I < 0, func: P });
  }, w.prototype.process = function() {
    for (; this._reads.length > 0 && this._buffer.length; ) {
      let I = this._reads[0];
      if (!this._buffer.length || !(this._buffer.length >= I.length || I.allowLess)) break;
      {
        this._reads.shift();
        let P = this._buffer;
        this._buffer = P.slice(I.length), I.func.call(this, P.slice(0, I.length));
      }
    }
    if (this._reads.length > 0) throw new Error("There are some read requests waitng on finished stream");
    if (this._buffer.length > 0) throw new Error("unrecognised content at end of stream");
  };
}, {}], 23: [function(d, m, g) {
  (function(w) {
    (function() {
      var I = d("object-assign");
      /*!
      	 * The buffer module from node.js, for the browser.
      	 *
      	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
      	 * @license  MIT
      	 */
      function P(dt, ht) {
        if (dt === ht) return 0;
        for (var pt = dt.length, Ct = ht.length, St = 0, At = Math.min(pt, Ct); St < At; ++St) if (dt[St] !== ht[St]) {
          pt = dt[St], Ct = ht[St];
          break;
        }
        return pt < Ct ? -1 : Ct < pt ? 1 : 0;
      }
      function F(dt) {
        return w.Buffer && typeof w.Buffer.isBuffer == "function" ? w.Buffer.isBuffer(dt) : !(dt == null || !dt._isBuffer);
      }
      var D = d("util/"), U = Object.prototype.hasOwnProperty, Z = Array.prototype.slice, $ = (function() {
      }).name === "foo";
      function j(dt) {
        return Object.prototype.toString.call(dt);
      }
      function G(dt) {
        return !F(dt) && typeof w.ArrayBuffer == "function" && (typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(dt) : !!dt && (dt instanceof DataView || !!(dt.buffer && dt.buffer instanceof ArrayBuffer)));
      }
      var Q = m.exports = V, H = /\s*function\s+([^\(\s]*)\s*/;
      function W(dt) {
        if (D.isFunction(dt)) {
          if ($) return dt.name;
          var ht = dt.toString().match(H);
          return ht && ht[1];
        }
      }
      function q(dt, ht) {
        return typeof dt == "string" ? dt.length < ht ? dt : dt.slice(0, ht) : dt;
      }
      function et(dt) {
        if ($ || !D.isFunction(dt)) return D.inspect(dt);
        var ht = W(dt);
        return "[Function" + (ht ? ": " + ht : "") + "]";
      }
      function rt(dt) {
        return q(et(dt.actual), 128) + " " + dt.operator + " " + q(et(dt.expected), 128);
      }
      function tt(dt, ht, pt, Ct, St) {
        throw new Q.AssertionError({ message: pt, actual: dt, expected: ht, operator: Ct, stackStartFunction: St });
      }
      function V(dt, ht) {
        dt || tt(dt, !0, ht, "==", Q.ok);
      }
      function X(dt, ht, pt, Ct) {
        if (dt === ht) return !0;
        if (F(dt) && F(ht)) return P(dt, ht) === 0;
        if (D.isDate(dt) && D.isDate(ht)) return dt.getTime() === ht.getTime();
        if (D.isRegExp(dt) && D.isRegExp(ht)) return dt.source === ht.source && dt.global === ht.global && dt.multiline === ht.multiline && dt.lastIndex === ht.lastIndex && dt.ignoreCase === ht.ignoreCase;
        if (dt !== null && typeof dt == "object" || ht !== null && typeof ht == "object") {
          if (G(dt) && G(ht) && j(dt) === j(ht) && !(dt instanceof Float32Array || dt instanceof Float64Array)) return P(new Uint8Array(dt.buffer), new Uint8Array(ht.buffer)) === 0;
          if (F(dt) !== F(ht)) return !1;
          var St = (Ct = Ct || { actual: [], expected: [] }).actual.indexOf(dt);
          return St !== -1 && St === Ct.expected.indexOf(ht) || (Ct.actual.push(dt), Ct.expected.push(ht), it(dt, ht, pt, Ct));
        }
        return pt ? dt === ht : dt == ht;
      }
      function ot(dt) {
        return Object.prototype.toString.call(dt) == "[object Arguments]";
      }
      function it(dt, ht, pt, Ct) {
        if (dt == null || ht == null) return !1;
        if (D.isPrimitive(dt) || D.isPrimitive(ht)) return dt === ht;
        if (pt && Object.getPrototypeOf(dt) !== Object.getPrototypeOf(ht)) return !1;
        var St = ot(dt), At = ot(ht);
        if (St && !At || !St && At) return !1;
        if (St) return X(dt = Z.call(dt), ht = Z.call(ht), pt);
        var Ft, xt, Pt = vt(dt), Ot = vt(ht);
        if (Pt.length !== Ot.length) return !1;
        for (Pt.sort(), Ot.sort(), xt = Pt.length - 1; xt >= 0; xt--) if (Pt[xt] !== Ot[xt]) return !1;
        for (xt = Pt.length - 1; xt >= 0; xt--) if (!X(dt[Ft = Pt[xt]], ht[Ft], pt, Ct)) return !1;
        return !0;
      }
      function st(dt, ht, pt) {
        X(dt, ht, !0) && tt(dt, ht, pt, "notDeepStrictEqual", st);
      }
      function at(dt, ht) {
        if (!dt || !ht) return !1;
        if (Object.prototype.toString.call(ht) == "[object RegExp]") return ht.test(dt);
        try {
          if (dt instanceof ht) return !0;
        } catch {
        }
        return !Error.isPrototypeOf(ht) && ht.call({}, dt) === !0;
      }
      function ct(dt) {
        var ht;
        try {
          dt();
        } catch (pt) {
          ht = pt;
        }
        return ht;
      }
      function K(dt, ht, pt, Ct) {
        var St;
        if (typeof ht != "function") throw new TypeError('"block" argument must be a function');
        typeof pt == "string" && (Ct = pt, pt = null), St = ct(ht), Ct = (pt && pt.name ? " (" + pt.name + ")." : ".") + (Ct ? " " + Ct : "."), dt && !St && tt(St, pt, "Missing expected exception" + Ct);
        var At = typeof Ct == "string", Ft = !dt && St && !pt;
        if ((!dt && D.isError(St) && At && at(St, pt) || Ft) && tt(St, pt, "Got unwanted exception" + Ct), dt && St && pt && !at(St, pt) || !dt && St) throw St;
      }
      function lt(dt, ht) {
        dt || tt(dt, !0, ht, "==", lt);
      }
      Q.AssertionError = function(dt) {
        this.name = "AssertionError", this.actual = dt.actual, this.expected = dt.expected, this.operator = dt.operator, dt.message ? (this.message = dt.message, this.generatedMessage = !1) : (this.message = rt(this), this.generatedMessage = !0);
        var ht = dt.stackStartFunction || tt;
        if (Error.captureStackTrace) Error.captureStackTrace(this, ht);
        else {
          var pt = new Error();
          if (pt.stack) {
            var Ct = pt.stack, St = W(ht), At = Ct.indexOf(`
` + St);
            if (At >= 0) {
              var Ft = Ct.indexOf(`
`, At + 1);
              Ct = Ct.substring(Ft + 1);
            }
            this.stack = Ct;
          }
        }
      }, D.inherits(Q.AssertionError, Error), Q.fail = tt, Q.ok = V, Q.equal = function(dt, ht, pt) {
        dt != ht && tt(dt, ht, pt, "==", Q.equal);
      }, Q.notEqual = function(dt, ht, pt) {
        dt == ht && tt(dt, ht, pt, "!=", Q.notEqual);
      }, Q.deepEqual = function(dt, ht, pt) {
        X(dt, ht, !1) || tt(dt, ht, pt, "deepEqual", Q.deepEqual);
      }, Q.deepStrictEqual = function(dt, ht, pt) {
        X(dt, ht, !0) || tt(dt, ht, pt, "deepStrictEqual", Q.deepStrictEqual);
      }, Q.notDeepEqual = function(dt, ht, pt) {
        X(dt, ht, !1) && tt(dt, ht, pt, "notDeepEqual", Q.notDeepEqual);
      }, Q.notDeepStrictEqual = st, Q.strictEqual = function(dt, ht, pt) {
        dt !== ht && tt(dt, ht, pt, "===", Q.strictEqual);
      }, Q.notStrictEqual = function(dt, ht, pt) {
        dt === ht && tt(dt, ht, pt, "!==", Q.notStrictEqual);
      }, Q.throws = function(dt, ht, pt) {
        K(!0, dt, ht, pt);
      }, Q.doesNotThrow = function(dt, ht, pt) {
        K(!1, dt, ht, pt);
      }, Q.ifError = function(dt) {
        if (dt) throw dt;
      }, Q.strict = I(lt, Q, { equal: Q.strictEqual, deepEqual: Q.deepStrictEqual, notEqual: Q.notStrictEqual, notDeepEqual: Q.notDeepStrictEqual }), Q.strict.strict = Q.strict;
      var vt = Object.keys || function(dt) {
        var ht = [];
        for (var pt in dt) U.call(dt, pt) && ht.push(pt);
        return ht;
      };
    }).call(this);
  }).call(this, commonjsGlobal !== void 0 ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
}, { "object-assign": 51, "util/": 26 }], 24: [function(d, m, g) {
  typeof Object.create == "function" ? m.exports = function(w, I) {
    w.super_ = I, w.prototype = Object.create(I.prototype, { constructor: { value: w, enumerable: !1, writable: !0, configurable: !0 } });
  } : m.exports = function(w, I) {
    w.super_ = I;
    var P = function() {
    };
    P.prototype = I.prototype, w.prototype = new P(), w.prototype.constructor = w;
  };
}, {}], 25: [function(d, m, g) {
  m.exports = function(w) {
    return w && typeof w == "object" && typeof w.copy == "function" && typeof w.fill == "function" && typeof w.readUInt8 == "function";
  };
}, {}], 26: [function(d, m, g) {
  (function(w, I) {
    (function() {
      var P = /%[sdj%]/g;
      g.format = function(xt) {
        if (!it(xt)) {
          for (var Pt = [], Ot = 0; Ot < arguments.length; Ot++) Pt.push(U(arguments[Ot]));
          return Pt.join(" ");
        }
        Ot = 1;
        for (var Bt = arguments, kt = Bt.length, Tt = String(xt).replace(P, function(Zt) {
          if (Zt === "%%") return "%";
          if (Ot >= kt) return Zt;
          switch (Zt) {
            case "%s":
              return String(Bt[Ot++]);
            case "%d":
              return Number(Bt[Ot++]);
            case "%j":
              try {
                return JSON.stringify(Bt[Ot++]);
              } catch {
                return "[Circular]";
              }
            default:
              return Zt;
          }
        }), Dt = Bt[Ot]; Ot < kt; Dt = Bt[++Ot]) V(Dt) || !K(Dt) ? Tt += " " + Dt : Tt += " " + U(Dt);
        return Tt;
      }, g.deprecate = function(xt, Pt) {
        if (at(I.process)) return function() {
          return g.deprecate(xt, Pt).apply(this, arguments);
        };
        if (w.noDeprecation === !0) return xt;
        var Ot = !1;
        function Bt() {
          if (!Ot) {
            if (w.throwDeprecation) throw new Error(Pt);
            w.traceDeprecation ? console.trace(Pt) : console.error(Pt), Ot = !0;
          }
          return xt.apply(this, arguments);
        }
        return Bt;
      };
      var F, D = {};
      function U(xt, Pt) {
        var Ot = { seen: [], stylize: $ };
        return arguments.length >= 3 && (Ot.depth = arguments[2]), arguments.length >= 4 && (Ot.colors = arguments[3]), tt(Pt) ? Ot.showHidden = Pt : Pt && g._extend(Ot, Pt), at(Ot.showHidden) && (Ot.showHidden = !1), at(Ot.depth) && (Ot.depth = 2), at(Ot.colors) && (Ot.colors = !1), at(Ot.customInspect) && (Ot.customInspect = !0), Ot.colors && (Ot.stylize = Z), G(Ot, xt, Ot.depth);
      }
      function Z(xt, Pt) {
        var Ot = U.styles[Pt];
        return Ot ? "\x1B[" + U.colors[Ot][0] + "m" + xt + "\x1B[" + U.colors[Ot][1] + "m" : xt;
      }
      function $(xt, Pt) {
        return xt;
      }
      function j(xt) {
        var Pt = {};
        return xt.forEach(function(Ot, Bt) {
          Pt[Ot] = !0;
        }), Pt;
      }
      function G(xt, Pt, Ot) {
        if (xt.customInspect && Pt && dt(Pt.inspect) && Pt.inspect !== g.inspect && (!Pt.constructor || Pt.constructor.prototype !== Pt)) {
          var Bt = Pt.inspect(Ot, xt);
          return it(Bt) || (Bt = G(xt, Bt, Ot)), Bt;
        }
        var kt = Q(xt, Pt);
        if (kt) return kt;
        var Tt = Object.keys(Pt), Dt = j(Tt);
        if (xt.showHidden && (Tt = Object.getOwnPropertyNames(Pt)), vt(Pt) && (Tt.indexOf("message") >= 0 || Tt.indexOf("description") >= 0)) return H(Pt);
        if (Tt.length === 0) {
          if (dt(Pt)) {
            var Zt = Pt.name ? ": " + Pt.name : "";
            return xt.stylize("[Function" + Zt + "]", "special");
          }
          if (ct(Pt)) return xt.stylize(RegExp.prototype.toString.call(Pt), "regexp");
          if (lt(Pt)) return xt.stylize(Date.prototype.toString.call(Pt), "date");
          if (vt(Pt)) return H(Pt);
        }
        var $t, Mt = "", nt = !1, It = ["{", "}"];
        return rt(Pt) && (nt = !0, It = ["[", "]"]), dt(Pt) && (Mt = " [Function" + (Pt.name ? ": " + Pt.name : "") + "]"), ct(Pt) && (Mt = " " + RegExp.prototype.toString.call(Pt)), lt(Pt) && (Mt = " " + Date.prototype.toUTCString.call(Pt)), vt(Pt) && (Mt = " " + H(Pt)), Tt.length !== 0 || nt && Pt.length != 0 ? Ot < 0 ? ct(Pt) ? xt.stylize(RegExp.prototype.toString.call(Pt), "regexp") : xt.stylize("[Object]", "special") : (xt.seen.push(Pt), $t = nt ? W(xt, Pt, Ot, Dt, Tt) : Tt.map(function(mt) {
          return q(xt, Pt, Ot, Dt, mt, nt);
        }), xt.seen.pop(), et($t, Mt, It)) : It[0] + Mt + It[1];
      }
      function Q(xt, Pt) {
        if (at(Pt)) return xt.stylize("undefined", "undefined");
        if (it(Pt)) {
          var Ot = "'" + JSON.stringify(Pt).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return xt.stylize(Ot, "string");
        }
        return ot(Pt) ? xt.stylize("" + Pt, "number") : tt(Pt) ? xt.stylize("" + Pt, "boolean") : V(Pt) ? xt.stylize("null", "null") : void 0;
      }
      function H(xt) {
        return "[" + Error.prototype.toString.call(xt) + "]";
      }
      function W(xt, Pt, Ot, Bt, kt) {
        for (var Tt = [], Dt = 0, Zt = Pt.length; Dt < Zt; ++Dt) Ft(Pt, String(Dt)) ? Tt.push(q(xt, Pt, Ot, Bt, String(Dt), !0)) : Tt.push("");
        return kt.forEach(function($t) {
          $t.match(/^\d+$/) || Tt.push(q(xt, Pt, Ot, Bt, $t, !0));
        }), Tt;
      }
      function q(xt, Pt, Ot, Bt, kt, Tt) {
        var Dt, Zt, $t;
        if (($t = Object.getOwnPropertyDescriptor(Pt, kt) || { value: Pt[kt] }).get ? Zt = $t.set ? xt.stylize("[Getter/Setter]", "special") : xt.stylize("[Getter]", "special") : $t.set && (Zt = xt.stylize("[Setter]", "special")), Ft(Bt, kt) || (Dt = "[" + kt + "]"), Zt || (xt.seen.indexOf($t.value) < 0 ? (Zt = V(Ot) ? G(xt, $t.value, null) : G(xt, $t.value, Ot - 1)).indexOf(`
`) > -1 && (Zt = Tt ? Zt.split(`
`).map(function(Mt) {
          return "  " + Mt;
        }).join(`
`).substr(2) : `
` + Zt.split(`
`).map(function(Mt) {
          return "   " + Mt;
        }).join(`
`)) : Zt = xt.stylize("[Circular]", "special")), at(Dt)) {
          if (Tt && kt.match(/^\d+$/)) return Zt;
          (Dt = JSON.stringify("" + kt)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Dt = Dt.substr(1, Dt.length - 2), Dt = xt.stylize(Dt, "name")) : (Dt = Dt.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Dt = xt.stylize(Dt, "string"));
        }
        return Dt + ": " + Zt;
      }
      function et(xt, Pt, Ot) {
        return xt.reduce(function(Bt, kt) {
          return kt.indexOf(`
`), Bt + kt.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0) > 60 ? Ot[0] + (Pt === "" ? "" : Pt + `
 `) + " " + xt.join(`,
  `) + " " + Ot[1] : Ot[0] + Pt + " " + xt.join(", ") + " " + Ot[1];
      }
      function rt(xt) {
        return Array.isArray(xt);
      }
      function tt(xt) {
        return typeof xt == "boolean";
      }
      function V(xt) {
        return xt === null;
      }
      function X(xt) {
        return xt == null;
      }
      function ot(xt) {
        return typeof xt == "number";
      }
      function it(xt) {
        return typeof xt == "string";
      }
      function st(xt) {
        return typeof xt == "symbol";
      }
      function at(xt) {
        return xt === void 0;
      }
      function ct(xt) {
        return K(xt) && pt(xt) === "[object RegExp]";
      }
      function K(xt) {
        return typeof xt == "object" && xt !== null;
      }
      function lt(xt) {
        return K(xt) && pt(xt) === "[object Date]";
      }
      function vt(xt) {
        return K(xt) && (pt(xt) === "[object Error]" || xt instanceof Error);
      }
      function dt(xt) {
        return typeof xt == "function";
      }
      function ht(xt) {
        return xt === null || typeof xt == "boolean" || typeof xt == "number" || typeof xt == "string" || typeof xt == "symbol" || xt === void 0;
      }
      function pt(xt) {
        return Object.prototype.toString.call(xt);
      }
      function Ct(xt) {
        return xt < 10 ? "0" + xt.toString(10) : xt.toString(10);
      }
      g.debuglog = function(xt) {
        if (at(F) && (F = w.env.NODE_DEBUG || ""), xt = xt.toUpperCase(), !D[xt]) if (new RegExp("\\b" + xt + "\\b", "i").test(F)) {
          var Pt = w.pid;
          D[xt] = function() {
            var Ot = g.format.apply(g, arguments);
            console.error("%s %d: %s", xt, Pt, Ot);
          };
        } else D[xt] = function() {
        };
        return D[xt];
      }, g.inspect = U, U.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, U.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, g.isArray = rt, g.isBoolean = tt, g.isNull = V, g.isNullOrUndefined = X, g.isNumber = ot, g.isString = it, g.isSymbol = st, g.isUndefined = at, g.isRegExp = ct, g.isObject = K, g.isDate = lt, g.isError = vt, g.isFunction = dt, g.isPrimitive = ht, g.isBuffer = d("./support/isBuffer");
      var St = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      function At() {
        var xt = /* @__PURE__ */ new Date(), Pt = [Ct(xt.getHours()), Ct(xt.getMinutes()), Ct(xt.getSeconds())].join(":");
        return [xt.getDate(), St[xt.getMonth()], Pt].join(" ");
      }
      function Ft(xt, Pt) {
        return Object.prototype.hasOwnProperty.call(xt, Pt);
      }
      g.log = function() {
        console.log("%s - %s", At(), g.format.apply(g, arguments));
      }, g.inherits = d("inherits"), g._extend = function(xt, Pt) {
        if (!Pt || !K(Pt)) return xt;
        for (var Ot = Object.keys(Pt), Bt = Ot.length; Bt--; ) xt[Ot[Bt]] = Pt[Ot[Bt]];
        return xt;
      };
    }).call(this);
  }).call(this, d("_process"), commonjsGlobal !== void 0 ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
}, { "./support/isBuffer": 25, _process: 63, inherits: 24 }], 27: [function(d, m, g) {
  (function(w) {
    (function() {
      var I = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], P = typeof globalThis > "u" ? w : globalThis;
      m.exports = function() {
        for (var F = [], D = 0; D < I.length; D++) typeof P[I[D]] == "function" && (F[F.length] = I[D]);
        return F;
      };
    }).call(this);
  }).call(this, commonjsGlobal !== void 0 ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
}, {}], 28: [function(d, m, g) {
  g.byteLength = $, g.toByteArray = G, g.fromByteArray = W;
  for (var w = [], I = [], P = typeof Uint8Array < "u" ? Uint8Array : Array, F = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", D = 0, U = F.length; D < U; ++D) w[D] = F[D], I[F.charCodeAt(D)] = D;
  function Z(q) {
    var et = q.length;
    if (et % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var rt = q.indexOf("=");
    return rt === -1 && (rt = et), [rt, rt === et ? 0 : 4 - rt % 4];
  }
  function $(q) {
    var et = Z(q), rt = et[0], tt = et[1];
    return 3 * (rt + tt) / 4 - tt;
  }
  function j(q, et, rt) {
    return 3 * (et + rt) / 4 - rt;
  }
  function G(q) {
    var et, rt, tt = Z(q), V = tt[0], X = tt[1], ot = new P(j(q, V, X)), it = 0, st = X > 0 ? V - 4 : V;
    for (rt = 0; rt < st; rt += 4) et = I[q.charCodeAt(rt)] << 18 | I[q.charCodeAt(rt + 1)] << 12 | I[q.charCodeAt(rt + 2)] << 6 | I[q.charCodeAt(rt + 3)], ot[it++] = et >> 16 & 255, ot[it++] = et >> 8 & 255, ot[it++] = 255 & et;
    return X === 2 && (et = I[q.charCodeAt(rt)] << 2 | I[q.charCodeAt(rt + 1)] >> 4, ot[it++] = 255 & et), X === 1 && (et = I[q.charCodeAt(rt)] << 10 | I[q.charCodeAt(rt + 1)] << 4 | I[q.charCodeAt(rt + 2)] >> 2, ot[it++] = et >> 8 & 255, ot[it++] = 255 & et), ot;
  }
  function Q(q) {
    return w[q >> 18 & 63] + w[q >> 12 & 63] + w[q >> 6 & 63] + w[63 & q];
  }
  function H(q, et, rt) {
    for (var tt, V = [], X = et; X < rt; X += 3) tt = (q[X] << 16 & 16711680) + (q[X + 1] << 8 & 65280) + (255 & q[X + 2]), V.push(Q(tt));
    return V.join("");
  }
  function W(q) {
    for (var et, rt = q.length, tt = rt % 3, V = [], X = 16383, ot = 0, it = rt - tt; ot < it; ot += X) V.push(H(q, ot, ot + X > it ? it : ot + X));
    return tt === 1 ? (et = q[rt - 1], V.push(w[et >> 2] + w[et << 4 & 63] + "==")) : tt === 2 && (et = (q[rt - 2] << 8) + q[rt - 1], V.push(w[et >> 10] + w[et >> 4 & 63] + w[et << 2 & 63] + "=")), V.join("");
  }
  I[45] = 62, I[95] = 63;
}, {}], 29: [function(d, m, g) {
}, {}], 30: [function(d, m, g) {
  (function(w, I) {
    (function() {
      var P = d("assert"), F = d("pako/lib/zlib/zstream"), D = d("pako/lib/zlib/deflate.js"), U = d("pako/lib/zlib/inflate.js"), Z = d("pako/lib/zlib/constants");
      for (var $ in Z) g[$] = Z[$];
      g.NONE = 0, g.DEFLATE = 1, g.INFLATE = 2, g.GZIP = 3, g.GUNZIP = 4, g.DEFLATERAW = 5, g.INFLATERAW = 6, g.UNZIP = 7;
      var j = 31, G = 139;
      function Q(H) {
        if (typeof H != "number" || H < g.DEFLATE || H > g.UNZIP) throw new TypeError("Bad argument");
        this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = H, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0;
      }
      Q.prototype.close = function() {
        this.write_in_progress ? this.pending_close = !0 : (this.pending_close = !1, P(this.init_done, "close before init"), P(this.mode <= g.UNZIP), this.mode === g.DEFLATE || this.mode === g.GZIP || this.mode === g.DEFLATERAW ? D.deflateEnd(this.strm) : this.mode !== g.INFLATE && this.mode !== g.GUNZIP && this.mode !== g.INFLATERAW && this.mode !== g.UNZIP || U.inflateEnd(this.strm), this.mode = g.NONE, this.dictionary = null);
      }, Q.prototype.write = function(H, W, q, et, rt, tt, V) {
        return this._write(!0, H, W, q, et, rt, tt, V);
      }, Q.prototype.writeSync = function(H, W, q, et, rt, tt, V) {
        return this._write(!1, H, W, q, et, rt, tt, V);
      }, Q.prototype._write = function(H, W, q, et, rt, tt, V, X) {
        if (P.equal(arguments.length, 8), P(this.init_done, "write before init"), P(this.mode !== g.NONE, "already finalized"), P.equal(!1, this.write_in_progress, "write already in progress"), P.equal(!1, this.pending_close, "close is pending"), this.write_in_progress = !0, P.equal(!1, W === void 0, "must provide flush value"), this.write_in_progress = !0, W !== g.Z_NO_FLUSH && W !== g.Z_PARTIAL_FLUSH && W !== g.Z_SYNC_FLUSH && W !== g.Z_FULL_FLUSH && W !== g.Z_FINISH && W !== g.Z_BLOCK) throw new Error("Invalid flush value");
        if (q == null && (q = I.alloc(0), rt = 0, et = 0), this.strm.avail_in = rt, this.strm.input = q, this.strm.next_in = et, this.strm.avail_out = X, this.strm.output = tt, this.strm.next_out = V, this.flush = W, !H) return this._process(), this._checkError() ? this._afterSync() : void 0;
        var ot = this;
        return w.nextTick(function() {
          ot._process(), ot._after();
        }), this;
      }, Q.prototype._afterSync = function() {
        var H = this.strm.avail_out, W = this.strm.avail_in;
        return this.write_in_progress = !1, [W, H];
      }, Q.prototype._process = function() {
        var H = null;
        switch (this.mode) {
          case g.DEFLATE:
          case g.GZIP:
          case g.DEFLATERAW:
            this.err = D.deflate(this.strm, this.flush);
            break;
          case g.UNZIP:
            switch (this.strm.avail_in > 0 && (H = this.strm.next_in), this.gzip_id_bytes_read) {
              case 0:
                if (H === null) break;
                if (this.strm.input[H] !== j) {
                  this.mode = g.INFLATE;
                  break;
                }
                if (this.gzip_id_bytes_read = 1, H++, this.strm.avail_in === 1) break;
              case 1:
                if (H === null) break;
                this.strm.input[H] === G ? (this.gzip_id_bytes_read = 2, this.mode = g.GUNZIP) : this.mode = g.INFLATE;
                break;
              default:
                throw new Error("invalid number of gzip magic number bytes read");
            }
          case g.INFLATE:
          case g.GUNZIP:
          case g.INFLATERAW:
            for (this.err = U.inflate(this.strm, this.flush), this.err === g.Z_NEED_DICT && this.dictionary && (this.err = U.inflateSetDictionary(this.strm, this.dictionary), this.err === g.Z_OK ? this.err = U.inflate(this.strm, this.flush) : this.err === g.Z_DATA_ERROR && (this.err = g.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === g.GUNZIP && this.err === g.Z_STREAM_END && this.strm.next_in[0] !== 0; ) this.reset(), this.err = U.inflate(this.strm, this.flush);
            break;
          default:
            throw new Error("Unknown mode " + this.mode);
        }
      }, Q.prototype._checkError = function() {
        switch (this.err) {
          case g.Z_OK:
          case g.Z_BUF_ERROR:
            if (this.strm.avail_out !== 0 && this.flush === g.Z_FINISH) return this._error("unexpected end of file"), !1;
            break;
          case g.Z_STREAM_END:
            break;
          case g.Z_NEED_DICT:
            return this.dictionary == null ? this._error("Missing dictionary") : this._error("Bad dictionary"), !1;
          default:
            return this._error("Zlib error"), !1;
        }
        return !0;
      }, Q.prototype._after = function() {
        if (this._checkError()) {
          var H = this.strm.avail_out, W = this.strm.avail_in;
          this.write_in_progress = !1, this.callback(W, H), this.pending_close && this.close();
        }
      }, Q.prototype._error = function(H) {
        this.strm.msg && (H = this.strm.msg), this.onerror(H, this.err), this.write_in_progress = !1, this.pending_close && this.close();
      }, Q.prototype.init = function(H, W, q, et, rt) {
        P(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])"), P(H >= 8 && H <= 15, "invalid windowBits"), P(W >= -1 && W <= 9, "invalid compression level"), P(q >= 1 && q <= 9, "invalid memlevel"), P(et === g.Z_FILTERED || et === g.Z_HUFFMAN_ONLY || et === g.Z_RLE || et === g.Z_FIXED || et === g.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(W, H, q, et, rt), this._setDictionary();
      }, Q.prototype.params = function() {
        throw new Error("deflateParams Not supported");
      }, Q.prototype.reset = function() {
        this._reset(), this._setDictionary();
      }, Q.prototype._init = function(H, W, q, et, rt) {
        switch (this.level = H, this.windowBits = W, this.memLevel = q, this.strategy = et, this.flush = g.Z_NO_FLUSH, this.err = g.Z_OK, this.mode !== g.GZIP && this.mode !== g.GUNZIP || (this.windowBits += 16), this.mode === g.UNZIP && (this.windowBits += 32), this.mode !== g.DEFLATERAW && this.mode !== g.INFLATERAW || (this.windowBits = -1 * this.windowBits), this.strm = new F(), this.mode) {
          case g.DEFLATE:
          case g.GZIP:
          case g.DEFLATERAW:
            this.err = D.deflateInit2(this.strm, this.level, g.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
            break;
          case g.INFLATE:
          case g.GUNZIP:
          case g.INFLATERAW:
          case g.UNZIP:
            this.err = U.inflateInit2(this.strm, this.windowBits);
            break;
          default:
            throw new Error("Unknown mode " + this.mode);
        }
        this.err !== g.Z_OK && this._error("Init error"), this.dictionary = rt, this.write_in_progress = !1, this.init_done = !0;
      }, Q.prototype._setDictionary = function() {
        if (this.dictionary != null) {
          switch (this.err = g.Z_OK, this.mode) {
            case g.DEFLATE:
            case g.DEFLATERAW:
              this.err = D.deflateSetDictionary(this.strm, this.dictionary);
          }
          this.err !== g.Z_OK && this._error("Failed to set dictionary");
        }
      }, Q.prototype._reset = function() {
        switch (this.err = g.Z_OK, this.mode) {
          case g.DEFLATE:
          case g.DEFLATERAW:
          case g.GZIP:
            this.err = D.deflateReset(this.strm);
            break;
          case g.INFLATE:
          case g.INFLATERAW:
          case g.GUNZIP:
            this.err = U.inflateReset(this.strm);
        }
        this.err !== g.Z_OK && this._error("Failed to reset stream");
      }, g.Zlib = Q;
    }).call(this);
  }).call(this, d("_process"), d("buffer").Buffer);
}, { _process: 63, assert: 23, buffer: 32, "pako/lib/zlib/constants": 54, "pako/lib/zlib/deflate.js": 56, "pako/lib/zlib/inflate.js": 58, "pako/lib/zlib/zstream": 62 }], 31: [function(d, m, g) {
  (function(w) {
    (function() {
      var I = d("buffer").Buffer, P = d("stream").Transform, F = d("./binding"), D = d("util"), U = d("assert").ok, Z = d("buffer").kMaxLength, $ = "Cannot create final Buffer. It would be larger than 0x" + Z.toString(16) + " bytes";
      F.Z_MIN_WINDOWBITS = 8, F.Z_MAX_WINDOWBITS = 15, F.Z_DEFAULT_WINDOWBITS = 15, F.Z_MIN_CHUNK = 64, F.Z_MAX_CHUNK = 1 / 0, F.Z_DEFAULT_CHUNK = 16384, F.Z_MIN_MEMLEVEL = 1, F.Z_MAX_MEMLEVEL = 9, F.Z_DEFAULT_MEMLEVEL = 8, F.Z_MIN_LEVEL = -1, F.Z_MAX_LEVEL = 9, F.Z_DEFAULT_LEVEL = F.Z_DEFAULT_COMPRESSION;
      for (var j = Object.keys(F), G = 0; G < j.length; G++) {
        var Q = j[G];
        Q.match(/^Z/) && Object.defineProperty(g, Q, { enumerable: !0, value: F[Q], writable: !1 });
      }
      for (var H = { Z_OK: F.Z_OK, Z_STREAM_END: F.Z_STREAM_END, Z_NEED_DICT: F.Z_NEED_DICT, Z_ERRNO: F.Z_ERRNO, Z_STREAM_ERROR: F.Z_STREAM_ERROR, Z_DATA_ERROR: F.Z_DATA_ERROR, Z_MEM_ERROR: F.Z_MEM_ERROR, Z_BUF_ERROR: F.Z_BUF_ERROR, Z_VERSION_ERROR: F.Z_VERSION_ERROR }, W = Object.keys(H), q = 0; q < W.length; q++) {
        var et = W[q];
        H[H[et]] = et;
      }
      function rt(ht, pt, Ct) {
        var St = [], At = 0;
        function Ft() {
          for (var Ot; (Ot = ht.read()) !== null; ) St.push(Ot), At += Ot.length;
          ht.once("readable", Ft);
        }
        function xt(Ot) {
          ht.removeListener("end", Pt), ht.removeListener("readable", Ft), Ct(Ot);
        }
        function Pt() {
          var Ot, Bt = null;
          At >= Z ? Bt = new RangeError($) : Ot = I.concat(St, At), St = [], ht.close(), Ct(Bt, Ot);
        }
        ht.on("error", xt), ht.on("end", Pt), ht.end(pt), Ft();
      }
      function tt(ht, pt) {
        if (typeof pt == "string" && (pt = I.from(pt)), !I.isBuffer(pt)) throw new TypeError("Not a string or buffer");
        var Ct = ht._finishFlushFlag;
        return ht._processChunk(pt, Ct);
      }
      function V(ht) {
        if (!(this instanceof V)) return new V(ht);
        lt.call(this, ht, F.DEFLATE);
      }
      function X(ht) {
        if (!(this instanceof X)) return new X(ht);
        lt.call(this, ht, F.INFLATE);
      }
      function ot(ht) {
        if (!(this instanceof ot)) return new ot(ht);
        lt.call(this, ht, F.GZIP);
      }
      function it(ht) {
        if (!(this instanceof it)) return new it(ht);
        lt.call(this, ht, F.GUNZIP);
      }
      function st(ht) {
        if (!(this instanceof st)) return new st(ht);
        lt.call(this, ht, F.DEFLATERAW);
      }
      function at(ht) {
        if (!(this instanceof at)) return new at(ht);
        lt.call(this, ht, F.INFLATERAW);
      }
      function ct(ht) {
        if (!(this instanceof ct)) return new ct(ht);
        lt.call(this, ht, F.UNZIP);
      }
      function K(ht) {
        return ht === F.Z_NO_FLUSH || ht === F.Z_PARTIAL_FLUSH || ht === F.Z_SYNC_FLUSH || ht === F.Z_FULL_FLUSH || ht === F.Z_FINISH || ht === F.Z_BLOCK;
      }
      function lt(ht, pt) {
        var Ct = this;
        if (this._opts = ht = ht || {}, this._chunkSize = ht.chunkSize || g.Z_DEFAULT_CHUNK, P.call(this, ht), ht.flush && !K(ht.flush)) throw new Error("Invalid flush flag: " + ht.flush);
        if (ht.finishFlush && !K(ht.finishFlush)) throw new Error("Invalid flush flag: " + ht.finishFlush);
        if (this._flushFlag = ht.flush || F.Z_NO_FLUSH, this._finishFlushFlag = ht.finishFlush !== void 0 ? ht.finishFlush : F.Z_FINISH, ht.chunkSize && (ht.chunkSize < g.Z_MIN_CHUNK || ht.chunkSize > g.Z_MAX_CHUNK)) throw new Error("Invalid chunk size: " + ht.chunkSize);
        if (ht.windowBits && (ht.windowBits < g.Z_MIN_WINDOWBITS || ht.windowBits > g.Z_MAX_WINDOWBITS)) throw new Error("Invalid windowBits: " + ht.windowBits);
        if (ht.level && (ht.level < g.Z_MIN_LEVEL || ht.level > g.Z_MAX_LEVEL)) throw new Error("Invalid compression level: " + ht.level);
        if (ht.memLevel && (ht.memLevel < g.Z_MIN_MEMLEVEL || ht.memLevel > g.Z_MAX_MEMLEVEL)) throw new Error("Invalid memLevel: " + ht.memLevel);
        if (ht.strategy && ht.strategy != g.Z_FILTERED && ht.strategy != g.Z_HUFFMAN_ONLY && ht.strategy != g.Z_RLE && ht.strategy != g.Z_FIXED && ht.strategy != g.Z_DEFAULT_STRATEGY) throw new Error("Invalid strategy: " + ht.strategy);
        if (ht.dictionary && !I.isBuffer(ht.dictionary)) throw new Error("Invalid dictionary: it should be a Buffer instance");
        this._handle = new F.Zlib(pt);
        var St = this;
        this._hadError = !1, this._handle.onerror = function(xt, Pt) {
          vt(St), St._hadError = !0;
          var Ot = new Error(xt);
          Ot.errno = Pt, Ot.code = g.codes[Pt], St.emit("error", Ot);
        };
        var At = g.Z_DEFAULT_COMPRESSION;
        typeof ht.level == "number" && (At = ht.level);
        var Ft = g.Z_DEFAULT_STRATEGY;
        typeof ht.strategy == "number" && (Ft = ht.strategy), this._handle.init(ht.windowBits || g.Z_DEFAULT_WINDOWBITS, At, ht.memLevel || g.Z_DEFAULT_MEMLEVEL, Ft, ht.dictionary), this._buffer = I.allocUnsafe(this._chunkSize), this._offset = 0, this._level = At, this._strategy = Ft, this.once("end", this.close), Object.defineProperty(this, "_closed", { get: function() {
          return !Ct._handle;
        }, configurable: !0, enumerable: !0 });
      }
      function vt(ht, pt) {
        pt && w.nextTick(pt), ht._handle && (ht._handle.close(), ht._handle = null);
      }
      function dt(ht) {
        ht.emit("close");
      }
      Object.defineProperty(g, "codes", { enumerable: !0, value: Object.freeze(H), writable: !1 }), g.Deflate = V, g.Inflate = X, g.Gzip = ot, g.Gunzip = it, g.DeflateRaw = st, g.InflateRaw = at, g.Unzip = ct, g.createDeflate = function(ht) {
        return new V(ht);
      }, g.createInflate = function(ht) {
        return new X(ht);
      }, g.createDeflateRaw = function(ht) {
        return new st(ht);
      }, g.createInflateRaw = function(ht) {
        return new at(ht);
      }, g.createGzip = function(ht) {
        return new ot(ht);
      }, g.createGunzip = function(ht) {
        return new it(ht);
      }, g.createUnzip = function(ht) {
        return new ct(ht);
      }, g.deflate = function(ht, pt, Ct) {
        return typeof pt == "function" && (Ct = pt, pt = {}), rt(new V(pt), ht, Ct);
      }, g.deflateSync = function(ht, pt) {
        return tt(new V(pt), ht);
      }, g.gzip = function(ht, pt, Ct) {
        return typeof pt == "function" && (Ct = pt, pt = {}), rt(new ot(pt), ht, Ct);
      }, g.gzipSync = function(ht, pt) {
        return tt(new ot(pt), ht);
      }, g.deflateRaw = function(ht, pt, Ct) {
        return typeof pt == "function" && (Ct = pt, pt = {}), rt(new st(pt), ht, Ct);
      }, g.deflateRawSync = function(ht, pt) {
        return tt(new st(pt), ht);
      }, g.unzip = function(ht, pt, Ct) {
        return typeof pt == "function" && (Ct = pt, pt = {}), rt(new ct(pt), ht, Ct);
      }, g.unzipSync = function(ht, pt) {
        return tt(new ct(pt), ht);
      }, g.inflate = function(ht, pt, Ct) {
        return typeof pt == "function" && (Ct = pt, pt = {}), rt(new X(pt), ht, Ct);
      }, g.inflateSync = function(ht, pt) {
        return tt(new X(pt), ht);
      }, g.gunzip = function(ht, pt, Ct) {
        return typeof pt == "function" && (Ct = pt, pt = {}), rt(new it(pt), ht, Ct);
      }, g.gunzipSync = function(ht, pt) {
        return tt(new it(pt), ht);
      }, g.inflateRaw = function(ht, pt, Ct) {
        return typeof pt == "function" && (Ct = pt, pt = {}), rt(new at(pt), ht, Ct);
      }, g.inflateRawSync = function(ht, pt) {
        return tt(new at(pt), ht);
      }, D.inherits(lt, P), lt.prototype.params = function(ht, pt, Ct) {
        if (ht < g.Z_MIN_LEVEL || ht > g.Z_MAX_LEVEL) throw new RangeError("Invalid compression level: " + ht);
        if (pt != g.Z_FILTERED && pt != g.Z_HUFFMAN_ONLY && pt != g.Z_RLE && pt != g.Z_FIXED && pt != g.Z_DEFAULT_STRATEGY) throw new TypeError("Invalid strategy: " + pt);
        if (this._level !== ht || this._strategy !== pt) {
          var St = this;
          this.flush(F.Z_SYNC_FLUSH, function() {
            U(St._handle, "zlib binding closed"), St._handle.params(ht, pt), St._hadError || (St._level = ht, St._strategy = pt, Ct && Ct());
          });
        } else w.nextTick(Ct);
      }, lt.prototype.reset = function() {
        return U(this._handle, "zlib binding closed"), this._handle.reset();
      }, lt.prototype._flush = function(ht) {
        this._transform(I.alloc(0), "", ht);
      }, lt.prototype.flush = function(ht, pt) {
        var Ct = this, St = this._writableState;
        (typeof ht == "function" || ht === void 0 && !pt) && (pt = ht, ht = F.Z_FULL_FLUSH), St.ended ? pt && w.nextTick(pt) : St.ending ? pt && this.once("end", pt) : St.needDrain ? pt && this.once("drain", function() {
          return Ct.flush(ht, pt);
        }) : (this._flushFlag = ht, this.write(I.alloc(0), "", pt));
      }, lt.prototype.close = function(ht) {
        vt(this, ht), w.nextTick(dt, this);
      }, lt.prototype._transform = function(ht, pt, Ct) {
        var St, At = this._writableState, Ft = (At.ending || At.ended) && (!ht || At.length === ht.length);
        return ht === null || I.isBuffer(ht) ? this._handle ? (Ft ? St = this._finishFlushFlag : (St = this._flushFlag, ht.length >= At.length && (this._flushFlag = this._opts.flush || F.Z_NO_FLUSH)), void this._processChunk(ht, St, Ct)) : Ct(new Error("zlib binding closed")) : Ct(new Error("invalid input"));
      }, lt.prototype._processChunk = function(ht, pt, Ct) {
        var St = ht && ht.length, At = this._chunkSize - this._offset, Ft = 0, xt = this, Pt = typeof Ct == "function";
        if (!Pt) {
          var Ot, Bt = [], kt = 0;
          this.on("error", function(Mt) {
            Ot = Mt;
          }), U(this._handle, "zlib binding closed");
          do
            var Tt = this._handle.writeSync(pt, ht, Ft, St, this._buffer, this._offset, At);
          while (!this._hadError && $t(Tt[0], Tt[1]));
          if (this._hadError) throw Ot;
          if (kt >= Z) throw vt(this), new RangeError($);
          var Dt = I.concat(Bt, kt);
          return vt(this), Dt;
        }
        U(this._handle, "zlib binding closed");
        var Zt = this._handle.write(pt, ht, Ft, St, this._buffer, this._offset, At);
        function $t(Mt, nt) {
          if (this && (this.buffer = null, this.callback = null), !xt._hadError) {
            var It = At - nt;
            if (U(It >= 0, "have should not go down"), It > 0) {
              var mt = xt._buffer.slice(xt._offset, xt._offset + It);
              xt._offset += It, Pt ? xt.push(mt) : (Bt.push(mt), kt += mt.length);
            }
            if ((nt === 0 || xt._offset >= xt._chunkSize) && (At = xt._chunkSize, xt._offset = 0, xt._buffer = I.allocUnsafe(xt._chunkSize)), nt === 0) {
              if (Ft += St - Mt, St = Mt, !Pt) return !0;
              var gt = xt._handle.write(pt, ht, Ft, St, xt._buffer, xt._offset, xt._chunkSize);
              return gt.callback = $t, void (gt.buffer = ht);
            }
            if (!Pt) return !1;
            Ct();
          }
        }
        Zt.buffer = ht, Zt.callback = $t;
      }, D.inherits(V, lt), D.inherits(X, lt), D.inherits(ot, lt), D.inherits(it, lt), D.inherits(st, lt), D.inherits(at, lt), D.inherits(ct, lt);
    }).call(this);
  }).call(this, d("_process"));
}, { "./binding": 30, _process: 63, assert: 23, buffer: 32, stream: 65, util: 84 }], 32: [function(d, m, g) {
  (function(w) {
    (function() {
      var I = d("base64-js"), P = d("ieee754");
      g.Buffer = Z, g.SlowBuffer = tt, g.INSPECT_MAX_BYTES = 50;
      var F = 2147483647;
      function D() {
        try {
          var J = new Uint8Array(1);
          return J.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
            return 42;
          } }, J.foo() === 42;
        } catch {
          return !1;
        }
      }
      function U(J) {
        if (J > F) throw new RangeError('The value "' + J + '" is invalid for option "size"');
        var ut = new Uint8Array(J);
        return ut.__proto__ = Z.prototype, ut;
      }
      function Z(J, ut, bt) {
        if (typeof J == "number") {
          if (typeof ut == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
          return Q(J);
        }
        return $(J, ut, bt);
      }
      function $(J, ut, bt) {
        if (typeof J == "string") return H(J, ut);
        if (ArrayBuffer.isView(J)) return W(J);
        if (J == null) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof J);
        if (wt(J, ArrayBuffer) || J && wt(J.buffer, ArrayBuffer)) return q(J, ut, bt);
        if (typeof J == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        var yt = J.valueOf && J.valueOf();
        if (yt != null && yt !== J) return Z.from(yt, ut, bt);
        var Lt = et(J);
        if (Lt) return Lt;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof J[Symbol.toPrimitive] == "function") return Z.from(J[Symbol.toPrimitive]("string"), ut, bt);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof J);
      }
      function j(J) {
        if (typeof J != "number") throw new TypeError('"size" argument must be of type number');
        if (J < 0) throw new RangeError('The value "' + J + '" is invalid for option "size"');
      }
      function G(J, ut, bt) {
        return j(J), J <= 0 ? U(J) : ut !== void 0 ? typeof bt == "string" ? U(J).fill(ut, bt) : U(J).fill(ut) : U(J);
      }
      function Q(J) {
        return j(J), U(J < 0 ? 0 : 0 | rt(J));
      }
      function H(J, ut) {
        if (typeof ut == "string" && ut !== "" || (ut = "utf8"), !Z.isEncoding(ut)) throw new TypeError("Unknown encoding: " + ut);
        var bt = 0 | V(J, ut), yt = U(bt), Lt = yt.write(J, ut);
        return Lt !== bt && (yt = yt.slice(0, Lt)), yt;
      }
      function W(J) {
        for (var ut = J.length < 0 ? 0 : 0 | rt(J.length), bt = U(ut), yt = 0; yt < ut; yt += 1) bt[yt] = 255 & J[yt];
        return bt;
      }
      function q(J, ut, bt) {
        if (ut < 0 || J.byteLength < ut) throw new RangeError('"offset" is outside of buffer bounds');
        if (J.byteLength < ut + (bt || 0)) throw new RangeError('"length" is outside of buffer bounds');
        var yt;
        return (yt = ut === void 0 && bt === void 0 ? new Uint8Array(J) : bt === void 0 ? new Uint8Array(J, ut) : new Uint8Array(J, ut, bt)).__proto__ = Z.prototype, yt;
      }
      function et(J) {
        if (Z.isBuffer(J)) {
          var ut = 0 | rt(J.length), bt = U(ut);
          return bt.length === 0 || J.copy(bt, 0, 0, ut), bt;
        }
        return J.length !== void 0 ? typeof J.length != "number" || Rt(J.length) ? U(0) : W(J) : J.type === "Buffer" && Array.isArray(J.data) ? W(J.data) : void 0;
      }
      function rt(J) {
        if (J >= F) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + F.toString(16) + " bytes");
        return 0 | J;
      }
      function tt(J) {
        return +J != J && (J = 0), Z.alloc(+J);
      }
      function V(J, ut) {
        if (Z.isBuffer(J)) return J.length;
        if (ArrayBuffer.isView(J) || wt(J, ArrayBuffer)) return J.byteLength;
        if (typeof J != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof J);
        var bt = J.length, yt = arguments.length > 2 && arguments[2] === !0;
        if (!yt && bt === 0) return 0;
        for (var Lt = !1; ; ) switch (ut) {
          case "ascii":
          case "latin1":
          case "binary":
            return bt;
          case "utf8":
          case "utf-8":
            return nt(J).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return 2 * bt;
          case "hex":
            return bt >>> 1;
          case "base64":
            return gt(J).length;
          default:
            if (Lt) return yt ? -1 : nt(J).length;
            ut = ("" + ut).toLowerCase(), Lt = !0;
        }
      }
      function X(J, ut, bt) {
        var yt = !1;
        if ((ut === void 0 || ut < 0) && (ut = 0), ut > this.length || ((bt === void 0 || bt > this.length) && (bt = this.length), bt <= 0) || (bt >>>= 0) <= (ut >>>= 0)) return "";
        for (J || (J = "utf8"); ; ) switch (J) {
          case "hex":
            return xt(this, ut, bt);
          case "utf8":
          case "utf-8":
            return pt(this, ut, bt);
          case "ascii":
            return At(this, ut, bt);
          case "latin1":
          case "binary":
            return Ft(this, ut, bt);
          case "base64":
            return ht(this, ut, bt);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Pt(this, ut, bt);
          default:
            if (yt) throw new TypeError("Unknown encoding: " + J);
            J = (J + "").toLowerCase(), yt = !0;
        }
      }
      function ot(J, ut, bt) {
        var yt = J[ut];
        J[ut] = J[bt], J[bt] = yt;
      }
      function it(J, ut, bt, yt, Lt) {
        if (J.length === 0) return -1;
        if (typeof bt == "string" ? (yt = bt, bt = 0) : bt > 2147483647 ? bt = 2147483647 : bt < -2147483648 && (bt = -2147483648), Rt(bt = +bt) && (bt = Lt ? 0 : J.length - 1), bt < 0 && (bt = J.length + bt), bt >= J.length) {
          if (Lt) return -1;
          bt = J.length - 1;
        } else if (bt < 0) {
          if (!Lt) return -1;
          bt = 0;
        }
        if (typeof ut == "string" && (ut = Z.from(ut, yt)), Z.isBuffer(ut)) return ut.length === 0 ? -1 : st(J, ut, bt, yt, Lt);
        if (typeof ut == "number") return ut &= 255, typeof Uint8Array.prototype.indexOf == "function" ? Lt ? Uint8Array.prototype.indexOf.call(J, ut, bt) : Uint8Array.prototype.lastIndexOf.call(J, ut, bt) : st(J, [ut], bt, yt, Lt);
        throw new TypeError("val must be string, number or Buffer");
      }
      function st(J, ut, bt, yt, Lt) {
        var jt, Kt = 1, te = J.length, Vt = ut.length;
        if (yt !== void 0 && ((yt = String(yt).toLowerCase()) === "ucs2" || yt === "ucs-2" || yt === "utf16le" || yt === "utf-16le")) {
          if (J.length < 2 || ut.length < 2) return -1;
          Kt = 2, te /= 2, Vt /= 2, bt /= 2;
        }
        function ee(se, fe) {
          return Kt === 1 ? se[fe] : se.readUInt16BE(fe * Kt);
        }
        if (Lt) {
          var Jt = -1;
          for (jt = bt; jt < te; jt++) if (ee(J, jt) === ee(ut, Jt === -1 ? 0 : jt - Jt)) {
            if (Jt === -1 && (Jt = jt), jt - Jt + 1 === Vt) return Jt * Kt;
          } else Jt !== -1 && (jt -= jt - Jt), Jt = -1;
        } else for (bt + Vt > te && (bt = te - Vt), jt = bt; jt >= 0; jt--) {
          for (var le = !0, ae = 0; ae < Vt; ae++) if (ee(J, jt + ae) !== ee(ut, ae)) {
            le = !1;
            break;
          }
          if (le) return jt;
        }
        return -1;
      }
      function at(J, ut, bt, yt) {
        bt = Number(bt) || 0;
        var Lt = J.length - bt;
        yt ? (yt = Number(yt)) > Lt && (yt = Lt) : yt = Lt;
        var jt = ut.length;
        yt > jt / 2 && (yt = jt / 2);
        for (var Kt = 0; Kt < yt; ++Kt) {
          var te = parseInt(ut.substr(2 * Kt, 2), 16);
          if (Rt(te)) return Kt;
          J[bt + Kt] = te;
        }
        return Kt;
      }
      function ct(J, ut, bt, yt) {
        return _t(nt(ut, J.length - bt), J, bt, yt);
      }
      function K(J, ut, bt, yt) {
        return _t(It(ut), J, bt, yt);
      }
      function lt(J, ut, bt, yt) {
        return K(J, ut, bt, yt);
      }
      function vt(J, ut, bt, yt) {
        return _t(gt(ut), J, bt, yt);
      }
      function dt(J, ut, bt, yt) {
        return _t(mt(ut, J.length - bt), J, bt, yt);
      }
      function ht(J, ut, bt) {
        return ut === 0 && bt === J.length ? I.fromByteArray(J) : I.fromByteArray(J.slice(ut, bt));
      }
      function pt(J, ut, bt) {
        bt = Math.min(J.length, bt);
        for (var yt = [], Lt = ut; Lt < bt; ) {
          var jt, Kt, te, Vt, ee = J[Lt], Jt = null, le = ee > 239 ? 4 : ee > 223 ? 3 : ee > 191 ? 2 : 1;
          if (Lt + le <= bt) switch (le) {
            case 1:
              ee < 128 && (Jt = ee);
              break;
            case 2:
              (192 & (jt = J[Lt + 1])) == 128 && (Vt = (31 & ee) << 6 | 63 & jt) > 127 && (Jt = Vt);
              break;
            case 3:
              jt = J[Lt + 1], Kt = J[Lt + 2], (192 & jt) == 128 && (192 & Kt) == 128 && (Vt = (15 & ee) << 12 | (63 & jt) << 6 | 63 & Kt) > 2047 && (Vt < 55296 || Vt > 57343) && (Jt = Vt);
              break;
            case 4:
              jt = J[Lt + 1], Kt = J[Lt + 2], te = J[Lt + 3], (192 & jt) == 128 && (192 & Kt) == 128 && (192 & te) == 128 && (Vt = (15 & ee) << 18 | (63 & jt) << 12 | (63 & Kt) << 6 | 63 & te) > 65535 && Vt < 1114112 && (Jt = Vt);
          }
          Jt === null ? (Jt = 65533, le = 1) : Jt > 65535 && (Jt -= 65536, yt.push(Jt >>> 10 & 1023 | 55296), Jt = 56320 | 1023 & Jt), yt.push(Jt), Lt += le;
        }
        return St(yt);
      }
      g.kMaxLength = F, Z.TYPED_ARRAY_SUPPORT = D(), Z.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(Z.prototype, "parent", { enumerable: !0, get: function() {
        if (Z.isBuffer(this)) return this.buffer;
      } }), Object.defineProperty(Z.prototype, "offset", { enumerable: !0, get: function() {
        if (Z.isBuffer(this)) return this.byteOffset;
      } }), typeof Symbol < "u" && Symbol.species != null && Z[Symbol.species] === Z && Object.defineProperty(Z, Symbol.species, { value: null, configurable: !0, enumerable: !1, writable: !1 }), Z.poolSize = 8192, Z.from = function(J, ut, bt) {
        return $(J, ut, bt);
      }, Z.prototype.__proto__ = Uint8Array.prototype, Z.__proto__ = Uint8Array, Z.alloc = function(J, ut, bt) {
        return G(J, ut, bt);
      }, Z.allocUnsafe = function(J) {
        return Q(J);
      }, Z.allocUnsafeSlow = function(J) {
        return Q(J);
      }, Z.isBuffer = function(J) {
        return J != null && J._isBuffer === !0 && J !== Z.prototype;
      }, Z.compare = function(J, ut) {
        if (wt(J, Uint8Array) && (J = Z.from(J, J.offset, J.byteLength)), wt(ut, Uint8Array) && (ut = Z.from(ut, ut.offset, ut.byteLength)), !Z.isBuffer(J) || !Z.isBuffer(ut)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (J === ut) return 0;
        for (var bt = J.length, yt = ut.length, Lt = 0, jt = Math.min(bt, yt); Lt < jt; ++Lt) if (J[Lt] !== ut[Lt]) {
          bt = J[Lt], yt = ut[Lt];
          break;
        }
        return bt < yt ? -1 : yt < bt ? 1 : 0;
      }, Z.isEncoding = function(J) {
        switch (String(J).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return !0;
          default:
            return !1;
        }
      }, Z.concat = function(J, ut) {
        if (!Array.isArray(J)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (J.length === 0) return Z.alloc(0);
        var bt;
        if (ut === void 0) for (ut = 0, bt = 0; bt < J.length; ++bt) ut += J[bt].length;
        var yt = Z.allocUnsafe(ut), Lt = 0;
        for (bt = 0; bt < J.length; ++bt) {
          var jt = J[bt];
          if (wt(jt, Uint8Array) && (jt = Z.from(jt)), !Z.isBuffer(jt)) throw new TypeError('"list" argument must be an Array of Buffers');
          jt.copy(yt, Lt), Lt += jt.length;
        }
        return yt;
      }, Z.byteLength = V, Z.prototype._isBuffer = !0, Z.prototype.swap16 = function() {
        var J = this.length;
        if (J % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (var ut = 0; ut < J; ut += 2) ot(this, ut, ut + 1);
        return this;
      }, Z.prototype.swap32 = function() {
        var J = this.length;
        if (J % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (var ut = 0; ut < J; ut += 4) ot(this, ut, ut + 3), ot(this, ut + 1, ut + 2);
        return this;
      }, Z.prototype.swap64 = function() {
        var J = this.length;
        if (J % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (var ut = 0; ut < J; ut += 8) ot(this, ut, ut + 7), ot(this, ut + 1, ut + 6), ot(this, ut + 2, ut + 5), ot(this, ut + 3, ut + 4);
        return this;
      }, Z.prototype.toString = function() {
        var J = this.length;
        return J === 0 ? "" : arguments.length === 0 ? pt(this, 0, J) : X.apply(this, arguments);
      }, Z.prototype.toLocaleString = Z.prototype.toString, Z.prototype.equals = function(J) {
        if (!Z.isBuffer(J)) throw new TypeError("Argument must be a Buffer");
        return this === J || Z.compare(this, J) === 0;
      }, Z.prototype.inspect = function() {
        var J = "", ut = g.INSPECT_MAX_BYTES;
        return J = this.toString("hex", 0, ut).replace(/(.{2})/g, "$1 ").trim(), this.length > ut && (J += " ... "), "<Buffer " + J + ">";
      }, Z.prototype.compare = function(J, ut, bt, yt, Lt) {
        if (wt(J, Uint8Array) && (J = Z.from(J, J.offset, J.byteLength)), !Z.isBuffer(J)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof J);
        if (ut === void 0 && (ut = 0), bt === void 0 && (bt = J ? J.length : 0), yt === void 0 && (yt = 0), Lt === void 0 && (Lt = this.length), ut < 0 || bt > J.length || yt < 0 || Lt > this.length) throw new RangeError("out of range index");
        if (yt >= Lt && ut >= bt) return 0;
        if (yt >= Lt) return -1;
        if (ut >= bt) return 1;
        if (this === J) return 0;
        for (var jt = (Lt >>>= 0) - (yt >>>= 0), Kt = (bt >>>= 0) - (ut >>>= 0), te = Math.min(jt, Kt), Vt = this.slice(yt, Lt), ee = J.slice(ut, bt), Jt = 0; Jt < te; ++Jt) if (Vt[Jt] !== ee[Jt]) {
          jt = Vt[Jt], Kt = ee[Jt];
          break;
        }
        return jt < Kt ? -1 : Kt < jt ? 1 : 0;
      }, Z.prototype.includes = function(J, ut, bt) {
        return this.indexOf(J, ut, bt) !== -1;
      }, Z.prototype.indexOf = function(J, ut, bt) {
        return it(this, J, ut, bt, !0);
      }, Z.prototype.lastIndexOf = function(J, ut, bt) {
        return it(this, J, ut, bt, !1);
      }, Z.prototype.write = function(J, ut, bt, yt) {
        if (ut === void 0) yt = "utf8", bt = this.length, ut = 0;
        else if (bt === void 0 && typeof ut == "string") yt = ut, bt = this.length, ut = 0;
        else {
          if (!isFinite(ut)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          ut >>>= 0, isFinite(bt) ? (bt >>>= 0, yt === void 0 && (yt = "utf8")) : (yt = bt, bt = void 0);
        }
        var Lt = this.length - ut;
        if ((bt === void 0 || bt > Lt) && (bt = Lt), J.length > 0 && (bt < 0 || ut < 0) || ut > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        yt || (yt = "utf8");
        for (var jt = !1; ; ) switch (yt) {
          case "hex":
            return at(this, J, ut, bt);
          case "utf8":
          case "utf-8":
            return ct(this, J, ut, bt);
          case "ascii":
            return K(this, J, ut, bt);
          case "latin1":
          case "binary":
            return lt(this, J, ut, bt);
          case "base64":
            return vt(this, J, ut, bt);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return dt(this, J, ut, bt);
          default:
            if (jt) throw new TypeError("Unknown encoding: " + yt);
            yt = ("" + yt).toLowerCase(), jt = !0;
        }
      }, Z.prototype.toJSON = function() {
        return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
      };
      var Ct = 4096;
      function St(J) {
        var ut = J.length;
        if (ut <= Ct) return String.fromCharCode.apply(String, J);
        for (var bt = "", yt = 0; yt < ut; ) bt += String.fromCharCode.apply(String, J.slice(yt, yt += Ct));
        return bt;
      }
      function At(J, ut, bt) {
        var yt = "";
        bt = Math.min(J.length, bt);
        for (var Lt = ut; Lt < bt; ++Lt) yt += String.fromCharCode(127 & J[Lt]);
        return yt;
      }
      function Ft(J, ut, bt) {
        var yt = "";
        bt = Math.min(J.length, bt);
        for (var Lt = ut; Lt < bt; ++Lt) yt += String.fromCharCode(J[Lt]);
        return yt;
      }
      function xt(J, ut, bt) {
        var yt = J.length;
        (!ut || ut < 0) && (ut = 0), (!bt || bt < 0 || bt > yt) && (bt = yt);
        for (var Lt = "", jt = ut; jt < bt; ++jt) Lt += Mt(J[jt]);
        return Lt;
      }
      function Pt(J, ut, bt) {
        for (var yt = J.slice(ut, bt), Lt = "", jt = 0; jt < yt.length; jt += 2) Lt += String.fromCharCode(yt[jt] + 256 * yt[jt + 1]);
        return Lt;
      }
      function Ot(J, ut, bt) {
        if (J % 1 != 0 || J < 0) throw new RangeError("offset is not uint");
        if (J + ut > bt) throw new RangeError("Trying to access beyond buffer length");
      }
      function Bt(J, ut, bt, yt, Lt, jt) {
        if (!Z.isBuffer(J)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (ut > Lt || ut < jt) throw new RangeError('"value" argument is out of bounds');
        if (bt + yt > J.length) throw new RangeError("Index out of range");
      }
      function kt(J, ut, bt, yt, Lt, jt) {
        if (bt + yt > J.length) throw new RangeError("Index out of range");
        if (bt < 0) throw new RangeError("Index out of range");
      }
      function Tt(J, ut, bt, yt, Lt) {
        return ut = +ut, bt >>>= 0, Lt || kt(J, ut, bt, 4), P.write(J, ut, bt, yt, 23, 4), bt + 4;
      }
      function Dt(J, ut, bt, yt, Lt) {
        return ut = +ut, bt >>>= 0, Lt || kt(J, ut, bt, 8), P.write(J, ut, bt, yt, 52, 8), bt + 8;
      }
      Z.prototype.slice = function(J, ut) {
        var bt = this.length;
        (J = ~~J) < 0 ? (J += bt) < 0 && (J = 0) : J > bt && (J = bt), (ut = ut === void 0 ? bt : ~~ut) < 0 ? (ut += bt) < 0 && (ut = 0) : ut > bt && (ut = bt), ut < J && (ut = J);
        var yt = this.subarray(J, ut);
        return yt.__proto__ = Z.prototype, yt;
      }, Z.prototype.readUIntLE = function(J, ut, bt) {
        J >>>= 0, ut >>>= 0, bt || Ot(J, ut, this.length);
        for (var yt = this[J], Lt = 1, jt = 0; ++jt < ut && (Lt *= 256); ) yt += this[J + jt] * Lt;
        return yt;
      }, Z.prototype.readUIntBE = function(J, ut, bt) {
        J >>>= 0, ut >>>= 0, bt || Ot(J, ut, this.length);
        for (var yt = this[J + --ut], Lt = 1; ut > 0 && (Lt *= 256); ) yt += this[J + --ut] * Lt;
        return yt;
      }, Z.prototype.readUInt8 = function(J, ut) {
        return J >>>= 0, ut || Ot(J, 1, this.length), this[J];
      }, Z.prototype.readUInt16LE = function(J, ut) {
        return J >>>= 0, ut || Ot(J, 2, this.length), this[J] | this[J + 1] << 8;
      }, Z.prototype.readUInt16BE = function(J, ut) {
        return J >>>= 0, ut || Ot(J, 2, this.length), this[J] << 8 | this[J + 1];
      }, Z.prototype.readUInt32LE = function(J, ut) {
        return J >>>= 0, ut || Ot(J, 4, this.length), (this[J] | this[J + 1] << 8 | this[J + 2] << 16) + 16777216 * this[J + 3];
      }, Z.prototype.readUInt32BE = function(J, ut) {
        return J >>>= 0, ut || Ot(J, 4, this.length), 16777216 * this[J] + (this[J + 1] << 16 | this[J + 2] << 8 | this[J + 3]);
      }, Z.prototype.readIntLE = function(J, ut, bt) {
        J >>>= 0, ut >>>= 0, bt || Ot(J, ut, this.length);
        for (var yt = this[J], Lt = 1, jt = 0; ++jt < ut && (Lt *= 256); ) yt += this[J + jt] * Lt;
        return yt >= (Lt *= 128) && (yt -= Math.pow(2, 8 * ut)), yt;
      }, Z.prototype.readIntBE = function(J, ut, bt) {
        J >>>= 0, ut >>>= 0, bt || Ot(J, ut, this.length);
        for (var yt = ut, Lt = 1, jt = this[J + --yt]; yt > 0 && (Lt *= 256); ) jt += this[J + --yt] * Lt;
        return jt >= (Lt *= 128) && (jt -= Math.pow(2, 8 * ut)), jt;
      }, Z.prototype.readInt8 = function(J, ut) {
        return J >>>= 0, ut || Ot(J, 1, this.length), 128 & this[J] ? -1 * (255 - this[J] + 1) : this[J];
      }, Z.prototype.readInt16LE = function(J, ut) {
        J >>>= 0, ut || Ot(J, 2, this.length);
        var bt = this[J] | this[J + 1] << 8;
        return 32768 & bt ? 4294901760 | bt : bt;
      }, Z.prototype.readInt16BE = function(J, ut) {
        J >>>= 0, ut || Ot(J, 2, this.length);
        var bt = this[J + 1] | this[J] << 8;
        return 32768 & bt ? 4294901760 | bt : bt;
      }, Z.prototype.readInt32LE = function(J, ut) {
        return J >>>= 0, ut || Ot(J, 4, this.length), this[J] | this[J + 1] << 8 | this[J + 2] << 16 | this[J + 3] << 24;
      }, Z.prototype.readInt32BE = function(J, ut) {
        return J >>>= 0, ut || Ot(J, 4, this.length), this[J] << 24 | this[J + 1] << 16 | this[J + 2] << 8 | this[J + 3];
      }, Z.prototype.readFloatLE = function(J, ut) {
        return J >>>= 0, ut || Ot(J, 4, this.length), P.read(this, J, !0, 23, 4);
      }, Z.prototype.readFloatBE = function(J, ut) {
        return J >>>= 0, ut || Ot(J, 4, this.length), P.read(this, J, !1, 23, 4);
      }, Z.prototype.readDoubleLE = function(J, ut) {
        return J >>>= 0, ut || Ot(J, 8, this.length), P.read(this, J, !0, 52, 8);
      }, Z.prototype.readDoubleBE = function(J, ut) {
        return J >>>= 0, ut || Ot(J, 8, this.length), P.read(this, J, !1, 52, 8);
      }, Z.prototype.writeUIntLE = function(J, ut, bt, yt) {
        J = +J, ut >>>= 0, bt >>>= 0, yt || Bt(this, J, ut, bt, Math.pow(2, 8 * bt) - 1, 0);
        var Lt = 1, jt = 0;
        for (this[ut] = 255 & J; ++jt < bt && (Lt *= 256); ) this[ut + jt] = J / Lt & 255;
        return ut + bt;
      }, Z.prototype.writeUIntBE = function(J, ut, bt, yt) {
        J = +J, ut >>>= 0, bt >>>= 0, yt || Bt(this, J, ut, bt, Math.pow(2, 8 * bt) - 1, 0);
        var Lt = bt - 1, jt = 1;
        for (this[ut + Lt] = 255 & J; --Lt >= 0 && (jt *= 256); ) this[ut + Lt] = J / jt & 255;
        return ut + bt;
      }, Z.prototype.writeUInt8 = function(J, ut, bt) {
        return J = +J, ut >>>= 0, bt || Bt(this, J, ut, 1, 255, 0), this[ut] = 255 & J, ut + 1;
      }, Z.prototype.writeUInt16LE = function(J, ut, bt) {
        return J = +J, ut >>>= 0, bt || Bt(this, J, ut, 2, 65535, 0), this[ut] = 255 & J, this[ut + 1] = J >>> 8, ut + 2;
      }, Z.prototype.writeUInt16BE = function(J, ut, bt) {
        return J = +J, ut >>>= 0, bt || Bt(this, J, ut, 2, 65535, 0), this[ut] = J >>> 8, this[ut + 1] = 255 & J, ut + 2;
      }, Z.prototype.writeUInt32LE = function(J, ut, bt) {
        return J = +J, ut >>>= 0, bt || Bt(this, J, ut, 4, 4294967295, 0), this[ut + 3] = J >>> 24, this[ut + 2] = J >>> 16, this[ut + 1] = J >>> 8, this[ut] = 255 & J, ut + 4;
      }, Z.prototype.writeUInt32BE = function(J, ut, bt) {
        return J = +J, ut >>>= 0, bt || Bt(this, J, ut, 4, 4294967295, 0), this[ut] = J >>> 24, this[ut + 1] = J >>> 16, this[ut + 2] = J >>> 8, this[ut + 3] = 255 & J, ut + 4;
      }, Z.prototype.writeIntLE = function(J, ut, bt, yt) {
        if (J = +J, ut >>>= 0, !yt) {
          var Lt = Math.pow(2, 8 * bt - 1);
          Bt(this, J, ut, bt, Lt - 1, -Lt);
        }
        var jt = 0, Kt = 1, te = 0;
        for (this[ut] = 255 & J; ++jt < bt && (Kt *= 256); ) J < 0 && te === 0 && this[ut + jt - 1] !== 0 && (te = 1), this[ut + jt] = (J / Kt | 0) - te & 255;
        return ut + bt;
      }, Z.prototype.writeIntBE = function(J, ut, bt, yt) {
        if (J = +J, ut >>>= 0, !yt) {
          var Lt = Math.pow(2, 8 * bt - 1);
          Bt(this, J, ut, bt, Lt - 1, -Lt);
        }
        var jt = bt - 1, Kt = 1, te = 0;
        for (this[ut + jt] = 255 & J; --jt >= 0 && (Kt *= 256); ) J < 0 && te === 0 && this[ut + jt + 1] !== 0 && (te = 1), this[ut + jt] = (J / Kt | 0) - te & 255;
        return ut + bt;
      }, Z.prototype.writeInt8 = function(J, ut, bt) {
        return J = +J, ut >>>= 0, bt || Bt(this, J, ut, 1, 127, -128), J < 0 && (J = 255 + J + 1), this[ut] = 255 & J, ut + 1;
      }, Z.prototype.writeInt16LE = function(J, ut, bt) {
        return J = +J, ut >>>= 0, bt || Bt(this, J, ut, 2, 32767, -32768), this[ut] = 255 & J, this[ut + 1] = J >>> 8, ut + 2;
      }, Z.prototype.writeInt16BE = function(J, ut, bt) {
        return J = +J, ut >>>= 0, bt || Bt(this, J, ut, 2, 32767, -32768), this[ut] = J >>> 8, this[ut + 1] = 255 & J, ut + 2;
      }, Z.prototype.writeInt32LE = function(J, ut, bt) {
        return J = +J, ut >>>= 0, bt || Bt(this, J, ut, 4, 2147483647, -2147483648), this[ut] = 255 & J, this[ut + 1] = J >>> 8, this[ut + 2] = J >>> 16, this[ut + 3] = J >>> 24, ut + 4;
      }, Z.prototype.writeInt32BE = function(J, ut, bt) {
        return J = +J, ut >>>= 0, bt || Bt(this, J, ut, 4, 2147483647, -2147483648), J < 0 && (J = 4294967295 + J + 1), this[ut] = J >>> 24, this[ut + 1] = J >>> 16, this[ut + 2] = J >>> 8, this[ut + 3] = 255 & J, ut + 4;
      }, Z.prototype.writeFloatLE = function(J, ut, bt) {
        return Tt(this, J, ut, !0, bt);
      }, Z.prototype.writeFloatBE = function(J, ut, bt) {
        return Tt(this, J, ut, !1, bt);
      }, Z.prototype.writeDoubleLE = function(J, ut, bt) {
        return Dt(this, J, ut, !0, bt);
      }, Z.prototype.writeDoubleBE = function(J, ut, bt) {
        return Dt(this, J, ut, !1, bt);
      }, Z.prototype.copy = function(J, ut, bt, yt) {
        if (!Z.isBuffer(J)) throw new TypeError("argument should be a Buffer");
        if (bt || (bt = 0), yt || yt === 0 || (yt = this.length), ut >= J.length && (ut = J.length), ut || (ut = 0), yt > 0 && yt < bt && (yt = bt), yt === bt || J.length === 0 || this.length === 0) return 0;
        if (ut < 0) throw new RangeError("targetStart out of bounds");
        if (bt < 0 || bt >= this.length) throw new RangeError("Index out of range");
        if (yt < 0) throw new RangeError("sourceEnd out of bounds");
        yt > this.length && (yt = this.length), J.length - ut < yt - bt && (yt = J.length - ut + bt);
        var Lt = yt - bt;
        if (this === J && typeof Uint8Array.prototype.copyWithin == "function") this.copyWithin(ut, bt, yt);
        else if (this === J && bt < ut && ut < yt) for (var jt = Lt - 1; jt >= 0; --jt) J[jt + ut] = this[jt + bt];
        else Uint8Array.prototype.set.call(J, this.subarray(bt, yt), ut);
        return Lt;
      }, Z.prototype.fill = function(J, ut, bt, yt) {
        if (typeof J == "string") {
          if (typeof ut == "string" ? (yt = ut, ut = 0, bt = this.length) : typeof bt == "string" && (yt = bt, bt = this.length), yt !== void 0 && typeof yt != "string") throw new TypeError("encoding must be a string");
          if (typeof yt == "string" && !Z.isEncoding(yt)) throw new TypeError("Unknown encoding: " + yt);
          if (J.length === 1) {
            var Lt = J.charCodeAt(0);
            (yt === "utf8" && Lt < 128 || yt === "latin1") && (J = Lt);
          }
        } else typeof J == "number" && (J &= 255);
        if (ut < 0 || this.length < ut || this.length < bt) throw new RangeError("Out of range index");
        if (bt <= ut) return this;
        var jt;
        if (ut >>>= 0, bt = bt === void 0 ? this.length : bt >>> 0, J || (J = 0), typeof J == "number") for (jt = ut; jt < bt; ++jt) this[jt] = J;
        else {
          var Kt = Z.isBuffer(J) ? J : Z.from(J, yt), te = Kt.length;
          if (te === 0) throw new TypeError('The value "' + J + '" is invalid for argument "value"');
          for (jt = 0; jt < bt - ut; ++jt) this[jt + ut] = Kt[jt % te];
        }
        return this;
      };
      var Zt = /[^+/0-9A-Za-z-_]/g;
      function $t(J) {
        if ((J = (J = J.split("=")[0]).trim().replace(Zt, "")).length < 2) return "";
        for (; J.length % 4 != 0; ) J += "=";
        return J;
      }
      function Mt(J) {
        return J < 16 ? "0" + J.toString(16) : J.toString(16);
      }
      function nt(J, ut) {
        var bt;
        ut = ut || 1 / 0;
        for (var yt = J.length, Lt = null, jt = [], Kt = 0; Kt < yt; ++Kt) {
          if ((bt = J.charCodeAt(Kt)) > 55295 && bt < 57344) {
            if (!Lt) {
              if (bt > 56319) {
                (ut -= 3) > -1 && jt.push(239, 191, 189);
                continue;
              }
              if (Kt + 1 === yt) {
                (ut -= 3) > -1 && jt.push(239, 191, 189);
                continue;
              }
              Lt = bt;
              continue;
            }
            if (bt < 56320) {
              (ut -= 3) > -1 && jt.push(239, 191, 189), Lt = bt;
              continue;
            }
            bt = 65536 + (Lt - 55296 << 10 | bt - 56320);
          } else Lt && (ut -= 3) > -1 && jt.push(239, 191, 189);
          if (Lt = null, bt < 128) {
            if ((ut -= 1) < 0) break;
            jt.push(bt);
          } else if (bt < 2048) {
            if ((ut -= 2) < 0) break;
            jt.push(bt >> 6 | 192, 63 & bt | 128);
          } else if (bt < 65536) {
            if ((ut -= 3) < 0) break;
            jt.push(bt >> 12 | 224, bt >> 6 & 63 | 128, 63 & bt | 128);
          } else {
            if (!(bt < 1114112)) throw new Error("Invalid code point");
            if ((ut -= 4) < 0) break;
            jt.push(bt >> 18 | 240, bt >> 12 & 63 | 128, bt >> 6 & 63 | 128, 63 & bt | 128);
          }
        }
        return jt;
      }
      function It(J) {
        for (var ut = [], bt = 0; bt < J.length; ++bt) ut.push(255 & J.charCodeAt(bt));
        return ut;
      }
      function mt(J, ut) {
        for (var bt, yt, Lt, jt = [], Kt = 0; Kt < J.length && !((ut -= 2) < 0); ++Kt) yt = (bt = J.charCodeAt(Kt)) >> 8, Lt = bt % 256, jt.push(Lt), jt.push(yt);
        return jt;
      }
      function gt(J) {
        return I.toByteArray($t(J));
      }
      function _t(J, ut, bt, yt) {
        for (var Lt = 0; Lt < yt && !(Lt + bt >= ut.length || Lt >= J.length); ++Lt) ut[Lt + bt] = J[Lt];
        return Lt;
      }
      function wt(J, ut) {
        return J instanceof ut || J != null && J.constructor != null && J.constructor.name != null && J.constructor.name === ut.name;
      }
      function Rt(J) {
        return J != J;
      }
    }).call(this);
  }).call(this, d("buffer").Buffer);
}, { "base64-js": 28, buffer: 32, ieee754: 45 }], 33: [function(d, m, g) {
  var w = d("get-intrinsic"), I = d("./"), P = I(w("String.prototype.indexOf"));
  m.exports = function(F, D) {
    var U = w(F, !!D);
    return typeof U == "function" && P(F, ".prototype.") > -1 ? I(U) : U;
  };
}, { "./": 34, "get-intrinsic": 39 }], 34: [function(d, m, g) {
  var w = d("function-bind"), I = d("get-intrinsic"), P = I("%Function.prototype.apply%"), F = I("%Function.prototype.call%"), D = I("%Reflect.apply%", !0) || w.call(F, P), U = I("%Object.getOwnPropertyDescriptor%", !0), Z = I("%Object.defineProperty%", !0), $ = I("%Math.max%");
  if (Z) try {
    Z({}, "a", { value: 1 });
  } catch {
    Z = null;
  }
  m.exports = function(G) {
    var Q = D(w, F, arguments);
    return U && Z && U(Q, "length").configurable && Z(Q, "length", { value: 1 + $(0, G.length - (arguments.length - 1)) }), Q;
  };
  var j = function() {
    return D(w, P, arguments);
  };
  Z ? Z(m.exports, "apply", { value: j }) : m.exports.apply = j;
}, { "function-bind": 38, "get-intrinsic": 39 }], 35: [function(d, m, g) {
  var w, I = typeof Reflect == "object" ? Reflect : null, P = I && typeof I.apply == "function" ? I.apply : function(it, st, at) {
    return Function.prototype.apply.call(it, st, at);
  };
  function F(it) {
    console && console.warn && console.warn(it);
  }
  w = I && typeof I.ownKeys == "function" ? I.ownKeys : Object.getOwnPropertySymbols ? function(it) {
    return Object.getOwnPropertyNames(it).concat(Object.getOwnPropertySymbols(it));
  } : function(it) {
    return Object.getOwnPropertyNames(it);
  };
  var D = Number.isNaN || function(it) {
    return it != it;
  };
  function U() {
    U.init.call(this);
  }
  m.exports = U, m.exports.once = V, U.EventEmitter = U, U.prototype._events = void 0, U.prototype._eventsCount = 0, U.prototype._maxListeners = void 0;
  var Z = 10;
  function $(it) {
    if (typeof it != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof it);
  }
  function j(it) {
    return it._maxListeners === void 0 ? U.defaultMaxListeners : it._maxListeners;
  }
  function G(it, st, at, ct) {
    var K, lt, vt;
    if ($(at), (lt = it._events) === void 0 ? (lt = it._events = /* @__PURE__ */ Object.create(null), it._eventsCount = 0) : (lt.newListener !== void 0 && (it.emit("newListener", st, at.listener ? at.listener : at), lt = it._events), vt = lt[st]), vt === void 0) vt = lt[st] = at, ++it._eventsCount;
    else if (typeof vt == "function" ? vt = lt[st] = ct ? [at, vt] : [vt, at] : ct ? vt.unshift(at) : vt.push(at), (K = j(it)) > 0 && vt.length > K && !vt.warned) {
      vt.warned = !0;
      var dt = new Error("Possible EventEmitter memory leak detected. " + vt.length + " " + String(st) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      dt.name = "MaxListenersExceededWarning", dt.emitter = it, dt.type = st, dt.count = vt.length, F(dt);
    }
    return it;
  }
  function Q() {
    if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function H(it, st, at) {
    var ct = { fired: !1, wrapFn: void 0, target: it, type: st, listener: at }, K = Q.bind(ct);
    return K.listener = at, ct.wrapFn = K, K;
  }
  function W(it, st, at) {
    var ct = it._events;
    if (ct === void 0) return [];
    var K = ct[st];
    return K === void 0 ? [] : typeof K == "function" ? at ? [K.listener || K] : [K] : at ? tt(K) : et(K, K.length);
  }
  function q(it) {
    var st = this._events;
    if (st !== void 0) {
      var at = st[it];
      if (typeof at == "function") return 1;
      if (at !== void 0) return at.length;
    }
    return 0;
  }
  function et(it, st) {
    for (var at = new Array(st), ct = 0; ct < st; ++ct) at[ct] = it[ct];
    return at;
  }
  function rt(it, st) {
    for (; st + 1 < it.length; st++) it[st] = it[st + 1];
    it.pop();
  }
  function tt(it) {
    for (var st = new Array(it.length), at = 0; at < st.length; ++at) st[at] = it[at].listener || it[at];
    return st;
  }
  function V(it, st) {
    return new Promise(function(at, ct) {
      function K(vt) {
        it.removeListener(st, lt), ct(vt);
      }
      function lt() {
        typeof it.removeListener == "function" && it.removeListener("error", K), at([].slice.call(arguments));
      }
      ot(it, st, lt, { once: !0 }), st !== "error" && X(it, K, { once: !0 });
    });
  }
  function X(it, st, at) {
    typeof it.on == "function" && ot(it, "error", st, at);
  }
  function ot(it, st, at, ct) {
    if (typeof it.on == "function") ct.once ? it.once(st, at) : it.on(st, at);
    else {
      if (typeof it.addEventListener != "function") throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof it);
      it.addEventListener(st, function K(lt) {
        ct.once && it.removeEventListener(st, K), at(lt);
      });
    }
  }
  Object.defineProperty(U, "defaultMaxListeners", { enumerable: !0, get: function() {
    return Z;
  }, set: function(it) {
    if (typeof it != "number" || it < 0 || D(it)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + it + ".");
    Z = it;
  } }), U.init = function() {
    this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, U.prototype.setMaxListeners = function(it) {
    if (typeof it != "number" || it < 0 || D(it)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + it + ".");
    return this._maxListeners = it, this;
  }, U.prototype.getMaxListeners = function() {
    return j(this);
  }, U.prototype.emit = function(it) {
    for (var st = [], at = 1; at < arguments.length; at++) st.push(arguments[at]);
    var ct = it === "error", K = this._events;
    if (K !== void 0) ct = ct && K.error === void 0;
    else if (!ct) return !1;
    if (ct) {
      var lt;
      if (st.length > 0 && (lt = st[0]), lt instanceof Error) throw lt;
      var vt = new Error("Unhandled error." + (lt ? " (" + lt.message + ")" : ""));
      throw vt.context = lt, vt;
    }
    var dt = K[it];
    if (dt === void 0) return !1;
    if (typeof dt == "function") P(dt, this, st);
    else {
      var ht = dt.length, pt = et(dt, ht);
      for (at = 0; at < ht; ++at) P(pt[at], this, st);
    }
    return !0;
  }, U.prototype.addListener = function(it, st) {
    return G(this, it, st, !1);
  }, U.prototype.on = U.prototype.addListener, U.prototype.prependListener = function(it, st) {
    return G(this, it, st, !0);
  }, U.prototype.once = function(it, st) {
    return $(st), this.on(it, H(this, it, st)), this;
  }, U.prototype.prependOnceListener = function(it, st) {
    return $(st), this.prependListener(it, H(this, it, st)), this;
  }, U.prototype.removeListener = function(it, st) {
    var at, ct, K, lt, vt;
    if ($(st), (ct = this._events) === void 0) return this;
    if ((at = ct[it]) === void 0) return this;
    if (at === st || at.listener === st) --this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete ct[it], ct.removeListener && this.emit("removeListener", it, at.listener || st));
    else if (typeof at != "function") {
      for (K = -1, lt = at.length - 1; lt >= 0; lt--) if (at[lt] === st || at[lt].listener === st) {
        vt = at[lt].listener, K = lt;
        break;
      }
      if (K < 0) return this;
      K === 0 ? at.shift() : rt(at, K), at.length === 1 && (ct[it] = at[0]), ct.removeListener !== void 0 && this.emit("removeListener", it, vt || st);
    }
    return this;
  }, U.prototype.off = U.prototype.removeListener, U.prototype.removeAllListeners = function(it) {
    var st, at, ct;
    if ((at = this._events) === void 0) return this;
    if (at.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : at[it] !== void 0 && (--this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete at[it]), this;
    if (arguments.length === 0) {
      var K, lt = Object.keys(at);
      for (ct = 0; ct < lt.length; ++ct) (K = lt[ct]) !== "removeListener" && this.removeAllListeners(K);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (typeof (st = at[it]) == "function") this.removeListener(it, st);
    else if (st !== void 0) for (ct = st.length - 1; ct >= 0; ct--) this.removeListener(it, st[ct]);
    return this;
  }, U.prototype.listeners = function(it) {
    return W(this, it, !0);
  }, U.prototype.rawListeners = function(it) {
    return W(this, it, !1);
  }, U.listenerCount = function(it, st) {
    return typeof it.listenerCount == "function" ? it.listenerCount(st) : q.call(it, st);
  }, U.prototype.listenerCount = q, U.prototype.eventNames = function() {
    return this._eventsCount > 0 ? w(this._events) : [];
  };
}, {}], 36: [function(d, m, g) {
  var w = d("is-callable"), I = Object.prototype.toString, P = Object.prototype.hasOwnProperty, F = function($, j, G) {
    for (var Q = 0, H = $.length; Q < H; Q++) P.call($, Q) && (G == null ? j($[Q], Q, $) : j.call(G, $[Q], Q, $));
  }, D = function($, j, G) {
    for (var Q = 0, H = $.length; Q < H; Q++) G == null ? j($.charAt(Q), Q, $) : j.call(G, $.charAt(Q), Q, $);
  }, U = function($, j, G) {
    for (var Q in $) P.call($, Q) && (G == null ? j($[Q], Q, $) : j.call(G, $[Q], Q, $));
  }, Z = function($, j, G) {
    if (!w(j)) throw new TypeError("iterator must be a function");
    var Q;
    arguments.length >= 3 && (Q = G), I.call($) === "[object Array]" ? F($, j, Q) : typeof $ == "string" ? D($, j, Q) : U($, j, Q);
  };
  m.exports = Z;
}, { "is-callable": 48 }], 37: [function(d, m, g) {
  var w = "Function.prototype.bind called on incompatible ", I = Array.prototype.slice, P = Object.prototype.toString, F = "[object Function]";
  m.exports = function(D) {
    var U = this;
    if (typeof U != "function" || P.call(U) !== F) throw new TypeError(w + U);
    for (var Z, $ = I.call(arguments, 1), j = function() {
      if (this instanceof Z) {
        var q = U.apply(this, $.concat(I.call(arguments)));
        return Object(q) === q ? q : this;
      }
      return U.apply(D, $.concat(I.call(arguments)));
    }, G = Math.max(0, U.length - $.length), Q = [], H = 0; H < G; H++) Q.push("$" + H);
    if (Z = Function("binder", "return function (" + Q.join(",") + "){ return binder.apply(this,arguments); }")(j), U.prototype) {
      var W = function() {
      };
      W.prototype = U.prototype, Z.prototype = new W(), W.prototype = null;
    }
    return Z;
  };
}, {}], 38: [function(d, m, g) {
  var w = d("./implementation");
  m.exports = Function.prototype.bind || w;
}, { "./implementation": 37 }], 39: [function(d, m, g) {
  var w, I = SyntaxError, P = Function, F = TypeError, D = function(dt) {
    try {
      return P('"use strict"; return (' + dt + ").constructor;")();
    } catch {
    }
  }, U = Object.getOwnPropertyDescriptor;
  if (U) try {
    U({}, "");
  } catch {
    U = null;
  }
  var Z = function() {
    throw new F();
  }, $ = U ? function() {
    try {
      return Z;
    } catch {
      try {
        return U(arguments, "callee").get;
      } catch {
        return Z;
      }
    }
  }() : Z, j = d("has-symbols")(), G = Object.getPrototypeOf || function(dt) {
    return dt.__proto__;
  }, Q = {}, H = typeof Uint8Array > "u" ? w : G(Uint8Array), W = { "%AggregateError%": typeof AggregateError > "u" ? w : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? w : ArrayBuffer, "%ArrayIteratorPrototype%": j ? G([][Symbol.iterator]()) : w, "%AsyncFromSyncIteratorPrototype%": w, "%AsyncFunction%": Q, "%AsyncGenerator%": Q, "%AsyncGeneratorFunction%": Q, "%AsyncIteratorPrototype%": Q, "%Atomics%": typeof Atomics > "u" ? w : Atomics, "%BigInt%": typeof BigInt > "u" ? w : BigInt, "%BigInt64Array%": typeof BigInt64Array > "u" ? w : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array > "u" ? w : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? w : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array > "u" ? w : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? w : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? w : FinalizationRegistry, "%Function%": P, "%GeneratorFunction%": Q, "%Int8Array%": typeof Int8Array > "u" ? w : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? w : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? w : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": j ? G(G([][Symbol.iterator]())) : w, "%JSON%": typeof JSON == "object" ? JSON : w, "%Map%": typeof Map > "u" ? w : Map, "%MapIteratorPrototype%": typeof Map < "u" && j ? G((/* @__PURE__ */ new Map())[Symbol.iterator]()) : w, "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? w : Promise, "%Proxy%": typeof Proxy > "u" ? w : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect > "u" ? w : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? w : Set, "%SetIteratorPrototype%": typeof Set < "u" && j ? G((/* @__PURE__ */ new Set())[Symbol.iterator]()) : w, "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? w : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": j ? G(""[Symbol.iterator]()) : w, "%Symbol%": j ? Symbol : w, "%SyntaxError%": I, "%ThrowTypeError%": $, "%TypedArray%": H, "%TypeError%": F, "%Uint8Array%": typeof Uint8Array > "u" ? w : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? w : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? w : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? w : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap > "u" ? w : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? w : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? w : WeakSet };
  try {
    null.error;
  } catch (dt) {
    var q = G(G(dt));
    W["%Error.prototype%"] = q;
  }
  var et = function dt(ht) {
    var pt;
    if (ht === "%AsyncFunction%") pt = D("async function () {}");
    else if (ht === "%GeneratorFunction%") pt = D("function* () {}");
    else if (ht === "%AsyncGeneratorFunction%") pt = D("async function* () {}");
    else if (ht === "%AsyncGenerator%") {
      var Ct = dt("%AsyncGeneratorFunction%");
      Ct && (pt = Ct.prototype);
    } else if (ht === "%AsyncIteratorPrototype%") {
      var St = dt("%AsyncGenerator%");
      St && (pt = G(St.prototype));
    }
    return W[ht] = pt, pt;
  }, rt = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, tt = d("function-bind"), V = d("has"), X = tt.call(Function.call, Array.prototype.concat), ot = tt.call(Function.apply, Array.prototype.splice), it = tt.call(Function.call, String.prototype.replace), st = tt.call(Function.call, String.prototype.slice), at = tt.call(Function.call, RegExp.prototype.exec), ct = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, K = /\\(\\)?/g, lt = function(dt) {
    var ht = st(dt, 0, 1), pt = st(dt, -1);
    if (ht === "%" && pt !== "%") throw new I("invalid intrinsic syntax, expected closing `%`");
    if (pt === "%" && ht !== "%") throw new I("invalid intrinsic syntax, expected opening `%`");
    var Ct = [];
    return it(dt, ct, function(St, At, Ft, xt) {
      Ct[Ct.length] = Ft ? it(xt, K, "$1") : At || St;
    }), Ct;
  }, vt = function(dt, ht) {
    var pt, Ct = dt;
    if (V(rt, Ct) && (Ct = "%" + (pt = rt[Ct])[0] + "%"), V(W, Ct)) {
      var St = W[Ct];
      if (St === Q && (St = et(Ct)), St === void 0 && !ht) throw new F("intrinsic " + dt + " exists, but is not available. Please file an issue!");
      return { alias: pt, name: Ct, value: St };
    }
    throw new I("intrinsic " + dt + " does not exist!");
  };
  m.exports = function(dt, ht) {
    if (typeof dt != "string" || dt.length === 0) throw new F("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof ht != "boolean") throw new F('"allowMissing" argument must be a boolean');
    if (at(/^%?[^%]*%?$/, dt) === null) throw new I("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var pt = lt(dt), Ct = pt.length > 0 ? pt[0] : "", St = vt("%" + Ct + "%", ht), At = St.name, Ft = St.value, xt = !1, Pt = St.alias;
    Pt && (Ct = Pt[0], ot(pt, X([0, 1], Pt)));
    for (var Ot = 1, Bt = !0; Ot < pt.length; Ot += 1) {
      var kt = pt[Ot], Tt = st(kt, 0, 1), Dt = st(kt, -1);
      if ((Tt === '"' || Tt === "'" || Tt === "`" || Dt === '"' || Dt === "'" || Dt === "`") && Tt !== Dt) throw new I("property names with quotes must have matching quotes");
      if (kt !== "constructor" && Bt || (xt = !0), V(W, At = "%" + (Ct += "." + kt) + "%")) Ft = W[At];
      else if (Ft != null) {
        if (!(kt in Ft)) {
          if (!ht) throw new F("base intrinsic for " + dt + " exists, but the property is not available.");
          return;
        }
        if (U && Ot + 1 >= pt.length) {
          var Zt = U(Ft, kt);
          Ft = (Bt = !!Zt) && "get" in Zt && !("originalValue" in Zt.get) ? Zt.get : Ft[kt];
        } else Bt = V(Ft, kt), Ft = Ft[kt];
        Bt && !xt && (W[At] = Ft);
      }
    }
    return Ft;
  };
}, { "function-bind": 38, has: 44, "has-symbols": 41 }], 40: [function(d, m, g) {
  var w = d("get-intrinsic")("%Object.getOwnPropertyDescriptor%", !0);
  if (w) try {
    w([], "length");
  } catch {
    w = null;
  }
  m.exports = w;
}, { "get-intrinsic": 39 }], 41: [function(d, m, g) {
  var w = typeof Symbol < "u" && Symbol, I = d("./shams");
  m.exports = function() {
    return typeof w == "function" && typeof Symbol == "function" && typeof w("foo") == "symbol" && typeof Symbol("bar") == "symbol" && I();
  };
}, { "./shams": 42 }], 42: [function(d, m, g) {
  m.exports = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
    if (typeof Symbol.iterator == "symbol") return !0;
    var w = {}, I = Symbol("test"), P = Object(I);
    if (typeof I == "string" || Object.prototype.toString.call(I) !== "[object Symbol]" || Object.prototype.toString.call(P) !== "[object Symbol]") return !1;
    var F = 42;
    for (I in w[I] = F, w) return !1;
    if (typeof Object.keys == "function" && Object.keys(w).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(w).length !== 0) return !1;
    var D = Object.getOwnPropertySymbols(w);
    if (D.length !== 1 || D[0] !== I || !Object.prototype.propertyIsEnumerable.call(w, I)) return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var U = Object.getOwnPropertyDescriptor(w, I);
      if (U.value !== F || U.enumerable !== !0) return !1;
    }
    return !0;
  };
}, {}], 43: [function(d, m, g) {
  var w = d("has-symbols/shams");
  m.exports = function() {
    return w() && !!Symbol.toStringTag;
  };
}, { "has-symbols/shams": 42 }], 44: [function(d, m, g) {
  var w = d("function-bind");
  m.exports = w.call(Function.call, Object.prototype.hasOwnProperty);
}, { "function-bind": 38 }], 45: [function(d, m, g) {
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  g.read = function(w, I, P, F, D) {
    var U, Z, $ = 8 * D - F - 1, j = (1 << $) - 1, G = j >> 1, Q = -7, H = P ? D - 1 : 0, W = P ? -1 : 1, q = w[I + H];
    for (H += W, U = q & (1 << -Q) - 1, q >>= -Q, Q += $; Q > 0; U = 256 * U + w[I + H], H += W, Q -= 8) ;
    for (Z = U & (1 << -Q) - 1, U >>= -Q, Q += F; Q > 0; Z = 256 * Z + w[I + H], H += W, Q -= 8) ;
    if (U === 0) U = 1 - G;
    else {
      if (U === j) return Z ? NaN : 1 / 0 * (q ? -1 : 1);
      Z += Math.pow(2, F), U -= G;
    }
    return (q ? -1 : 1) * Z * Math.pow(2, U - F);
  }, g.write = function(w, I, P, F, D, U) {
    var Z, $, j, G = 8 * U - D - 1, Q = (1 << G) - 1, H = Q >> 1, W = D === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, q = F ? 0 : U - 1, et = F ? 1 : -1, rt = I < 0 || I === 0 && 1 / I < 0 ? 1 : 0;
    for (I = Math.abs(I), isNaN(I) || I === 1 / 0 ? ($ = isNaN(I) ? 1 : 0, Z = Q) : (Z = Math.floor(Math.log(I) / Math.LN2), I * (j = Math.pow(2, -Z)) < 1 && (Z--, j *= 2), (I += Z + H >= 1 ? W / j : W * Math.pow(2, 1 - H)) * j >= 2 && (Z++, j /= 2), Z + H >= Q ? ($ = 0, Z = Q) : Z + H >= 1 ? ($ = (I * j - 1) * Math.pow(2, D), Z += H) : ($ = I * Math.pow(2, H - 1) * Math.pow(2, D), Z = 0)); D >= 8; w[P + q] = 255 & $, q += et, $ /= 256, D -= 8) ;
    for (Z = Z << D | $, G += D; G > 0; w[P + q] = 255 & Z, q += et, Z /= 256, G -= 8) ;
    w[P + q - et] |= 128 * rt;
  };
}, {}], 46: [function(d, m, g) {
  typeof Object.create == "function" ? m.exports = function(w, I) {
    I && (w.super_ = I, w.prototype = Object.create(I.prototype, { constructor: { value: w, enumerable: !1, writable: !0, configurable: !0 } }));
  } : m.exports = function(w, I) {
    if (I) {
      w.super_ = I;
      var P = function() {
      };
      P.prototype = I.prototype, w.prototype = new P(), w.prototype.constructor = w;
    }
  };
}, {}], 47: [function(d, m, g) {
  var w = d("has-tostringtag/shams")(), I = d("call-bind/callBound")("Object.prototype.toString"), P = function(U) {
    return !(w && U && typeof U == "object" && Symbol.toStringTag in U) && I(U) === "[object Arguments]";
  }, F = function(U) {
    return !!P(U) || U !== null && typeof U == "object" && typeof U.length == "number" && U.length >= 0 && I(U) !== "[object Array]" && I(U.callee) === "[object Function]";
  }, D = function() {
    return P(arguments);
  }();
  P.isLegacyArguments = F, m.exports = D ? P : F;
}, { "call-bind/callBound": 33, "has-tostringtag/shams": 43 }], 48: [function(d, m, g) {
  var w, I, P = Function.prototype.toString, F = typeof Reflect == "object" && Reflect !== null && Reflect.apply;
  if (typeof F == "function" && typeof Object.defineProperty == "function") try {
    w = Object.defineProperty({}, "length", { get: function() {
      throw I;
    } }), I = {}, F(function() {
      throw 42;
    }, null, w);
  } catch (X) {
    X !== I && (F = null);
  }
  else F = null;
  var D = /^\s*class\b/, U = function(X) {
    try {
      var ot = P.call(X);
      return D.test(ot);
    } catch {
      return !1;
    }
  }, Z = function(X) {
    try {
      return !U(X) && (P.call(X), !0);
    } catch {
      return !1;
    }
  }, $ = Object.prototype.toString, j = "[object Object]", G = "[object Function]", Q = "[object GeneratorFunction]", H = "[object HTMLAllCollection]", W = "[object HTML document.all class]", q = "[object HTMLCollection]", et = typeof Symbol == "function" && !!Symbol.toStringTag, rt = !(0 in [,]), tt = function() {
    return !1;
  };
  if (typeof document == "object") {
    var V = document.all;
    $.call(V) === $.call(document.all) && (tt = function(X) {
      if ((rt || !X) && (X === void 0 || typeof X == "object")) try {
        var ot = $.call(X);
        return (ot === H || ot === W || ot === q || ot === j) && X("") == null;
      } catch {
      }
      return !1;
    });
  }
  m.exports = F ? function(X) {
    if (tt(X)) return !0;
    if (!X || typeof X != "function" && typeof X != "object") return !1;
    try {
      F(X, null, w);
    } catch (ot) {
      if (ot !== I) return !1;
    }
    return !U(X) && Z(X);
  } : function(X) {
    if (tt(X)) return !0;
    if (!X || typeof X != "function" && typeof X != "object") return !1;
    if (et) return Z(X);
    if (U(X)) return !1;
    var ot = $.call(X);
    return !(ot !== G && ot !== Q && !/^\[object HTML/.test(ot)) && Z(X);
  };
}, {}], 49: [function(d, m, g) {
  var w, I = Object.prototype.toString, P = Function.prototype.toString, F = /^\s*(?:function)?\*/, D = d("has-tostringtag/shams")(), U = Object.getPrototypeOf, Z = function() {
    if (!D) return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  };
  m.exports = function($) {
    if (typeof $ != "function") return !1;
    if (F.test(P.call($))) return !0;
    if (!D) return I.call($) === "[object GeneratorFunction]";
    if (!U) return !1;
    if (w === void 0) {
      var j = Z();
      w = !!j && U(j);
    }
    return U($) === w;
  };
}, { "has-tostringtag/shams": 43 }], 50: [function(d, m, g) {
  (function(w) {
    (function() {
      var I = d("for-each"), P = d("available-typed-arrays"), F = d("call-bind/callBound"), D = F("Object.prototype.toString"), U = d("has-tostringtag/shams")(), Z = d("gopd"), $ = typeof globalThis > "u" ? w : globalThis, j = P(), G = F("Array.prototype.indexOf", !0) || function(et, rt) {
        for (var tt = 0; tt < et.length; tt += 1) if (et[tt] === rt) return tt;
        return -1;
      }, Q = F("String.prototype.slice"), H = {}, W = Object.getPrototypeOf;
      U && Z && W && I(j, function(et) {
        var rt = new $[et]();
        if (Symbol.toStringTag in rt) {
          var tt = W(rt), V = Z(tt, Symbol.toStringTag);
          if (!V) {
            var X = W(tt);
            V = Z(X, Symbol.toStringTag);
          }
          H[et] = V.get;
        }
      });
      var q = function(et) {
        var rt = !1;
        return I(H, function(tt, V) {
          if (!rt) try {
            rt = tt.call(et) === V;
          } catch {
          }
        }), rt;
      };
      m.exports = function(et) {
        if (!et || typeof et != "object") return !1;
        if (!U || !(Symbol.toStringTag in et)) {
          var rt = Q(D(et), 8, -1);
          return G(j, rt) > -1;
        }
        return !!Z && q(et);
      };
    }).call(this);
  }).call(this, commonjsGlobal !== void 0 ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
}, { "available-typed-arrays": 27, "call-bind/callBound": 33, "for-each": 36, gopd: 40, "has-tostringtag/shams": 43 }], 51: [function(d, m, g) {
  var w = Object.getOwnPropertySymbols, I = Object.prototype.hasOwnProperty, P = Object.prototype.propertyIsEnumerable;
  function F(U) {
    if (U == null) throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(U);
  }
  function D() {
    try {
      if (!Object.assign) return !1;
      var U = new String("abc");
      if (U[5] = "de", Object.getOwnPropertyNames(U)[0] === "5") return !1;
      for (var Z = {}, $ = 0; $ < 10; $++) Z["_" + String.fromCharCode($)] = $;
      var j = Object.getOwnPropertyNames(Z).map(function(Q) {
        return Z[Q];
      });
      if (j.join("") !== "0123456789") return !1;
      var G = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(Q) {
        G[Q] = Q;
      }), Object.keys(Object.assign({}, G)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  m.exports = D() ? Object.assign : function(U, Z) {
    for (var $, j, G = F(U), Q = 1; Q < arguments.length; Q++) {
      for (var H in $ = Object(arguments[Q])) I.call($, H) && (G[H] = $[H]);
      if (w) {
        j = w($);
        for (var W = 0; W < j.length; W++) P.call($, j[W]) && (G[j[W]] = $[j[W]]);
      }
    }
    return G;
  };
}, {}], 52: [function(d, m, g) {
  var w = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
  function I(D, U) {
    return Object.prototype.hasOwnProperty.call(D, U);
  }
  g.assign = function(D) {
    for (var U = Array.prototype.slice.call(arguments, 1); U.length; ) {
      var Z = U.shift();
      if (Z) {
        if (typeof Z != "object") throw new TypeError(Z + "must be non-object");
        for (var $ in Z) I(Z, $) && (D[$] = Z[$]);
      }
    }
    return D;
  }, g.shrinkBuf = function(D, U) {
    return D.length === U ? D : D.subarray ? D.subarray(0, U) : (D.length = U, D);
  };
  var P = { arraySet: function(D, U, Z, $, j) {
    if (U.subarray && D.subarray) D.set(U.subarray(Z, Z + $), j);
    else for (var G = 0; G < $; G++) D[j + G] = U[Z + G];
  }, flattenChunks: function(D) {
    var U, Z, $, j, G, Q;
    for ($ = 0, U = 0, Z = D.length; U < Z; U++) $ += D[U].length;
    for (Q = new Uint8Array($), j = 0, U = 0, Z = D.length; U < Z; U++) G = D[U], Q.set(G, j), j += G.length;
    return Q;
  } }, F = { arraySet: function(D, U, Z, $, j) {
    for (var G = 0; G < $; G++) D[j + G] = U[Z + G];
  }, flattenChunks: function(D) {
    return [].concat.apply([], D);
  } };
  g.setTyped = function(D) {
    D ? (g.Buf8 = Uint8Array, g.Buf16 = Uint16Array, g.Buf32 = Int32Array, g.assign(g, P)) : (g.Buf8 = Array, g.Buf16 = Array, g.Buf32 = Array, g.assign(g, F));
  }, g.setTyped(w);
}, {}], 53: [function(d, m, g) {
  function w(I, P, F, D) {
    for (var U = 65535 & I, Z = I >>> 16 & 65535, $ = 0; F !== 0; ) {
      F -= $ = F > 2e3 ? 2e3 : F;
      do
        Z = Z + (U = U + P[D++] | 0) | 0;
      while (--$);
      U %= 65521, Z %= 65521;
    }
    return U | Z << 16;
  }
  m.exports = w;
}, {}], 54: [function(d, m, g) {
  m.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
}, {}], 55: [function(d, m, g) {
  function w() {
    for (var F, D = [], U = 0; U < 256; U++) {
      F = U;
      for (var Z = 0; Z < 8; Z++) F = 1 & F ? 3988292384 ^ F >>> 1 : F >>> 1;
      D[U] = F;
    }
    return D;
  }
  var I = w();
  function P(F, D, U, Z) {
    var $ = I, j = Z + U;
    F ^= -1;
    for (var G = Z; G < j; G++) F = F >>> 8 ^ $[255 & (F ^ D[G])];
    return ~F;
  }
  m.exports = P;
}, {}], 56: [function(d, m, g) {
  var w, I = d("../utils/common"), P = d("./trees"), F = d("./adler32"), D = d("./crc32"), U = d("./messages"), Z = 0, $ = 1, j = 3, G = 4, Q = 5, H = 0, W = 1, q = -2, et = -3, rt = -5, tt = -1, V = 1, X = 2, ot = 3, it = 4, st = 0, at = 2, ct = 8, K = 9, lt = 15, vt = 8, dt = 286, ht = 30, pt = 19, Ct = 2 * dt + 1, St = 15, At = 3, Ft = 258, xt = Ft + At + 1, Pt = 32, Ot = 42, Bt = 69, kt = 73, Tt = 91, Dt = 103, Zt = 113, $t = 666, Mt = 1, nt = 2, It = 3, mt = 4, gt = 3;
  function _t(ft, qt) {
    return ft.msg = U[qt], qt;
  }
  function wt(ft) {
    return (ft << 1) - (ft > 4 ? 9 : 0);
  }
  function Rt(ft) {
    for (var qt = ft.length; --qt >= 0; ) ft[qt] = 0;
  }
  function J(ft) {
    var qt = ft.state, Gt = qt.pending;
    Gt > ft.avail_out && (Gt = ft.avail_out), Gt !== 0 && (I.arraySet(ft.output, qt.pending_buf, qt.pending_out, Gt, ft.next_out), ft.next_out += Gt, qt.pending_out += Gt, ft.total_out += Gt, ft.avail_out -= Gt, qt.pending -= Gt, qt.pending === 0 && (qt.pending_out = 0));
  }
  function ut(ft, qt) {
    P._tr_flush_block(ft, ft.block_start >= 0 ? ft.block_start : -1, ft.strstart - ft.block_start, qt), ft.block_start = ft.strstart, J(ft.strm);
  }
  function bt(ft, qt) {
    ft.pending_buf[ft.pending++] = qt;
  }
  function yt(ft, qt) {
    ft.pending_buf[ft.pending++] = qt >>> 8 & 255, ft.pending_buf[ft.pending++] = 255 & qt;
  }
  function Lt(ft, qt, Gt, zt) {
    var Qt = ft.avail_in;
    return Qt > zt && (Qt = zt), Qt === 0 ? 0 : (ft.avail_in -= Qt, I.arraySet(qt, ft.input, ft.next_in, Qt, Gt), ft.state.wrap === 1 ? ft.adler = F(ft.adler, qt, Qt, Gt) : ft.state.wrap === 2 && (ft.adler = D(ft.adler, qt, Qt, Gt)), ft.next_in += Qt, ft.total_in += Qt, Qt);
  }
  function jt(ft, qt) {
    var Gt, zt, Qt = ft.max_chain_length, Ht = ft.strstart, ue = ft.prev_length, ie = ft.nice_match, oe = ft.strstart > ft.w_size - xt ? ft.strstart - (ft.w_size - xt) : 0, he = ft.window, Ee = ft.w_mask, de = ft.prev, me = ft.strstart + Ft, be = he[Ht + ue - 1], ye = he[Ht + ue];
    ft.prev_length >= ft.good_match && (Qt >>= 2), ie > ft.lookahead && (ie = ft.lookahead);
    do
      if (he[(Gt = qt) + ue] === ye && he[Gt + ue - 1] === be && he[Gt] === he[Ht] && he[++Gt] === he[Ht + 1]) {
        Ht += 2, Gt++;
        do
          ;
        while (he[++Ht] === he[++Gt] && he[++Ht] === he[++Gt] && he[++Ht] === he[++Gt] && he[++Ht] === he[++Gt] && he[++Ht] === he[++Gt] && he[++Ht] === he[++Gt] && he[++Ht] === he[++Gt] && he[++Ht] === he[++Gt] && Ht < me);
        if (zt = Ft - (me - Ht), Ht = me - Ft, zt > ue) {
          if (ft.match_start = qt, ue = zt, zt >= ie) break;
          be = he[Ht + ue - 1], ye = he[Ht + ue];
        }
      }
    while ((qt = de[qt & Ee]) > oe && --Qt != 0);
    return ue <= ft.lookahead ? ue : ft.lookahead;
  }
  function Kt(ft) {
    var qt, Gt, zt, Qt, Ht, ue = ft.w_size;
    do {
      if (Qt = ft.window_size - ft.lookahead - ft.strstart, ft.strstart >= ue + (ue - xt)) {
        I.arraySet(ft.window, ft.window, ue, ue, 0), ft.match_start -= ue, ft.strstart -= ue, ft.block_start -= ue, qt = Gt = ft.hash_size;
        do
          zt = ft.head[--qt], ft.head[qt] = zt >= ue ? zt - ue : 0;
        while (--Gt);
        qt = Gt = ue;
        do
          zt = ft.prev[--qt], ft.prev[qt] = zt >= ue ? zt - ue : 0;
        while (--Gt);
        Qt += ue;
      }
      if (ft.strm.avail_in === 0) break;
      if (Gt = Lt(ft.strm, ft.window, ft.strstart + ft.lookahead, Qt), ft.lookahead += Gt, ft.lookahead + ft.insert >= At) for (Ht = ft.strstart - ft.insert, ft.ins_h = ft.window[Ht], ft.ins_h = (ft.ins_h << ft.hash_shift ^ ft.window[Ht + 1]) & ft.hash_mask; ft.insert && (ft.ins_h = (ft.ins_h << ft.hash_shift ^ ft.window[Ht + At - 1]) & ft.hash_mask, ft.prev[Ht & ft.w_mask] = ft.head[ft.ins_h], ft.head[ft.ins_h] = Ht, Ht++, ft.insert--, !(ft.lookahead + ft.insert < At)); ) ;
    } while (ft.lookahead < xt && ft.strm.avail_in !== 0);
  }
  function te(ft, qt) {
    var Gt = 65535;
    for (Gt > ft.pending_buf_size - 5 && (Gt = ft.pending_buf_size - 5); ; ) {
      if (ft.lookahead <= 1) {
        if (Kt(ft), ft.lookahead === 0 && qt === Z) return Mt;
        if (ft.lookahead === 0) break;
      }
      ft.strstart += ft.lookahead, ft.lookahead = 0;
      var zt = ft.block_start + Gt;
      if ((ft.strstart === 0 || ft.strstart >= zt) && (ft.lookahead = ft.strstart - zt, ft.strstart = zt, ut(ft, !1), ft.strm.avail_out === 0) || ft.strstart - ft.block_start >= ft.w_size - xt && (ut(ft, !1), ft.strm.avail_out === 0)) return Mt;
    }
    return ft.insert = 0, qt === G ? (ut(ft, !0), ft.strm.avail_out === 0 ? It : mt) : (ft.strstart > ft.block_start && (ut(ft, !1), ft.strm.avail_out), Mt);
  }
  function Vt(ft, qt) {
    for (var Gt, zt; ; ) {
      if (ft.lookahead < xt) {
        if (Kt(ft), ft.lookahead < xt && qt === Z) return Mt;
        if (ft.lookahead === 0) break;
      }
      if (Gt = 0, ft.lookahead >= At && (ft.ins_h = (ft.ins_h << ft.hash_shift ^ ft.window[ft.strstart + At - 1]) & ft.hash_mask, Gt = ft.prev[ft.strstart & ft.w_mask] = ft.head[ft.ins_h], ft.head[ft.ins_h] = ft.strstart), Gt !== 0 && ft.strstart - Gt <= ft.w_size - xt && (ft.match_length = jt(ft, Gt)), ft.match_length >= At) if (zt = P._tr_tally(ft, ft.strstart - ft.match_start, ft.match_length - At), ft.lookahead -= ft.match_length, ft.match_length <= ft.max_lazy_match && ft.lookahead >= At) {
        ft.match_length--;
        do
          ft.strstart++, ft.ins_h = (ft.ins_h << ft.hash_shift ^ ft.window[ft.strstart + At - 1]) & ft.hash_mask, Gt = ft.prev[ft.strstart & ft.w_mask] = ft.head[ft.ins_h], ft.head[ft.ins_h] = ft.strstart;
        while (--ft.match_length != 0);
        ft.strstart++;
      } else ft.strstart += ft.match_length, ft.match_length = 0, ft.ins_h = ft.window[ft.strstart], ft.ins_h = (ft.ins_h << ft.hash_shift ^ ft.window[ft.strstart + 1]) & ft.hash_mask;
      else zt = P._tr_tally(ft, 0, ft.window[ft.strstart]), ft.lookahead--, ft.strstart++;
      if (zt && (ut(ft, !1), ft.strm.avail_out === 0)) return Mt;
    }
    return ft.insert = ft.strstart < At - 1 ? ft.strstart : At - 1, qt === G ? (ut(ft, !0), ft.strm.avail_out === 0 ? It : mt) : ft.last_lit && (ut(ft, !1), ft.strm.avail_out === 0) ? Mt : nt;
  }
  function ee(ft, qt) {
    for (var Gt, zt, Qt; ; ) {
      if (ft.lookahead < xt) {
        if (Kt(ft), ft.lookahead < xt && qt === Z) return Mt;
        if (ft.lookahead === 0) break;
      }
      if (Gt = 0, ft.lookahead >= At && (ft.ins_h = (ft.ins_h << ft.hash_shift ^ ft.window[ft.strstart + At - 1]) & ft.hash_mask, Gt = ft.prev[ft.strstart & ft.w_mask] = ft.head[ft.ins_h], ft.head[ft.ins_h] = ft.strstart), ft.prev_length = ft.match_length, ft.prev_match = ft.match_start, ft.match_length = At - 1, Gt !== 0 && ft.prev_length < ft.max_lazy_match && ft.strstart - Gt <= ft.w_size - xt && (ft.match_length = jt(ft, Gt), ft.match_length <= 5 && (ft.strategy === V || ft.match_length === At && ft.strstart - ft.match_start > 4096) && (ft.match_length = At - 1)), ft.prev_length >= At && ft.match_length <= ft.prev_length) {
        Qt = ft.strstart + ft.lookahead - At, zt = P._tr_tally(ft, ft.strstart - 1 - ft.prev_match, ft.prev_length - At), ft.lookahead -= ft.prev_length - 1, ft.prev_length -= 2;
        do
          ++ft.strstart <= Qt && (ft.ins_h = (ft.ins_h << ft.hash_shift ^ ft.window[ft.strstart + At - 1]) & ft.hash_mask, Gt = ft.prev[ft.strstart & ft.w_mask] = ft.head[ft.ins_h], ft.head[ft.ins_h] = ft.strstart);
        while (--ft.prev_length != 0);
        if (ft.match_available = 0, ft.match_length = At - 1, ft.strstart++, zt && (ut(ft, !1), ft.strm.avail_out === 0)) return Mt;
      } else if (ft.match_available) {
        if ((zt = P._tr_tally(ft, 0, ft.window[ft.strstart - 1])) && ut(ft, !1), ft.strstart++, ft.lookahead--, ft.strm.avail_out === 0) return Mt;
      } else ft.match_available = 1, ft.strstart++, ft.lookahead--;
    }
    return ft.match_available && (zt = P._tr_tally(ft, 0, ft.window[ft.strstart - 1]), ft.match_available = 0), ft.insert = ft.strstart < At - 1 ? ft.strstart : At - 1, qt === G ? (ut(ft, !0), ft.strm.avail_out === 0 ? It : mt) : ft.last_lit && (ut(ft, !1), ft.strm.avail_out === 0) ? Mt : nt;
  }
  function Jt(ft, qt) {
    for (var Gt, zt, Qt, Ht, ue = ft.window; ; ) {
      if (ft.lookahead <= Ft) {
        if (Kt(ft), ft.lookahead <= Ft && qt === Z) return Mt;
        if (ft.lookahead === 0) break;
      }
      if (ft.match_length = 0, ft.lookahead >= At && ft.strstart > 0 && (zt = ue[Qt = ft.strstart - 1]) === ue[++Qt] && zt === ue[++Qt] && zt === ue[++Qt]) {
        Ht = ft.strstart + Ft;
        do
          ;
        while (zt === ue[++Qt] && zt === ue[++Qt] && zt === ue[++Qt] && zt === ue[++Qt] && zt === ue[++Qt] && zt === ue[++Qt] && zt === ue[++Qt] && zt === ue[++Qt] && Qt < Ht);
        ft.match_length = Ft - (Ht - Qt), ft.match_length > ft.lookahead && (ft.match_length = ft.lookahead);
      }
      if (ft.match_length >= At ? (Gt = P._tr_tally(ft, 1, ft.match_length - At), ft.lookahead -= ft.match_length, ft.strstart += ft.match_length, ft.match_length = 0) : (Gt = P._tr_tally(ft, 0, ft.window[ft.strstart]), ft.lookahead--, ft.strstart++), Gt && (ut(ft, !1), ft.strm.avail_out === 0)) return Mt;
    }
    return ft.insert = 0, qt === G ? (ut(ft, !0), ft.strm.avail_out === 0 ? It : mt) : ft.last_lit && (ut(ft, !1), ft.strm.avail_out === 0) ? Mt : nt;
  }
  function le(ft, qt) {
    for (var Gt; ; ) {
      if (ft.lookahead === 0 && (Kt(ft), ft.lookahead === 0)) {
        if (qt === Z) return Mt;
        break;
      }
      if (ft.match_length = 0, Gt = P._tr_tally(ft, 0, ft.window[ft.strstart]), ft.lookahead--, ft.strstart++, Gt && (ut(ft, !1), ft.strm.avail_out === 0)) return Mt;
    }
    return ft.insert = 0, qt === G ? (ut(ft, !0), ft.strm.avail_out === 0 ? It : mt) : ft.last_lit && (ut(ft, !1), ft.strm.avail_out === 0) ? Mt : nt;
  }
  function ae(ft, qt, Gt, zt, Qt) {
    this.good_length = ft, this.max_lazy = qt, this.nice_length = Gt, this.max_chain = zt, this.func = Qt;
  }
  function se(ft) {
    ft.window_size = 2 * ft.w_size, Rt(ft.head), ft.max_lazy_match = w[ft.level].max_lazy, ft.good_match = w[ft.level].good_length, ft.nice_match = w[ft.level].nice_length, ft.max_chain_length = w[ft.level].max_chain, ft.strstart = 0, ft.block_start = 0, ft.lookahead = 0, ft.insert = 0, ft.match_length = ft.prev_length = At - 1, ft.match_available = 0, ft.ins_h = 0;
  }
  function fe() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = ct, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new I.Buf16(2 * Ct), this.dyn_dtree = new I.Buf16(2 * (2 * ht + 1)), this.bl_tree = new I.Buf16(2 * (2 * pt + 1)), Rt(this.dyn_ltree), Rt(this.dyn_dtree), Rt(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new I.Buf16(St + 1), this.heap = new I.Buf16(2 * dt + 1), Rt(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new I.Buf16(2 * dt + 1), Rt(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
  }
  function ne(ft) {
    var qt;
    return ft && ft.state ? (ft.total_in = ft.total_out = 0, ft.data_type = at, (qt = ft.state).pending = 0, qt.pending_out = 0, qt.wrap < 0 && (qt.wrap = -qt.wrap), qt.status = qt.wrap ? Ot : Zt, ft.adler = qt.wrap === 2 ? 0 : 1, qt.last_flush = Z, P._tr_init(qt), H) : _t(ft, q);
  }
  function Nt(ft) {
    var qt = ne(ft);
    return qt === H && se(ft.state), qt;
  }
  function Xt(ft, qt) {
    return ft && ft.state ? ft.state.wrap !== 2 ? q : (ft.state.gzhead = qt, H) : q;
  }
  function Ut(ft, qt, Gt, zt, Qt, Ht) {
    if (!ft) return q;
    var ue = 1;
    if (qt === tt && (qt = 6), zt < 0 ? (ue = 0, zt = -zt) : zt > 15 && (ue = 2, zt -= 16), Qt < 1 || Qt > K || Gt !== ct || zt < 8 || zt > 15 || qt < 0 || qt > 9 || Ht < 0 || Ht > it) return _t(ft, q);
    zt === 8 && (zt = 9);
    var ie = new fe();
    return ft.state = ie, ie.strm = ft, ie.wrap = ue, ie.gzhead = null, ie.w_bits = zt, ie.w_size = 1 << ie.w_bits, ie.w_mask = ie.w_size - 1, ie.hash_bits = Qt + 7, ie.hash_size = 1 << ie.hash_bits, ie.hash_mask = ie.hash_size - 1, ie.hash_shift = ~~((ie.hash_bits + At - 1) / At), ie.window = new I.Buf8(2 * ie.w_size), ie.head = new I.Buf16(ie.hash_size), ie.prev = new I.Buf16(ie.w_size), ie.lit_bufsize = 1 << Qt + 6, ie.pending_buf_size = 4 * ie.lit_bufsize, ie.pending_buf = new I.Buf8(ie.pending_buf_size), ie.d_buf = 1 * ie.lit_bufsize, ie.l_buf = 3 * ie.lit_bufsize, ie.level = qt, ie.strategy = Ht, ie.method = Gt, Nt(ft);
  }
  function Wt(ft, qt) {
    return Ut(ft, qt, ct, lt, vt, st);
  }
  function Et(ft, qt) {
    var Gt, zt, Qt, Ht;
    if (!ft || !ft.state || qt > Q || qt < 0) return ft ? _t(ft, q) : q;
    if (zt = ft.state, !ft.output || !ft.input && ft.avail_in !== 0 || zt.status === $t && qt !== G) return _t(ft, ft.avail_out === 0 ? rt : q);
    if (zt.strm = ft, Gt = zt.last_flush, zt.last_flush = qt, zt.status === Ot) if (zt.wrap === 2) ft.adler = 0, bt(zt, 31), bt(zt, 139), bt(zt, 8), zt.gzhead ? (bt(zt, (zt.gzhead.text ? 1 : 0) + (zt.gzhead.hcrc ? 2 : 0) + (zt.gzhead.extra ? 4 : 0) + (zt.gzhead.name ? 8 : 0) + (zt.gzhead.comment ? 16 : 0)), bt(zt, 255 & zt.gzhead.time), bt(zt, zt.gzhead.time >> 8 & 255), bt(zt, zt.gzhead.time >> 16 & 255), bt(zt, zt.gzhead.time >> 24 & 255), bt(zt, zt.level === 9 ? 2 : zt.strategy >= X || zt.level < 2 ? 4 : 0), bt(zt, 255 & zt.gzhead.os), zt.gzhead.extra && zt.gzhead.extra.length && (bt(zt, 255 & zt.gzhead.extra.length), bt(zt, zt.gzhead.extra.length >> 8 & 255)), zt.gzhead.hcrc && (ft.adler = D(ft.adler, zt.pending_buf, zt.pending, 0)), zt.gzindex = 0, zt.status = Bt) : (bt(zt, 0), bt(zt, 0), bt(zt, 0), bt(zt, 0), bt(zt, 0), bt(zt, zt.level === 9 ? 2 : zt.strategy >= X || zt.level < 2 ? 4 : 0), bt(zt, gt), zt.status = Zt);
    else {
      var ue = ct + (zt.w_bits - 8 << 4) << 8;
      ue |= (zt.strategy >= X || zt.level < 2 ? 0 : zt.level < 6 ? 1 : zt.level === 6 ? 2 : 3) << 6, zt.strstart !== 0 && (ue |= Pt), ue += 31 - ue % 31, zt.status = Zt, yt(zt, ue), zt.strstart !== 0 && (yt(zt, ft.adler >>> 16), yt(zt, 65535 & ft.adler)), ft.adler = 1;
    }
    if (zt.status === Bt) if (zt.gzhead.extra) {
      for (Qt = zt.pending; zt.gzindex < (65535 & zt.gzhead.extra.length) && (zt.pending !== zt.pending_buf_size || (zt.gzhead.hcrc && zt.pending > Qt && (ft.adler = D(ft.adler, zt.pending_buf, zt.pending - Qt, Qt)), J(ft), Qt = zt.pending, zt.pending !== zt.pending_buf_size)); ) bt(zt, 255 & zt.gzhead.extra[zt.gzindex]), zt.gzindex++;
      zt.gzhead.hcrc && zt.pending > Qt && (ft.adler = D(ft.adler, zt.pending_buf, zt.pending - Qt, Qt)), zt.gzindex === zt.gzhead.extra.length && (zt.gzindex = 0, zt.status = kt);
    } else zt.status = kt;
    if (zt.status === kt) if (zt.gzhead.name) {
      Qt = zt.pending;
      do {
        if (zt.pending === zt.pending_buf_size && (zt.gzhead.hcrc && zt.pending > Qt && (ft.adler = D(ft.adler, zt.pending_buf, zt.pending - Qt, Qt)), J(ft), Qt = zt.pending, zt.pending === zt.pending_buf_size)) {
          Ht = 1;
          break;
        }
        Ht = zt.gzindex < zt.gzhead.name.length ? 255 & zt.gzhead.name.charCodeAt(zt.gzindex++) : 0, bt(zt, Ht);
      } while (Ht !== 0);
      zt.gzhead.hcrc && zt.pending > Qt && (ft.adler = D(ft.adler, zt.pending_buf, zt.pending - Qt, Qt)), Ht === 0 && (zt.gzindex = 0, zt.status = Tt);
    } else zt.status = Tt;
    if (zt.status === Tt) if (zt.gzhead.comment) {
      Qt = zt.pending;
      do {
        if (zt.pending === zt.pending_buf_size && (zt.gzhead.hcrc && zt.pending > Qt && (ft.adler = D(ft.adler, zt.pending_buf, zt.pending - Qt, Qt)), J(ft), Qt = zt.pending, zt.pending === zt.pending_buf_size)) {
          Ht = 1;
          break;
        }
        Ht = zt.gzindex < zt.gzhead.comment.length ? 255 & zt.gzhead.comment.charCodeAt(zt.gzindex++) : 0, bt(zt, Ht);
      } while (Ht !== 0);
      zt.gzhead.hcrc && zt.pending > Qt && (ft.adler = D(ft.adler, zt.pending_buf, zt.pending - Qt, Qt)), Ht === 0 && (zt.status = Dt);
    } else zt.status = Dt;
    if (zt.status === Dt && (zt.gzhead.hcrc ? (zt.pending + 2 > zt.pending_buf_size && J(ft), zt.pending + 2 <= zt.pending_buf_size && (bt(zt, 255 & ft.adler), bt(zt, ft.adler >> 8 & 255), ft.adler = 0, zt.status = Zt)) : zt.status = Zt), zt.pending !== 0) {
      if (J(ft), ft.avail_out === 0) return zt.last_flush = -1, H;
    } else if (ft.avail_in === 0 && wt(qt) <= wt(Gt) && qt !== G) return _t(ft, rt);
    if (zt.status === $t && ft.avail_in !== 0) return _t(ft, rt);
    if (ft.avail_in !== 0 || zt.lookahead !== 0 || qt !== Z && zt.status !== $t) {
      var ie = zt.strategy === X ? le(zt, qt) : zt.strategy === ot ? Jt(zt, qt) : w[zt.level].func(zt, qt);
      if (ie !== It && ie !== mt || (zt.status = $t), ie === Mt || ie === It) return ft.avail_out === 0 && (zt.last_flush = -1), H;
      if (ie === nt && (qt === $ ? P._tr_align(zt) : qt !== Q && (P._tr_stored_block(zt, 0, 0, !1), qt === j && (Rt(zt.head), zt.lookahead === 0 && (zt.strstart = 0, zt.block_start = 0, zt.insert = 0))), J(ft), ft.avail_out === 0)) return zt.last_flush = -1, H;
    }
    return qt !== G ? H : zt.wrap <= 0 ? W : (zt.wrap === 2 ? (bt(zt, 255 & ft.adler), bt(zt, ft.adler >> 8 & 255), bt(zt, ft.adler >> 16 & 255), bt(zt, ft.adler >> 24 & 255), bt(zt, 255 & ft.total_in), bt(zt, ft.total_in >> 8 & 255), bt(zt, ft.total_in >> 16 & 255), bt(zt, ft.total_in >> 24 & 255)) : (yt(zt, ft.adler >>> 16), yt(zt, 65535 & ft.adler)), J(ft), zt.wrap > 0 && (zt.wrap = -zt.wrap), zt.pending !== 0 ? H : W);
  }
  function Yt(ft) {
    var qt;
    return ft && ft.state ? (qt = ft.state.status) !== Ot && qt !== Bt && qt !== kt && qt !== Tt && qt !== Dt && qt !== Zt && qt !== $t ? _t(ft, q) : (ft.state = null, qt === Zt ? _t(ft, et) : H) : q;
  }
  function ce(ft, qt) {
    var Gt, zt, Qt, Ht, ue, ie, oe, he, Ee = qt.length;
    if (!ft || !ft.state || (Ht = (Gt = ft.state).wrap) === 2 || Ht === 1 && Gt.status !== Ot || Gt.lookahead) return q;
    for (Ht === 1 && (ft.adler = F(ft.adler, qt, Ee, 0)), Gt.wrap = 0, Ee >= Gt.w_size && (Ht === 0 && (Rt(Gt.head), Gt.strstart = 0, Gt.block_start = 0, Gt.insert = 0), he = new I.Buf8(Gt.w_size), I.arraySet(he, qt, Ee - Gt.w_size, Gt.w_size, 0), qt = he, Ee = Gt.w_size), ue = ft.avail_in, ie = ft.next_in, oe = ft.input, ft.avail_in = Ee, ft.next_in = 0, ft.input = qt, Kt(Gt); Gt.lookahead >= At; ) {
      zt = Gt.strstart, Qt = Gt.lookahead - (At - 1);
      do
        Gt.ins_h = (Gt.ins_h << Gt.hash_shift ^ Gt.window[zt + At - 1]) & Gt.hash_mask, Gt.prev[zt & Gt.w_mask] = Gt.head[Gt.ins_h], Gt.head[Gt.ins_h] = zt, zt++;
      while (--Qt);
      Gt.strstart = zt, Gt.lookahead = At - 1, Kt(Gt);
    }
    return Gt.strstart += Gt.lookahead, Gt.block_start = Gt.strstart, Gt.insert = Gt.lookahead, Gt.lookahead = 0, Gt.match_length = Gt.prev_length = At - 1, Gt.match_available = 0, ft.next_in = ie, ft.input = oe, ft.avail_in = ue, Gt.wrap = Ht, H;
  }
  w = [new ae(0, 0, 0, 0, te), new ae(4, 4, 8, 4, Vt), new ae(4, 5, 16, 8, Vt), new ae(4, 6, 32, 32, Vt), new ae(4, 4, 16, 16, ee), new ae(8, 16, 32, 32, ee), new ae(8, 16, 128, 128, ee), new ae(8, 32, 128, 256, ee), new ae(32, 128, 258, 1024, ee), new ae(32, 258, 258, 4096, ee)], g.deflateInit = Wt, g.deflateInit2 = Ut, g.deflateReset = Nt, g.deflateResetKeep = ne, g.deflateSetHeader = Xt, g.deflate = Et, g.deflateEnd = Yt, g.deflateSetDictionary = ce, g.deflateInfo = "pako deflate (from Nodeca project)";
}, { "../utils/common": 52, "./adler32": 53, "./crc32": 55, "./messages": 60, "./trees": 61 }], 57: [function(d, m, g) {
  var w = 30, I = 12;
  m.exports = function(P, F) {
    var D, U, Z, $, j, G, Q, H, W, q, et, rt, tt, V, X, ot, it, st, at, ct, K, lt, vt, dt, ht;
    D = P.state, U = P.next_in, dt = P.input, Z = U + (P.avail_in - 5), $ = P.next_out, ht = P.output, j = $ - (F - P.avail_out), G = $ + (P.avail_out - 257), Q = D.dmax, H = D.wsize, W = D.whave, q = D.wnext, et = D.window, rt = D.hold, tt = D.bits, V = D.lencode, X = D.distcode, ot = (1 << D.lenbits) - 1, it = (1 << D.distbits) - 1;
    t: do {
      tt < 15 && (rt += dt[U++] << tt, tt += 8, rt += dt[U++] << tt, tt += 8), st = V[rt & ot];
      e: for (; ; ) {
        if (rt >>>= at = st >>> 24, tt -= at, (at = st >>> 16 & 255) == 0) ht[$++] = 65535 & st;
        else {
          if (!(16 & at)) {
            if (64 & at) {
              if (32 & at) {
                D.mode = I;
                break t;
              }
              P.msg = "invalid literal/length code", D.mode = w;
              break t;
            }
            st = V[(65535 & st) + (rt & (1 << at) - 1)];
            continue e;
          }
          for (ct = 65535 & st, (at &= 15) && (tt < at && (rt += dt[U++] << tt, tt += 8), ct += rt & (1 << at) - 1, rt >>>= at, tt -= at), tt < 15 && (rt += dt[U++] << tt, tt += 8, rt += dt[U++] << tt, tt += 8), st = X[rt & it]; ; ) {
            if (rt >>>= at = st >>> 24, tt -= at, 16 & (at = st >>> 16 & 255)) {
              if (K = 65535 & st, tt < (at &= 15) && (rt += dt[U++] << tt, (tt += 8) < at && (rt += dt[U++] << tt, tt += 8)), (K += rt & (1 << at) - 1) > Q) {
                P.msg = "invalid distance too far back", D.mode = w;
                break t;
              }
              if (rt >>>= at, tt -= at, K > (at = $ - j)) {
                if ((at = K - at) > W && D.sane) {
                  P.msg = "invalid distance too far back", D.mode = w;
                  break t;
                }
                if (lt = 0, vt = et, q === 0) {
                  if (lt += H - at, at < ct) {
                    ct -= at;
                    do
                      ht[$++] = et[lt++];
                    while (--at);
                    lt = $ - K, vt = ht;
                  }
                } else if (q < at) {
                  if (lt += H + q - at, (at -= q) < ct) {
                    ct -= at;
                    do
                      ht[$++] = et[lt++];
                    while (--at);
                    if (lt = 0, q < ct) {
                      ct -= at = q;
                      do
                        ht[$++] = et[lt++];
                      while (--at);
                      lt = $ - K, vt = ht;
                    }
                  }
                } else if (lt += q - at, at < ct) {
                  ct -= at;
                  do
                    ht[$++] = et[lt++];
                  while (--at);
                  lt = $ - K, vt = ht;
                }
                for (; ct > 2; ) ht[$++] = vt[lt++], ht[$++] = vt[lt++], ht[$++] = vt[lt++], ct -= 3;
                ct && (ht[$++] = vt[lt++], ct > 1 && (ht[$++] = vt[lt++]));
              } else {
                lt = $ - K;
                do
                  ht[$++] = ht[lt++], ht[$++] = ht[lt++], ht[$++] = ht[lt++], ct -= 3;
                while (ct > 2);
                ct && (ht[$++] = ht[lt++], ct > 1 && (ht[$++] = ht[lt++]));
              }
              break;
            }
            if (64 & at) {
              P.msg = "invalid distance code", D.mode = w;
              break t;
            }
            st = X[(65535 & st) + (rt & (1 << at) - 1)];
          }
        }
        break;
      }
    } while (U < Z && $ < G);
    U -= ct = tt >> 3, rt &= (1 << (tt -= ct << 3)) - 1, P.next_in = U, P.next_out = $, P.avail_in = U < Z ? Z - U + 5 : 5 - (U - Z), P.avail_out = $ < G ? G - $ + 257 : 257 - ($ - G), D.hold = rt, D.bits = tt;
  };
}, {}], 58: [function(d, m, g) {
  var w = d("../utils/common"), I = d("./adler32"), P = d("./crc32"), F = d("./inffast"), D = d("./inftrees"), U = 0, Z = 1, $ = 2, j = 4, G = 5, Q = 6, H = 0, W = 1, q = 2, et = -2, rt = -3, tt = -4, V = -5, X = 8, ot = 1, it = 2, st = 3, at = 4, ct = 5, K = 6, lt = 7, vt = 8, dt = 9, ht = 10, pt = 11, Ct = 12, St = 13, At = 14, Ft = 15, xt = 16, Pt = 17, Ot = 18, Bt = 19, kt = 20, Tt = 21, Dt = 22, Zt = 23, $t = 24, Mt = 25, nt = 26, It = 27, mt = 28, gt = 29, _t = 30, wt = 31, Rt = 852, J = 592, ut = 15;
  function bt(Ut) {
    return (Ut >>> 24 & 255) + (Ut >>> 8 & 65280) + ((65280 & Ut) << 8) + ((255 & Ut) << 24);
  }
  function yt() {
    this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new w.Buf16(320), this.work = new w.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
  }
  function Lt(Ut) {
    var Wt;
    return Ut && Ut.state ? (Wt = Ut.state, Ut.total_in = Ut.total_out = Wt.total = 0, Ut.msg = "", Wt.wrap && (Ut.adler = 1 & Wt.wrap), Wt.mode = ot, Wt.last = 0, Wt.havedict = 0, Wt.dmax = 32768, Wt.head = null, Wt.hold = 0, Wt.bits = 0, Wt.lencode = Wt.lendyn = new w.Buf32(Rt), Wt.distcode = Wt.distdyn = new w.Buf32(J), Wt.sane = 1, Wt.back = -1, H) : et;
  }
  function jt(Ut) {
    var Wt;
    return Ut && Ut.state ? ((Wt = Ut.state).wsize = 0, Wt.whave = 0, Wt.wnext = 0, Lt(Ut)) : et;
  }
  function Kt(Ut, Wt) {
    var Et, Yt;
    return Ut && Ut.state ? (Yt = Ut.state, Wt < 0 ? (Et = 0, Wt = -Wt) : (Et = 1 + (Wt >> 4), Wt < 48 && (Wt &= 15)), Wt && (Wt < 8 || Wt > 15) ? et : (Yt.window !== null && Yt.wbits !== Wt && (Yt.window = null), Yt.wrap = Et, Yt.wbits = Wt, jt(Ut))) : et;
  }
  function te(Ut, Wt) {
    var Et, Yt;
    return Ut ? (Yt = new yt(), Ut.state = Yt, Yt.window = null, (Et = Kt(Ut, Wt)) !== H && (Ut.state = null), Et) : et;
  }
  function Vt(Ut) {
    return te(Ut, ut);
  }
  var ee, Jt, le = !0;
  function ae(Ut) {
    if (le) {
      var Wt;
      for (ee = new w.Buf32(512), Jt = new w.Buf32(32), Wt = 0; Wt < 144; ) Ut.lens[Wt++] = 8;
      for (; Wt < 256; ) Ut.lens[Wt++] = 9;
      for (; Wt < 280; ) Ut.lens[Wt++] = 7;
      for (; Wt < 288; ) Ut.lens[Wt++] = 8;
      for (D(Z, Ut.lens, 0, 288, ee, 0, Ut.work, { bits: 9 }), Wt = 0; Wt < 32; ) Ut.lens[Wt++] = 5;
      D($, Ut.lens, 0, 32, Jt, 0, Ut.work, { bits: 5 }), le = !1;
    }
    Ut.lencode = ee, Ut.lenbits = 9, Ut.distcode = Jt, Ut.distbits = 5;
  }
  function se(Ut, Wt, Et, Yt) {
    var ce, ft = Ut.state;
    return ft.window === null && (ft.wsize = 1 << ft.wbits, ft.wnext = 0, ft.whave = 0, ft.window = new w.Buf8(ft.wsize)), Yt >= ft.wsize ? (w.arraySet(ft.window, Wt, Et - ft.wsize, ft.wsize, 0), ft.wnext = 0, ft.whave = ft.wsize) : ((ce = ft.wsize - ft.wnext) > Yt && (ce = Yt), w.arraySet(ft.window, Wt, Et - Yt, ce, ft.wnext), (Yt -= ce) ? (w.arraySet(ft.window, Wt, Et - Yt, Yt, 0), ft.wnext = Yt, ft.whave = ft.wsize) : (ft.wnext += ce, ft.wnext === ft.wsize && (ft.wnext = 0), ft.whave < ft.wsize && (ft.whave += ce))), 0;
  }
  function fe(Ut, Wt) {
    var Et, Yt, ce, ft, qt, Gt, zt, Qt, Ht, ue, ie, oe, he, Ee, de, me, be, ye, Ie, Se, _e, we, ke, Ae, ve = 0, ge = new w.Buf8(4), Te = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    if (!Ut || !Ut.state || !Ut.output || !Ut.input && Ut.avail_in !== 0) return et;
    (Et = Ut.state).mode === Ct && (Et.mode = St), qt = Ut.next_out, ce = Ut.output, zt = Ut.avail_out, ft = Ut.next_in, Yt = Ut.input, Gt = Ut.avail_in, Qt = Et.hold, Ht = Et.bits, ue = Gt, ie = zt, we = H;
    t: for (; ; ) switch (Et.mode) {
      case ot:
        if (Et.wrap === 0) {
          Et.mode = St;
          break;
        }
        for (; Ht < 16; ) {
          if (Gt === 0) break t;
          Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
        }
        if (2 & Et.wrap && Qt === 35615) {
          Et.check = 0, ge[0] = 255 & Qt, ge[1] = Qt >>> 8 & 255, Et.check = P(Et.check, ge, 2, 0), Qt = 0, Ht = 0, Et.mode = it;
          break;
        }
        if (Et.flags = 0, Et.head && (Et.head.done = !1), !(1 & Et.wrap) || (((255 & Qt) << 8) + (Qt >> 8)) % 31) {
          Ut.msg = "incorrect header check", Et.mode = _t;
          break;
        }
        if ((15 & Qt) !== X) {
          Ut.msg = "unknown compression method", Et.mode = _t;
          break;
        }
        if (Ht -= 4, _e = 8 + (15 & (Qt >>>= 4)), Et.wbits === 0) Et.wbits = _e;
        else if (_e > Et.wbits) {
          Ut.msg = "invalid window size", Et.mode = _t;
          break;
        }
        Et.dmax = 1 << _e, Ut.adler = Et.check = 1, Et.mode = 512 & Qt ? ht : Ct, Qt = 0, Ht = 0;
        break;
      case it:
        for (; Ht < 16; ) {
          if (Gt === 0) break t;
          Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
        }
        if (Et.flags = Qt, (255 & Et.flags) !== X) {
          Ut.msg = "unknown compression method", Et.mode = _t;
          break;
        }
        if (57344 & Et.flags) {
          Ut.msg = "unknown header flags set", Et.mode = _t;
          break;
        }
        Et.head && (Et.head.text = Qt >> 8 & 1), 512 & Et.flags && (ge[0] = 255 & Qt, ge[1] = Qt >>> 8 & 255, Et.check = P(Et.check, ge, 2, 0)), Qt = 0, Ht = 0, Et.mode = st;
      case st:
        for (; Ht < 32; ) {
          if (Gt === 0) break t;
          Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
        }
        Et.head && (Et.head.time = Qt), 512 & Et.flags && (ge[0] = 255 & Qt, ge[1] = Qt >>> 8 & 255, ge[2] = Qt >>> 16 & 255, ge[3] = Qt >>> 24 & 255, Et.check = P(Et.check, ge, 4, 0)), Qt = 0, Ht = 0, Et.mode = at;
      case at:
        for (; Ht < 16; ) {
          if (Gt === 0) break t;
          Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
        }
        Et.head && (Et.head.xflags = 255 & Qt, Et.head.os = Qt >> 8), 512 & Et.flags && (ge[0] = 255 & Qt, ge[1] = Qt >>> 8 & 255, Et.check = P(Et.check, ge, 2, 0)), Qt = 0, Ht = 0, Et.mode = ct;
      case ct:
        if (1024 & Et.flags) {
          for (; Ht < 16; ) {
            if (Gt === 0) break t;
            Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
          }
          Et.length = Qt, Et.head && (Et.head.extra_len = Qt), 512 & Et.flags && (ge[0] = 255 & Qt, ge[1] = Qt >>> 8 & 255, Et.check = P(Et.check, ge, 2, 0)), Qt = 0, Ht = 0;
        } else Et.head && (Et.head.extra = null);
        Et.mode = K;
      case K:
        if (1024 & Et.flags && ((oe = Et.length) > Gt && (oe = Gt), oe && (Et.head && (_e = Et.head.extra_len - Et.length, Et.head.extra || (Et.head.extra = new Array(Et.head.extra_len)), w.arraySet(Et.head.extra, Yt, ft, oe, _e)), 512 & Et.flags && (Et.check = P(Et.check, Yt, oe, ft)), Gt -= oe, ft += oe, Et.length -= oe), Et.length)) break t;
        Et.length = 0, Et.mode = lt;
      case lt:
        if (2048 & Et.flags) {
          if (Gt === 0) break t;
          oe = 0;
          do
            _e = Yt[ft + oe++], Et.head && _e && Et.length < 65536 && (Et.head.name += String.fromCharCode(_e));
          while (_e && oe < Gt);
          if (512 & Et.flags && (Et.check = P(Et.check, Yt, oe, ft)), Gt -= oe, ft += oe, _e) break t;
        } else Et.head && (Et.head.name = null);
        Et.length = 0, Et.mode = vt;
      case vt:
        if (4096 & Et.flags) {
          if (Gt === 0) break t;
          oe = 0;
          do
            _e = Yt[ft + oe++], Et.head && _e && Et.length < 65536 && (Et.head.comment += String.fromCharCode(_e));
          while (_e && oe < Gt);
          if (512 & Et.flags && (Et.check = P(Et.check, Yt, oe, ft)), Gt -= oe, ft += oe, _e) break t;
        } else Et.head && (Et.head.comment = null);
        Et.mode = dt;
      case dt:
        if (512 & Et.flags) {
          for (; Ht < 16; ) {
            if (Gt === 0) break t;
            Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
          }
          if (Qt !== (65535 & Et.check)) {
            Ut.msg = "header crc mismatch", Et.mode = _t;
            break;
          }
          Qt = 0, Ht = 0;
        }
        Et.head && (Et.head.hcrc = Et.flags >> 9 & 1, Et.head.done = !0), Ut.adler = Et.check = 0, Et.mode = Ct;
        break;
      case ht:
        for (; Ht < 32; ) {
          if (Gt === 0) break t;
          Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
        }
        Ut.adler = Et.check = bt(Qt), Qt = 0, Ht = 0, Et.mode = pt;
      case pt:
        if (Et.havedict === 0) return Ut.next_out = qt, Ut.avail_out = zt, Ut.next_in = ft, Ut.avail_in = Gt, Et.hold = Qt, Et.bits = Ht, q;
        Ut.adler = Et.check = 1, Et.mode = Ct;
      case Ct:
        if (Wt === G || Wt === Q) break t;
      case St:
        if (Et.last) {
          Qt >>>= 7 & Ht, Ht -= 7 & Ht, Et.mode = It;
          break;
        }
        for (; Ht < 3; ) {
          if (Gt === 0) break t;
          Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
        }
        switch (Et.last = 1 & Qt, Ht -= 1, 3 & (Qt >>>= 1)) {
          case 0:
            Et.mode = At;
            break;
          case 1:
            if (ae(Et), Et.mode = kt, Wt === Q) {
              Qt >>>= 2, Ht -= 2;
              break t;
            }
            break;
          case 2:
            Et.mode = Pt;
            break;
          case 3:
            Ut.msg = "invalid block type", Et.mode = _t;
        }
        Qt >>>= 2, Ht -= 2;
        break;
      case At:
        for (Qt >>>= 7 & Ht, Ht -= 7 & Ht; Ht < 32; ) {
          if (Gt === 0) break t;
          Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
        }
        if ((65535 & Qt) != (Qt >>> 16 ^ 65535)) {
          Ut.msg = "invalid stored block lengths", Et.mode = _t;
          break;
        }
        if (Et.length = 65535 & Qt, Qt = 0, Ht = 0, Et.mode = Ft, Wt === Q) break t;
      case Ft:
        Et.mode = xt;
      case xt:
        if (oe = Et.length) {
          if (oe > Gt && (oe = Gt), oe > zt && (oe = zt), oe === 0) break t;
          w.arraySet(ce, Yt, ft, oe, qt), Gt -= oe, ft += oe, zt -= oe, qt += oe, Et.length -= oe;
          break;
        }
        Et.mode = Ct;
        break;
      case Pt:
        for (; Ht < 14; ) {
          if (Gt === 0) break t;
          Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
        }
        if (Et.nlen = 257 + (31 & Qt), Qt >>>= 5, Ht -= 5, Et.ndist = 1 + (31 & Qt), Qt >>>= 5, Ht -= 5, Et.ncode = 4 + (15 & Qt), Qt >>>= 4, Ht -= 4, Et.nlen > 286 || Et.ndist > 30) {
          Ut.msg = "too many length or distance symbols", Et.mode = _t;
          break;
        }
        Et.have = 0, Et.mode = Ot;
      case Ot:
        for (; Et.have < Et.ncode; ) {
          for (; Ht < 3; ) {
            if (Gt === 0) break t;
            Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
          }
          Et.lens[Te[Et.have++]] = 7 & Qt, Qt >>>= 3, Ht -= 3;
        }
        for (; Et.have < 19; ) Et.lens[Te[Et.have++]] = 0;
        if (Et.lencode = Et.lendyn, Et.lenbits = 7, ke = { bits: Et.lenbits }, we = D(U, Et.lens, 0, 19, Et.lencode, 0, Et.work, ke), Et.lenbits = ke.bits, we) {
          Ut.msg = "invalid code lengths set", Et.mode = _t;
          break;
        }
        Et.have = 0, Et.mode = Bt;
      case Bt:
        for (; Et.have < Et.nlen + Et.ndist; ) {
          for (; me = (ve = Et.lencode[Qt & (1 << Et.lenbits) - 1]) >>> 16 & 255, be = 65535 & ve, !((de = ve >>> 24) <= Ht); ) {
            if (Gt === 0) break t;
            Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
          }
          if (be < 16) Qt >>>= de, Ht -= de, Et.lens[Et.have++] = be;
          else {
            if (be === 16) {
              for (Ae = de + 2; Ht < Ae; ) {
                if (Gt === 0) break t;
                Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
              }
              if (Qt >>>= de, Ht -= de, Et.have === 0) {
                Ut.msg = "invalid bit length repeat", Et.mode = _t;
                break;
              }
              _e = Et.lens[Et.have - 1], oe = 3 + (3 & Qt), Qt >>>= 2, Ht -= 2;
            } else if (be === 17) {
              for (Ae = de + 3; Ht < Ae; ) {
                if (Gt === 0) break t;
                Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
              }
              Ht -= de, _e = 0, oe = 3 + (7 & (Qt >>>= de)), Qt >>>= 3, Ht -= 3;
            } else {
              for (Ae = de + 7; Ht < Ae; ) {
                if (Gt === 0) break t;
                Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
              }
              Ht -= de, _e = 0, oe = 11 + (127 & (Qt >>>= de)), Qt >>>= 7, Ht -= 7;
            }
            if (Et.have + oe > Et.nlen + Et.ndist) {
              Ut.msg = "invalid bit length repeat", Et.mode = _t;
              break;
            }
            for (; oe--; ) Et.lens[Et.have++] = _e;
          }
        }
        if (Et.mode === _t) break;
        if (Et.lens[256] === 0) {
          Ut.msg = "invalid code -- missing end-of-block", Et.mode = _t;
          break;
        }
        if (Et.lenbits = 9, ke = { bits: Et.lenbits }, we = D(Z, Et.lens, 0, Et.nlen, Et.lencode, 0, Et.work, ke), Et.lenbits = ke.bits, we) {
          Ut.msg = "invalid literal/lengths set", Et.mode = _t;
          break;
        }
        if (Et.distbits = 6, Et.distcode = Et.distdyn, ke = { bits: Et.distbits }, we = D($, Et.lens, Et.nlen, Et.ndist, Et.distcode, 0, Et.work, ke), Et.distbits = ke.bits, we) {
          Ut.msg = "invalid distances set", Et.mode = _t;
          break;
        }
        if (Et.mode = kt, Wt === Q) break t;
      case kt:
        Et.mode = Tt;
      case Tt:
        if (Gt >= 6 && zt >= 258) {
          Ut.next_out = qt, Ut.avail_out = zt, Ut.next_in = ft, Ut.avail_in = Gt, Et.hold = Qt, Et.bits = Ht, F(Ut, ie), qt = Ut.next_out, ce = Ut.output, zt = Ut.avail_out, ft = Ut.next_in, Yt = Ut.input, Gt = Ut.avail_in, Qt = Et.hold, Ht = Et.bits, Et.mode === Ct && (Et.back = -1);
          break;
        }
        for (Et.back = 0; me = (ve = Et.lencode[Qt & (1 << Et.lenbits) - 1]) >>> 16 & 255, be = 65535 & ve, !((de = ve >>> 24) <= Ht); ) {
          if (Gt === 0) break t;
          Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
        }
        if (me && !(240 & me)) {
          for (ye = de, Ie = me, Se = be; me = (ve = Et.lencode[Se + ((Qt & (1 << ye + Ie) - 1) >> ye)]) >>> 16 & 255, be = 65535 & ve, !(ye + (de = ve >>> 24) <= Ht); ) {
            if (Gt === 0) break t;
            Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
          }
          Qt >>>= ye, Ht -= ye, Et.back += ye;
        }
        if (Qt >>>= de, Ht -= de, Et.back += de, Et.length = be, me === 0) {
          Et.mode = nt;
          break;
        }
        if (32 & me) {
          Et.back = -1, Et.mode = Ct;
          break;
        }
        if (64 & me) {
          Ut.msg = "invalid literal/length code", Et.mode = _t;
          break;
        }
        Et.extra = 15 & me, Et.mode = Dt;
      case Dt:
        if (Et.extra) {
          for (Ae = Et.extra; Ht < Ae; ) {
            if (Gt === 0) break t;
            Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
          }
          Et.length += Qt & (1 << Et.extra) - 1, Qt >>>= Et.extra, Ht -= Et.extra, Et.back += Et.extra;
        }
        Et.was = Et.length, Et.mode = Zt;
      case Zt:
        for (; me = (ve = Et.distcode[Qt & (1 << Et.distbits) - 1]) >>> 16 & 255, be = 65535 & ve, !((de = ve >>> 24) <= Ht); ) {
          if (Gt === 0) break t;
          Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
        }
        if (!(240 & me)) {
          for (ye = de, Ie = me, Se = be; me = (ve = Et.distcode[Se + ((Qt & (1 << ye + Ie) - 1) >> ye)]) >>> 16 & 255, be = 65535 & ve, !(ye + (de = ve >>> 24) <= Ht); ) {
            if (Gt === 0) break t;
            Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
          }
          Qt >>>= ye, Ht -= ye, Et.back += ye;
        }
        if (Qt >>>= de, Ht -= de, Et.back += de, 64 & me) {
          Ut.msg = "invalid distance code", Et.mode = _t;
          break;
        }
        Et.offset = be, Et.extra = 15 & me, Et.mode = $t;
      case $t:
        if (Et.extra) {
          for (Ae = Et.extra; Ht < Ae; ) {
            if (Gt === 0) break t;
            Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
          }
          Et.offset += Qt & (1 << Et.extra) - 1, Qt >>>= Et.extra, Ht -= Et.extra, Et.back += Et.extra;
        }
        if (Et.offset > Et.dmax) {
          Ut.msg = "invalid distance too far back", Et.mode = _t;
          break;
        }
        Et.mode = Mt;
      case Mt:
        if (zt === 0) break t;
        if (oe = ie - zt, Et.offset > oe) {
          if ((oe = Et.offset - oe) > Et.whave && Et.sane) {
            Ut.msg = "invalid distance too far back", Et.mode = _t;
            break;
          }
          oe > Et.wnext ? (oe -= Et.wnext, he = Et.wsize - oe) : he = Et.wnext - oe, oe > Et.length && (oe = Et.length), Ee = Et.window;
        } else Ee = ce, he = qt - Et.offset, oe = Et.length;
        oe > zt && (oe = zt), zt -= oe, Et.length -= oe;
        do
          ce[qt++] = Ee[he++];
        while (--oe);
        Et.length === 0 && (Et.mode = Tt);
        break;
      case nt:
        if (zt === 0) break t;
        ce[qt++] = Et.length, zt--, Et.mode = Tt;
        break;
      case It:
        if (Et.wrap) {
          for (; Ht < 32; ) {
            if (Gt === 0) break t;
            Gt--, Qt |= Yt[ft++] << Ht, Ht += 8;
          }
          if (ie -= zt, Ut.total_out += ie, Et.total += ie, ie && (Ut.adler = Et.check = Et.flags ? P(Et.check, ce, ie, qt - ie) : I(Et.check, ce, ie, qt - ie)), ie = zt, (Et.flags ? Qt : bt(Qt)) !== Et.check) {
            Ut.msg = "incorrect data check", Et.mode = _t;
            break;
          }
          Qt = 0, Ht = 0;
        }
        Et.mode = mt;
      case mt:
        if (Et.wrap && Et.flags) {
          for (; Ht < 32; ) {
            if (Gt === 0) break t;
            Gt--, Qt += Yt[ft++] << Ht, Ht += 8;
          }
          if (Qt !== (4294967295 & Et.total)) {
            Ut.msg = "incorrect length check", Et.mode = _t;
            break;
          }
          Qt = 0, Ht = 0;
        }
        Et.mode = gt;
      case gt:
        we = W;
        break t;
      case _t:
        we = rt;
        break t;
      case wt:
        return tt;
      default:
        return et;
    }
    return Ut.next_out = qt, Ut.avail_out = zt, Ut.next_in = ft, Ut.avail_in = Gt, Et.hold = Qt, Et.bits = Ht, (Et.wsize || ie !== Ut.avail_out && Et.mode < _t && (Et.mode < It || Wt !== j)) && se(Ut, Ut.output, Ut.next_out, ie - Ut.avail_out), ue -= Ut.avail_in, ie -= Ut.avail_out, Ut.total_in += ue, Ut.total_out += ie, Et.total += ie, Et.wrap && ie && (Ut.adler = Et.check = Et.flags ? P(Et.check, ce, ie, Ut.next_out - ie) : I(Et.check, ce, ie, Ut.next_out - ie)), Ut.data_type = Et.bits + (Et.last ? 64 : 0) + (Et.mode === Ct ? 128 : 0) + (Et.mode === kt || Et.mode === Ft ? 256 : 0), (ue === 0 && ie === 0 || Wt === j) && we === H && (we = V), we;
  }
  function ne(Ut) {
    if (!Ut || !Ut.state) return et;
    var Wt = Ut.state;
    return Wt.window && (Wt.window = null), Ut.state = null, H;
  }
  function Nt(Ut, Wt) {
    var Et;
    return Ut && Ut.state && 2 & (Et = Ut.state).wrap ? (Et.head = Wt, Wt.done = !1, H) : et;
  }
  function Xt(Ut, Wt) {
    var Et, Yt = Wt.length;
    return Ut && Ut.state ? (Et = Ut.state).wrap !== 0 && Et.mode !== pt ? et : Et.mode === pt && I(1, Wt, Yt, 0) !== Et.check ? rt : se(Ut, Wt, Yt, Yt) ? (Et.mode = wt, tt) : (Et.havedict = 1, H) : et;
  }
  g.inflateReset = jt, g.inflateReset2 = Kt, g.inflateResetKeep = Lt, g.inflateInit = Vt, g.inflateInit2 = te, g.inflate = fe, g.inflateEnd = ne, g.inflateGetHeader = Nt, g.inflateSetDictionary = Xt, g.inflateInfo = "pako inflate (from Nodeca project)";
}, { "../utils/common": 52, "./adler32": 53, "./crc32": 55, "./inffast": 57, "./inftrees": 59 }], 59: [function(d, m, g) {
  var w = d("../utils/common"), I = 15, P = 852, F = 592, D = 0, U = 1, Z = 2, $ = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], j = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], G = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], Q = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
  m.exports = function(H, W, q, et, rt, tt, V, X) {
    var ot, it, st, at, ct, K, lt, vt, dt, ht = X.bits, pt = 0, Ct = 0, St = 0, At = 0, Ft = 0, xt = 0, Pt = 0, Ot = 0, Bt = 0, kt = 0, Tt = null, Dt = 0, Zt = new w.Buf16(I + 1), $t = new w.Buf16(I + 1), Mt = null, nt = 0;
    for (pt = 0; pt <= I; pt++) Zt[pt] = 0;
    for (Ct = 0; Ct < et; Ct++) Zt[W[q + Ct]]++;
    for (Ft = ht, At = I; At >= 1 && Zt[At] === 0; At--) ;
    if (Ft > At && (Ft = At), At === 0) return rt[tt++] = 20971520, rt[tt++] = 20971520, X.bits = 1, 0;
    for (St = 1; St < At && Zt[St] === 0; St++) ;
    for (Ft < St && (Ft = St), Ot = 1, pt = 1; pt <= I; pt++) if (Ot <<= 1, (Ot -= Zt[pt]) < 0) return -1;
    if (Ot > 0 && (H === D || At !== 1)) return -1;
    for ($t[1] = 0, pt = 1; pt < I; pt++) $t[pt + 1] = $t[pt] + Zt[pt];
    for (Ct = 0; Ct < et; Ct++) W[q + Ct] !== 0 && (V[$t[W[q + Ct]]++] = Ct);
    if (H === D ? (Tt = Mt = V, K = 19) : H === U ? (Tt = $, Dt -= 257, Mt = j, nt -= 257, K = 256) : (Tt = G, Mt = Q, K = -1), kt = 0, Ct = 0, pt = St, ct = tt, xt = Ft, Pt = 0, st = -1, at = (Bt = 1 << Ft) - 1, H === U && Bt > P || H === Z && Bt > F) return 1;
    for (; ; ) {
      lt = pt - Pt, V[Ct] < K ? (vt = 0, dt = V[Ct]) : V[Ct] > K ? (vt = Mt[nt + V[Ct]], dt = Tt[Dt + V[Ct]]) : (vt = 96, dt = 0), ot = 1 << pt - Pt, St = it = 1 << xt;
      do
        rt[ct + (kt >> Pt) + (it -= ot)] = lt << 24 | vt << 16 | dt;
      while (it !== 0);
      for (ot = 1 << pt - 1; kt & ot; ) ot >>= 1;
      if (ot !== 0 ? (kt &= ot - 1, kt += ot) : kt = 0, Ct++, --Zt[pt] == 0) {
        if (pt === At) break;
        pt = W[q + V[Ct]];
      }
      if (pt > Ft && (kt & at) !== st) {
        for (Pt === 0 && (Pt = Ft), ct += St, Ot = 1 << (xt = pt - Pt); xt + Pt < At && !((Ot -= Zt[xt + Pt]) <= 0); ) xt++, Ot <<= 1;
        if (Bt += 1 << xt, H === U && Bt > P || H === Z && Bt > F) return 1;
        rt[st = kt & at] = Ft << 24 | xt << 16 | ct - tt;
      }
    }
    return kt !== 0 && (rt[ct + kt] = pt - Pt << 24 | 64 << 16), X.bits = Ft, 0;
  };
}, { "../utils/common": 52 }], 60: [function(d, m, g) {
  m.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
}, {}], 61: [function(d, m, g) {
  var w = d("../utils/common"), I = 4, P = 0, F = 1, D = 2;
  function U(Nt) {
    for (var Xt = Nt.length; --Xt >= 0; ) Nt[Xt] = 0;
  }
  var Z = 0, $ = 1, j = 2, G = 3, Q = 258, H = 29, W = 256, q = W + 1 + H, et = 30, rt = 19, tt = 2 * q + 1, V = 15, X = 16, ot = 7, it = 256, st = 16, at = 17, ct = 18, K = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], lt = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], vt = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], dt = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], ht = 512, pt = new Array(2 * (q + 2));
  U(pt);
  var Ct = new Array(2 * et);
  U(Ct);
  var St = new Array(ht);
  U(St);
  var At = new Array(Q - G + 1);
  U(At);
  var Ft = new Array(H);
  U(Ft);
  var xt, Pt, Ot, Bt = new Array(et);
  function kt(Nt, Xt, Ut, Wt, Et) {
    this.static_tree = Nt, this.extra_bits = Xt, this.extra_base = Ut, this.elems = Wt, this.max_length = Et, this.has_stree = Nt && Nt.length;
  }
  function Tt(Nt, Xt) {
    this.dyn_tree = Nt, this.max_code = 0, this.stat_desc = Xt;
  }
  function Dt(Nt) {
    return Nt < 256 ? St[Nt] : St[256 + (Nt >>> 7)];
  }
  function Zt(Nt, Xt) {
    Nt.pending_buf[Nt.pending++] = 255 & Xt, Nt.pending_buf[Nt.pending++] = Xt >>> 8 & 255;
  }
  function $t(Nt, Xt, Ut) {
    Nt.bi_valid > X - Ut ? (Nt.bi_buf |= Xt << Nt.bi_valid & 65535, Zt(Nt, Nt.bi_buf), Nt.bi_buf = Xt >> X - Nt.bi_valid, Nt.bi_valid += Ut - X) : (Nt.bi_buf |= Xt << Nt.bi_valid & 65535, Nt.bi_valid += Ut);
  }
  function Mt(Nt, Xt, Ut) {
    $t(Nt, Ut[2 * Xt], Ut[2 * Xt + 1]);
  }
  function nt(Nt, Xt) {
    var Ut = 0;
    do
      Ut |= 1 & Nt, Nt >>>= 1, Ut <<= 1;
    while (--Xt > 0);
    return Ut >>> 1;
  }
  function It(Nt) {
    Nt.bi_valid === 16 ? (Zt(Nt, Nt.bi_buf), Nt.bi_buf = 0, Nt.bi_valid = 0) : Nt.bi_valid >= 8 && (Nt.pending_buf[Nt.pending++] = 255 & Nt.bi_buf, Nt.bi_buf >>= 8, Nt.bi_valid -= 8);
  }
  function mt(Nt, Xt) {
    var Ut, Wt, Et, Yt, ce, ft, qt = Xt.dyn_tree, Gt = Xt.max_code, zt = Xt.stat_desc.static_tree, Qt = Xt.stat_desc.has_stree, Ht = Xt.stat_desc.extra_bits, ue = Xt.stat_desc.extra_base, ie = Xt.stat_desc.max_length, oe = 0;
    for (Yt = 0; Yt <= V; Yt++) Nt.bl_count[Yt] = 0;
    for (qt[2 * Nt.heap[Nt.heap_max] + 1] = 0, Ut = Nt.heap_max + 1; Ut < tt; Ut++) (Yt = qt[2 * qt[2 * (Wt = Nt.heap[Ut]) + 1] + 1] + 1) > ie && (Yt = ie, oe++), qt[2 * Wt + 1] = Yt, Wt > Gt || (Nt.bl_count[Yt]++, ce = 0, Wt >= ue && (ce = Ht[Wt - ue]), ft = qt[2 * Wt], Nt.opt_len += ft * (Yt + ce), Qt && (Nt.static_len += ft * (zt[2 * Wt + 1] + ce)));
    if (oe !== 0) {
      do {
        for (Yt = ie - 1; Nt.bl_count[Yt] === 0; ) Yt--;
        Nt.bl_count[Yt]--, Nt.bl_count[Yt + 1] += 2, Nt.bl_count[ie]--, oe -= 2;
      } while (oe > 0);
      for (Yt = ie; Yt !== 0; Yt--) for (Wt = Nt.bl_count[Yt]; Wt !== 0; ) (Et = Nt.heap[--Ut]) > Gt || (qt[2 * Et + 1] !== Yt && (Nt.opt_len += (Yt - qt[2 * Et + 1]) * qt[2 * Et], qt[2 * Et + 1] = Yt), Wt--);
    }
  }
  function gt(Nt, Xt, Ut) {
    var Wt, Et, Yt = new Array(V + 1), ce = 0;
    for (Wt = 1; Wt <= V; Wt++) Yt[Wt] = ce = ce + Ut[Wt - 1] << 1;
    for (Et = 0; Et <= Xt; Et++) {
      var ft = Nt[2 * Et + 1];
      ft !== 0 && (Nt[2 * Et] = nt(Yt[ft]++, ft));
    }
  }
  function _t() {
    var Nt, Xt, Ut, Wt, Et, Yt = new Array(V + 1);
    for (Ut = 0, Wt = 0; Wt < H - 1; Wt++) for (Ft[Wt] = Ut, Nt = 0; Nt < 1 << K[Wt]; Nt++) At[Ut++] = Wt;
    for (At[Ut - 1] = Wt, Et = 0, Wt = 0; Wt < 16; Wt++) for (Bt[Wt] = Et, Nt = 0; Nt < 1 << lt[Wt]; Nt++) St[Et++] = Wt;
    for (Et >>= 7; Wt < et; Wt++) for (Bt[Wt] = Et << 7, Nt = 0; Nt < 1 << lt[Wt] - 7; Nt++) St[256 + Et++] = Wt;
    for (Xt = 0; Xt <= V; Xt++) Yt[Xt] = 0;
    for (Nt = 0; Nt <= 143; ) pt[2 * Nt + 1] = 8, Nt++, Yt[8]++;
    for (; Nt <= 255; ) pt[2 * Nt + 1] = 9, Nt++, Yt[9]++;
    for (; Nt <= 279; ) pt[2 * Nt + 1] = 7, Nt++, Yt[7]++;
    for (; Nt <= 287; ) pt[2 * Nt + 1] = 8, Nt++, Yt[8]++;
    for (gt(pt, q + 1, Yt), Nt = 0; Nt < et; Nt++) Ct[2 * Nt + 1] = 5, Ct[2 * Nt] = nt(Nt, 5);
    xt = new kt(pt, K, W + 1, q, V), Pt = new kt(Ct, lt, 0, et, V), Ot = new kt(new Array(0), vt, 0, rt, ot);
  }
  function wt(Nt) {
    var Xt;
    for (Xt = 0; Xt < q; Xt++) Nt.dyn_ltree[2 * Xt] = 0;
    for (Xt = 0; Xt < et; Xt++) Nt.dyn_dtree[2 * Xt] = 0;
    for (Xt = 0; Xt < rt; Xt++) Nt.bl_tree[2 * Xt] = 0;
    Nt.dyn_ltree[2 * it] = 1, Nt.opt_len = Nt.static_len = 0, Nt.last_lit = Nt.matches = 0;
  }
  function Rt(Nt) {
    Nt.bi_valid > 8 ? Zt(Nt, Nt.bi_buf) : Nt.bi_valid > 0 && (Nt.pending_buf[Nt.pending++] = Nt.bi_buf), Nt.bi_buf = 0, Nt.bi_valid = 0;
  }
  function J(Nt, Xt, Ut, Wt) {
    Rt(Nt), Zt(Nt, Ut), Zt(Nt, ~Ut), w.arraySet(Nt.pending_buf, Nt.window, Xt, Ut, Nt.pending), Nt.pending += Ut;
  }
  function ut(Nt, Xt, Ut, Wt) {
    var Et = 2 * Xt, Yt = 2 * Ut;
    return Nt[Et] < Nt[Yt] || Nt[Et] === Nt[Yt] && Wt[Xt] <= Wt[Ut];
  }
  function bt(Nt, Xt, Ut) {
    for (var Wt = Nt.heap[Ut], Et = Ut << 1; Et <= Nt.heap_len && (Et < Nt.heap_len && ut(Xt, Nt.heap[Et + 1], Nt.heap[Et], Nt.depth) && Et++, !ut(Xt, Wt, Nt.heap[Et], Nt.depth)); ) Nt.heap[Ut] = Nt.heap[Et], Ut = Et, Et <<= 1;
    Nt.heap[Ut] = Wt;
  }
  function yt(Nt, Xt, Ut) {
    var Wt, Et, Yt, ce, ft = 0;
    if (Nt.last_lit !== 0) do
      Wt = Nt.pending_buf[Nt.d_buf + 2 * ft] << 8 | Nt.pending_buf[Nt.d_buf + 2 * ft + 1], Et = Nt.pending_buf[Nt.l_buf + ft], ft++, Wt === 0 ? Mt(Nt, Et, Xt) : (Mt(Nt, (Yt = At[Et]) + W + 1, Xt), (ce = K[Yt]) !== 0 && $t(Nt, Et -= Ft[Yt], ce), Mt(Nt, Yt = Dt(--Wt), Ut), (ce = lt[Yt]) !== 0 && $t(Nt, Wt -= Bt[Yt], ce));
    while (ft < Nt.last_lit);
    Mt(Nt, it, Xt);
  }
  function Lt(Nt, Xt) {
    var Ut, Wt, Et, Yt = Xt.dyn_tree, ce = Xt.stat_desc.static_tree, ft = Xt.stat_desc.has_stree, qt = Xt.stat_desc.elems, Gt = -1;
    for (Nt.heap_len = 0, Nt.heap_max = tt, Ut = 0; Ut < qt; Ut++) Yt[2 * Ut] !== 0 ? (Nt.heap[++Nt.heap_len] = Gt = Ut, Nt.depth[Ut] = 0) : Yt[2 * Ut + 1] = 0;
    for (; Nt.heap_len < 2; ) Yt[2 * (Et = Nt.heap[++Nt.heap_len] = Gt < 2 ? ++Gt : 0)] = 1, Nt.depth[Et] = 0, Nt.opt_len--, ft && (Nt.static_len -= ce[2 * Et + 1]);
    for (Xt.max_code = Gt, Ut = Nt.heap_len >> 1; Ut >= 1; Ut--) bt(Nt, Yt, Ut);
    Et = qt;
    do
      Ut = Nt.heap[1], Nt.heap[1] = Nt.heap[Nt.heap_len--], bt(Nt, Yt, 1), Wt = Nt.heap[1], Nt.heap[--Nt.heap_max] = Ut, Nt.heap[--Nt.heap_max] = Wt, Yt[2 * Et] = Yt[2 * Ut] + Yt[2 * Wt], Nt.depth[Et] = (Nt.depth[Ut] >= Nt.depth[Wt] ? Nt.depth[Ut] : Nt.depth[Wt]) + 1, Yt[2 * Ut + 1] = Yt[2 * Wt + 1] = Et, Nt.heap[1] = Et++, bt(Nt, Yt, 1);
    while (Nt.heap_len >= 2);
    Nt.heap[--Nt.heap_max] = Nt.heap[1], mt(Nt, Xt), gt(Yt, Gt, Nt.bl_count);
  }
  function jt(Nt, Xt, Ut) {
    var Wt, Et, Yt = -1, ce = Xt[1], ft = 0, qt = 7, Gt = 4;
    for (ce === 0 && (qt = 138, Gt = 3), Xt[2 * (Ut + 1) + 1] = 65535, Wt = 0; Wt <= Ut; Wt++) Et = ce, ce = Xt[2 * (Wt + 1) + 1], ++ft < qt && Et === ce || (ft < Gt ? Nt.bl_tree[2 * Et] += ft : Et !== 0 ? (Et !== Yt && Nt.bl_tree[2 * Et]++, Nt.bl_tree[2 * st]++) : ft <= 10 ? Nt.bl_tree[2 * at]++ : Nt.bl_tree[2 * ct]++, ft = 0, Yt = Et, ce === 0 ? (qt = 138, Gt = 3) : Et === ce ? (qt = 6, Gt = 3) : (qt = 7, Gt = 4));
  }
  function Kt(Nt, Xt, Ut) {
    var Wt, Et, Yt = -1, ce = Xt[1], ft = 0, qt = 7, Gt = 4;
    for (ce === 0 && (qt = 138, Gt = 3), Wt = 0; Wt <= Ut; Wt++) if (Et = ce, ce = Xt[2 * (Wt + 1) + 1], !(++ft < qt && Et === ce)) {
      if (ft < Gt) do
        Mt(Nt, Et, Nt.bl_tree);
      while (--ft != 0);
      else Et !== 0 ? (Et !== Yt && (Mt(Nt, Et, Nt.bl_tree), ft--), Mt(Nt, st, Nt.bl_tree), $t(Nt, ft - 3, 2)) : ft <= 10 ? (Mt(Nt, at, Nt.bl_tree), $t(Nt, ft - 3, 3)) : (Mt(Nt, ct, Nt.bl_tree), $t(Nt, ft - 11, 7));
      ft = 0, Yt = Et, ce === 0 ? (qt = 138, Gt = 3) : Et === ce ? (qt = 6, Gt = 3) : (qt = 7, Gt = 4);
    }
  }
  function te(Nt) {
    var Xt;
    for (jt(Nt, Nt.dyn_ltree, Nt.l_desc.max_code), jt(Nt, Nt.dyn_dtree, Nt.d_desc.max_code), Lt(Nt, Nt.bl_desc), Xt = rt - 1; Xt >= 3 && Nt.bl_tree[2 * dt[Xt] + 1] === 0; Xt--) ;
    return Nt.opt_len += 3 * (Xt + 1) + 5 + 5 + 4, Xt;
  }
  function Vt(Nt, Xt, Ut, Wt) {
    var Et;
    for ($t(Nt, Xt - 257, 5), $t(Nt, Ut - 1, 5), $t(Nt, Wt - 4, 4), Et = 0; Et < Wt; Et++) $t(Nt, Nt.bl_tree[2 * dt[Et] + 1], 3);
    Kt(Nt, Nt.dyn_ltree, Xt - 1), Kt(Nt, Nt.dyn_dtree, Ut - 1);
  }
  function ee(Nt) {
    var Xt, Ut = 4093624447;
    for (Xt = 0; Xt <= 31; Xt++, Ut >>>= 1) if (1 & Ut && Nt.dyn_ltree[2 * Xt] !== 0) return P;
    if (Nt.dyn_ltree[18] !== 0 || Nt.dyn_ltree[20] !== 0 || Nt.dyn_ltree[26] !== 0) return F;
    for (Xt = 32; Xt < W; Xt++) if (Nt.dyn_ltree[2 * Xt] !== 0) return F;
    return P;
  }
  U(Bt);
  var Jt = !1;
  function le(Nt) {
    Jt || (_t(), Jt = !0), Nt.l_desc = new Tt(Nt.dyn_ltree, xt), Nt.d_desc = new Tt(Nt.dyn_dtree, Pt), Nt.bl_desc = new Tt(Nt.bl_tree, Ot), Nt.bi_buf = 0, Nt.bi_valid = 0, wt(Nt);
  }
  function ae(Nt, Xt, Ut, Wt) {
    $t(Nt, (Z << 1) + (Wt ? 1 : 0), 3), J(Nt, Xt, Ut);
  }
  function se(Nt) {
    $t(Nt, $ << 1, 3), Mt(Nt, it, pt), It(Nt);
  }
  function fe(Nt, Xt, Ut, Wt) {
    var Et, Yt, ce = 0;
    Nt.level > 0 ? (Nt.strm.data_type === D && (Nt.strm.data_type = ee(Nt)), Lt(Nt, Nt.l_desc), Lt(Nt, Nt.d_desc), ce = te(Nt), Et = Nt.opt_len + 3 + 7 >>> 3, (Yt = Nt.static_len + 3 + 7 >>> 3) <= Et && (Et = Yt)) : Et = Yt = Ut + 5, Ut + 4 <= Et && Xt !== -1 ? ae(Nt, Xt, Ut, Wt) : Nt.strategy === I || Yt === Et ? ($t(Nt, ($ << 1) + (Wt ? 1 : 0), 3), yt(Nt, pt, Ct)) : ($t(Nt, (j << 1) + (Wt ? 1 : 0), 3), Vt(Nt, Nt.l_desc.max_code + 1, Nt.d_desc.max_code + 1, ce + 1), yt(Nt, Nt.dyn_ltree, Nt.dyn_dtree)), wt(Nt), Wt && Rt(Nt);
  }
  function ne(Nt, Xt, Ut) {
    return Nt.pending_buf[Nt.d_buf + 2 * Nt.last_lit] = Xt >>> 8 & 255, Nt.pending_buf[Nt.d_buf + 2 * Nt.last_lit + 1] = 255 & Xt, Nt.pending_buf[Nt.l_buf + Nt.last_lit] = 255 & Ut, Nt.last_lit++, Xt === 0 ? Nt.dyn_ltree[2 * Ut]++ : (Nt.matches++, Xt--, Nt.dyn_ltree[2 * (At[Ut] + W + 1)]++, Nt.dyn_dtree[2 * Dt(Xt)]++), Nt.last_lit === Nt.lit_bufsize - 1;
  }
  g._tr_init = le, g._tr_stored_block = ae, g._tr_flush_block = fe, g._tr_tally = ne, g._tr_align = se;
}, { "../utils/common": 52 }], 62: [function(d, m, g) {
  function w() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
  }
  m.exports = w;
}, {}], 63: [function(d, m, g) {
  var w, I, P = m.exports = {};
  function F() {
    throw new Error("setTimeout has not been defined");
  }
  function D() {
    throw new Error("clearTimeout has not been defined");
  }
  function U(rt) {
    if (w === setTimeout) return setTimeout(rt, 0);
    if ((w === F || !w) && setTimeout) return w = setTimeout, setTimeout(rt, 0);
    try {
      return w(rt, 0);
    } catch {
      try {
        return w.call(null, rt, 0);
      } catch {
        return w.call(this, rt, 0);
      }
    }
  }
  function Z(rt) {
    if (I === clearTimeout) return clearTimeout(rt);
    if ((I === D || !I) && clearTimeout) return I = clearTimeout, clearTimeout(rt);
    try {
      return I(rt);
    } catch {
      try {
        return I.call(null, rt);
      } catch {
        return I.call(this, rt);
      }
    }
  }
  (function() {
    try {
      w = typeof setTimeout == "function" ? setTimeout : F;
    } catch {
      w = F;
    }
    try {
      I = typeof clearTimeout == "function" ? clearTimeout : D;
    } catch {
      I = D;
    }
  })();
  var $, j = [], G = !1, Q = -1;
  function H() {
    G && $ && (G = !1, $.length ? j = $.concat(j) : Q = -1, j.length && W());
  }
  function W() {
    if (!G) {
      var rt = U(H);
      G = !0;
      for (var tt = j.length; tt; ) {
        for ($ = j, j = []; ++Q < tt; ) $ && $[Q].run();
        Q = -1, tt = j.length;
      }
      $ = null, G = !1, Z(rt);
    }
  }
  function q(rt, tt) {
    this.fun = rt, this.array = tt;
  }
  function et() {
  }
  P.nextTick = function(rt) {
    var tt = new Array(arguments.length - 1);
    if (arguments.length > 1) for (var V = 1; V < arguments.length; V++) tt[V - 1] = arguments[V];
    j.push(new q(rt, tt)), j.length !== 1 || G || U(W);
  }, q.prototype.run = function() {
    this.fun.apply(null, this.array);
  }, P.title = "browser", P.browser = !0, P.env = {}, P.argv = [], P.version = "", P.versions = {}, P.on = et, P.addListener = et, P.once = et, P.off = et, P.removeListener = et, P.removeAllListeners = et, P.emit = et, P.prependListener = et, P.prependOnceListener = et, P.listeners = function(rt) {
    return [];
  }, P.binding = function(rt) {
    throw new Error("process.binding is not supported");
  }, P.cwd = function() {
    return "/";
  }, P.chdir = function(rt) {
    throw new Error("process.chdir is not supported");
  }, P.umask = function() {
    return 0;
  };
}, {}], 64: [function(d, m, g) {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var w = d("buffer"), I = w.Buffer;
  function P(D, U) {
    for (var Z in D) U[Z] = D[Z];
  }
  function F(D, U, Z) {
    return I(D, U, Z);
  }
  I.from && I.alloc && I.allocUnsafe && I.allocUnsafeSlow ? m.exports = w : (P(w, g), g.Buffer = F), F.prototype = Object.create(I.prototype), P(I, F), F.from = function(D, U, Z) {
    if (typeof D == "number") throw new TypeError("Argument must not be a number");
    return I(D, U, Z);
  }, F.alloc = function(D, U, Z) {
    if (typeof D != "number") throw new TypeError("Argument must be a number");
    var $ = I(D);
    return U !== void 0 ? typeof Z == "string" ? $.fill(U, Z) : $.fill(U) : $.fill(0), $;
  }, F.allocUnsafe = function(D) {
    if (typeof D != "number") throw new TypeError("Argument must be a number");
    return I(D);
  }, F.allocUnsafeSlow = function(D) {
    if (typeof D != "number") throw new TypeError("Argument must be a number");
    return w.SlowBuffer(D);
  };
}, { buffer: 32 }], 65: [function(d, m, g) {
  m.exports = I;
  var w = d("events").EventEmitter;
  function I() {
    w.call(this);
  }
  d("inherits")(I, w), I.Readable = d("readable-stream/lib/_stream_readable.js"), I.Writable = d("readable-stream/lib/_stream_writable.js"), I.Duplex = d("readable-stream/lib/_stream_duplex.js"), I.Transform = d("readable-stream/lib/_stream_transform.js"), I.PassThrough = d("readable-stream/lib/_stream_passthrough.js"), I.finished = d("readable-stream/lib/internal/streams/end-of-stream.js"), I.pipeline = d("readable-stream/lib/internal/streams/pipeline.js"), I.Stream = I, I.prototype.pipe = function(P, F) {
    var D = this;
    function U(W) {
      P.writable && P.write(W) === !1 && D.pause && D.pause();
    }
    function Z() {
      D.readable && D.resume && D.resume();
    }
    D.on("data", U), P.on("drain", Z), P._isStdio || F && F.end === !1 || (D.on("end", j), D.on("close", G));
    var $ = !1;
    function j() {
      $ || ($ = !0, P.end());
    }
    function G() {
      $ || ($ = !0, typeof P.destroy == "function" && P.destroy());
    }
    function Q(W) {
      if (H(), w.listenerCount(this, "error") === 0) throw W;
    }
    function H() {
      D.removeListener("data", U), P.removeListener("drain", Z), D.removeListener("end", j), D.removeListener("close", G), D.removeListener("error", Q), P.removeListener("error", Q), D.removeListener("end", H), D.removeListener("close", H), P.removeListener("close", H);
    }
    return D.on("error", Q), P.on("error", Q), D.on("end", H), D.on("close", H), P.on("close", H), P.emit("pipe", D), P;
  };
}, { events: 35, inherits: 46, "readable-stream/lib/_stream_duplex.js": 67, "readable-stream/lib/_stream_passthrough.js": 68, "readable-stream/lib/_stream_readable.js": 69, "readable-stream/lib/_stream_transform.js": 70, "readable-stream/lib/_stream_writable.js": 71, "readable-stream/lib/internal/streams/end-of-stream.js": 75, "readable-stream/lib/internal/streams/pipeline.js": 77 }], 66: [function(d, m, g) {
  function w($, j) {
    $.prototype = Object.create(j.prototype), $.prototype.constructor = $, $.__proto__ = j;
  }
  var I = {};
  function P($, j, G) {
    function Q(W, q, et) {
      return typeof j == "string" ? j : j(W, q, et);
    }
    G || (G = Error);
    var H = function(W) {
      function q(et, rt, tt) {
        return W.call(this, Q(et, rt, tt)) || this;
      }
      return w(q, W), q;
    }(G);
    H.prototype.name = G.name, H.prototype.code = $, I[$] = H;
  }
  function F($, j) {
    if (Array.isArray($)) {
      var G = $.length;
      return $ = $.map(function(Q) {
        return String(Q);
      }), G > 2 ? "one of ".concat(j, " ").concat($.slice(0, G - 1).join(", "), ", or ") + $[G - 1] : G === 2 ? "one of ".concat(j, " ").concat($[0], " or ").concat($[1]) : "of ".concat(j, " ").concat($[0]);
    }
    return "of ".concat(j, " ").concat(String($));
  }
  function D($, j, G) {
    return $.substr(0, j.length) === j;
  }
  function U($, j, G) {
    return (G === void 0 || G > $.length) && (G = $.length), $.substring(G - j.length, G) === j;
  }
  function Z($, j, G) {
    return typeof G != "number" && (G = 0), !(G + j.length > $.length) && $.indexOf(j, G) !== -1;
  }
  P("ERR_INVALID_OPT_VALUE", function($, j) {
    return 'The value "' + j + '" is invalid for option "' + $ + '"';
  }, TypeError), P("ERR_INVALID_ARG_TYPE", function($, j, G) {
    var Q, H;
    if (typeof j == "string" && D(j, "not ") ? (Q = "must not be", j = j.replace(/^not /, "")) : Q = "must be", U($, " argument")) H = "The ".concat($, " ").concat(Q, " ").concat(F(j, "type"));
    else {
      var W = Z($, ".") ? "property" : "argument";
      H = 'The "'.concat($, '" ').concat(W, " ").concat(Q, " ").concat(F(j, "type"));
    }
    return H += ". Received type ".concat(typeof G);
  }, TypeError), P("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), P("ERR_METHOD_NOT_IMPLEMENTED", function($) {
    return "The " + $ + " method is not implemented";
  }), P("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), P("ERR_STREAM_DESTROYED", function($) {
    return "Cannot call " + $ + " after a stream was destroyed";
  }), P("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), P("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), P("ERR_STREAM_WRITE_AFTER_END", "write after end"), P("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), P("ERR_UNKNOWN_ENCODING", function($) {
    return "Unknown encoding: " + $;
  }, TypeError), P("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), m.exports.codes = I;
}, {}], 67: [function(d, m, g) {
  (function(w) {
    (function() {
      var I = Object.keys || function(Q) {
        var H = [];
        for (var W in Q) H.push(W);
        return H;
      };
      m.exports = $;
      var P = d("./_stream_readable"), F = d("./_stream_writable");
      d("inherits")($, P);
      for (var D = I(F.prototype), U = 0; U < D.length; U++) {
        var Z = D[U];
        $.prototype[Z] || ($.prototype[Z] = F.prototype[Z]);
      }
      function $(Q) {
        if (!(this instanceof $)) return new $(Q);
        P.call(this, Q), F.call(this, Q), this.allowHalfOpen = !0, Q && (Q.readable === !1 && (this.readable = !1), Q.writable === !1 && (this.writable = !1), Q.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", j)));
      }
      function j() {
        this._writableState.ended || w.nextTick(G, this);
      }
      function G(Q) {
        Q.end();
      }
      Object.defineProperty($.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
        return this._writableState.highWaterMark;
      } }), Object.defineProperty($.prototype, "writableBuffer", { enumerable: !1, get: function() {
        return this._writableState && this._writableState.getBuffer();
      } }), Object.defineProperty($.prototype, "writableLength", { enumerable: !1, get: function() {
        return this._writableState.length;
      } }), Object.defineProperty($.prototype, "destroyed", { enumerable: !1, get: function() {
        return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed;
      }, set: function(Q) {
        this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = Q, this._writableState.destroyed = Q);
      } });
    }).call(this);
  }).call(this, d("_process"));
}, { "./_stream_readable": 69, "./_stream_writable": 71, _process: 63, inherits: 46 }], 68: [function(d, m, g) {
  m.exports = I;
  var w = d("./_stream_transform");
  function I(P) {
    if (!(this instanceof I)) return new I(P);
    w.call(this, P);
  }
  d("inherits")(I, w), I.prototype._transform = function(P, F, D) {
    D(null, P);
  };
}, { "./_stream_transform": 70, inherits: 46 }], 69: [function(d, m, g) {
  (function(w, I) {
    (function() {
      var P;
      m.exports = vt, vt.ReadableState = lt, d("events").EventEmitter;
      var F = function(_t, wt) {
        return _t.listeners(wt).length;
      }, D = d("./internal/streams/stream"), U = d("buffer").Buffer, Z = I.Uint8Array || function() {
      };
      function $(_t) {
        return U.from(_t);
      }
      function j(_t) {
        return U.isBuffer(_t) || _t instanceof Z;
      }
      var G, Q = d("util");
      G = Q && Q.debuglog ? Q.debuglog("stream") : function() {
      };
      var H, W, q, et = d("./internal/streams/buffer_list"), rt = d("./internal/streams/destroy"), tt = d("./internal/streams/state").getHighWaterMark, V = d("../errors").codes, X = V.ERR_INVALID_ARG_TYPE, ot = V.ERR_STREAM_PUSH_AFTER_EOF, it = V.ERR_METHOD_NOT_IMPLEMENTED, st = V.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      d("inherits")(vt, D);
      var at = rt.errorOrDestroy, ct = ["error", "close", "destroy", "pause", "resume"];
      function K(_t, wt, Rt) {
        if (typeof _t.prependListener == "function") return _t.prependListener(wt, Rt);
        _t._events && _t._events[wt] ? Array.isArray(_t._events[wt]) ? _t._events[wt].unshift(Rt) : _t._events[wt] = [Rt, _t._events[wt]] : _t.on(wt, Rt);
      }
      function lt(_t, wt, Rt) {
        P = P || d("./_stream_duplex"), _t = _t || {}, typeof Rt != "boolean" && (Rt = wt instanceof P), this.objectMode = !!_t.objectMode, Rt && (this.objectMode = this.objectMode || !!_t.readableObjectMode), this.highWaterMark = tt(this, _t, "readableHighWaterMark", Rt), this.buffer = new et(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = _t.emitClose !== !1, this.autoDestroy = !!_t.autoDestroy, this.destroyed = !1, this.defaultEncoding = _t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, _t.encoding && (H || (H = d("string_decoder/").StringDecoder), this.decoder = new H(_t.encoding), this.encoding = _t.encoding);
      }
      function vt(_t) {
        if (P = P || d("./_stream_duplex"), !(this instanceof vt)) return new vt(_t);
        var wt = this instanceof P;
        this._readableState = new lt(_t, this, wt), this.readable = !0, _t && (typeof _t.read == "function" && (this._read = _t.read), typeof _t.destroy == "function" && (this._destroy = _t.destroy)), D.call(this);
      }
      function dt(_t, wt, Rt, J, ut) {
        G("readableAddChunk", wt);
        var bt, yt = _t._readableState;
        if (wt === null) yt.reading = !1, Ft(_t, yt);
        else if (ut || (bt = pt(yt, wt)), bt) at(_t, bt);
        else if (yt.objectMode || wt && wt.length > 0) if (typeof wt == "string" || yt.objectMode || Object.getPrototypeOf(wt) === U.prototype || (wt = $(wt)), J) yt.endEmitted ? at(_t, new st()) : ht(_t, yt, wt, !0);
        else if (yt.ended) at(_t, new ot());
        else {
          if (yt.destroyed) return !1;
          yt.reading = !1, yt.decoder && !Rt ? (wt = yt.decoder.write(wt), yt.objectMode || wt.length !== 0 ? ht(_t, yt, wt, !1) : Ot(_t, yt)) : ht(_t, yt, wt, !1);
        }
        else J || (yt.reading = !1, Ot(_t, yt));
        return !yt.ended && (yt.length < yt.highWaterMark || yt.length === 0);
      }
      function ht(_t, wt, Rt, J) {
        wt.flowing && wt.length === 0 && !wt.sync ? (wt.awaitDrain = 0, _t.emit("data", Rt)) : (wt.length += wt.objectMode ? 1 : Rt.length, J ? wt.buffer.unshift(Rt) : wt.buffer.push(Rt), wt.needReadable && xt(_t)), Ot(_t, wt);
      }
      function pt(_t, wt) {
        var Rt;
        return j(wt) || typeof wt == "string" || wt === void 0 || _t.objectMode || (Rt = new X("chunk", ["string", "Buffer", "Uint8Array"], wt)), Rt;
      }
      Object.defineProperty(vt.prototype, "destroyed", { enumerable: !1, get: function() {
        return this._readableState !== void 0 && this._readableState.destroyed;
      }, set: function(_t) {
        this._readableState && (this._readableState.destroyed = _t);
      } }), vt.prototype.destroy = rt.destroy, vt.prototype._undestroy = rt.undestroy, vt.prototype._destroy = function(_t, wt) {
        wt(_t);
      }, vt.prototype.push = function(_t, wt) {
        var Rt, J = this._readableState;
        return J.objectMode ? Rt = !0 : typeof _t == "string" && ((wt = wt || J.defaultEncoding) !== J.encoding && (_t = U.from(_t, wt), wt = ""), Rt = !0), dt(this, _t, wt, !1, Rt);
      }, vt.prototype.unshift = function(_t) {
        return dt(this, _t, null, !0, !1);
      }, vt.prototype.isPaused = function() {
        return this._readableState.flowing === !1;
      }, vt.prototype.setEncoding = function(_t) {
        H || (H = d("string_decoder/").StringDecoder);
        var wt = new H(_t);
        this._readableState.decoder = wt, this._readableState.encoding = this._readableState.decoder.encoding;
        for (var Rt = this._readableState.buffer.head, J = ""; Rt !== null; ) J += wt.write(Rt.data), Rt = Rt.next;
        return this._readableState.buffer.clear(), J !== "" && this._readableState.buffer.push(J), this._readableState.length = J.length, this;
      };
      var Ct = 1073741824;
      function St(_t) {
        return _t >= Ct ? _t = Ct : (_t--, _t |= _t >>> 1, _t |= _t >>> 2, _t |= _t >>> 4, _t |= _t >>> 8, _t |= _t >>> 16, _t++), _t;
      }
      function At(_t, wt) {
        return _t <= 0 || wt.length === 0 && wt.ended ? 0 : wt.objectMode ? 1 : _t != _t ? wt.flowing && wt.length ? wt.buffer.head.data.length : wt.length : (_t > wt.highWaterMark && (wt.highWaterMark = St(_t)), _t <= wt.length ? _t : wt.ended ? wt.length : (wt.needReadable = !0, 0));
      }
      function Ft(_t, wt) {
        if (G("onEofChunk"), !wt.ended) {
          if (wt.decoder) {
            var Rt = wt.decoder.end();
            Rt && Rt.length && (wt.buffer.push(Rt), wt.length += wt.objectMode ? 1 : Rt.length);
          }
          wt.ended = !0, wt.sync ? xt(_t) : (wt.needReadable = !1, wt.emittedReadable || (wt.emittedReadable = !0, Pt(_t)));
        }
      }
      function xt(_t) {
        var wt = _t._readableState;
        G("emitReadable", wt.needReadable, wt.emittedReadable), wt.needReadable = !1, wt.emittedReadable || (G("emitReadable", wt.flowing), wt.emittedReadable = !0, w.nextTick(Pt, _t));
      }
      function Pt(_t) {
        var wt = _t._readableState;
        G("emitReadable_", wt.destroyed, wt.length, wt.ended), wt.destroyed || !wt.length && !wt.ended || (_t.emit("readable"), wt.emittedReadable = !1), wt.needReadable = !wt.flowing && !wt.ended && wt.length <= wt.highWaterMark, Mt(_t);
      }
      function Ot(_t, wt) {
        wt.readingMore || (wt.readingMore = !0, w.nextTick(Bt, _t, wt));
      }
      function Bt(_t, wt) {
        for (; !wt.reading && !wt.ended && (wt.length < wt.highWaterMark || wt.flowing && wt.length === 0); ) {
          var Rt = wt.length;
          if (G("maybeReadMore read 0"), _t.read(0), Rt === wt.length) break;
        }
        wt.readingMore = !1;
      }
      function kt(_t) {
        return function() {
          var wt = _t._readableState;
          G("pipeOnDrain", wt.awaitDrain), wt.awaitDrain && wt.awaitDrain--, wt.awaitDrain === 0 && F(_t, "data") && (wt.flowing = !0, Mt(_t));
        };
      }
      function Tt(_t) {
        var wt = _t._readableState;
        wt.readableListening = _t.listenerCount("readable") > 0, wt.resumeScheduled && !wt.paused ? wt.flowing = !0 : _t.listenerCount("data") > 0 && _t.resume();
      }
      function Dt(_t) {
        G("readable nexttick read 0"), _t.read(0);
      }
      function Zt(_t, wt) {
        wt.resumeScheduled || (wt.resumeScheduled = !0, w.nextTick($t, _t, wt));
      }
      function $t(_t, wt) {
        G("resume", wt.reading), wt.reading || _t.read(0), wt.resumeScheduled = !1, _t.emit("resume"), Mt(_t), wt.flowing && !wt.reading && _t.read(0);
      }
      function Mt(_t) {
        var wt = _t._readableState;
        for (G("flow", wt.flowing); wt.flowing && _t.read() !== null; ) ;
      }
      function nt(_t, wt) {
        return wt.length === 0 ? null : (wt.objectMode ? Rt = wt.buffer.shift() : !_t || _t >= wt.length ? (Rt = wt.decoder ? wt.buffer.join("") : wt.buffer.length === 1 ? wt.buffer.first() : wt.buffer.concat(wt.length), wt.buffer.clear()) : Rt = wt.buffer.consume(_t, wt.decoder), Rt);
        var Rt;
      }
      function It(_t) {
        var wt = _t._readableState;
        G("endReadable", wt.endEmitted), wt.endEmitted || (wt.ended = !0, w.nextTick(mt, wt, _t));
      }
      function mt(_t, wt) {
        if (G("endReadableNT", _t.endEmitted, _t.length), !_t.endEmitted && _t.length === 0 && (_t.endEmitted = !0, wt.readable = !1, wt.emit("end"), _t.autoDestroy)) {
          var Rt = wt._writableState;
          (!Rt || Rt.autoDestroy && Rt.finished) && wt.destroy();
        }
      }
      function gt(_t, wt) {
        for (var Rt = 0, J = _t.length; Rt < J; Rt++) if (_t[Rt] === wt) return Rt;
        return -1;
      }
      vt.prototype.read = function(_t) {
        G("read", _t), _t = parseInt(_t, 10);
        var wt = this._readableState, Rt = _t;
        if (_t !== 0 && (wt.emittedReadable = !1), _t === 0 && wt.needReadable && ((wt.highWaterMark !== 0 ? wt.length >= wt.highWaterMark : wt.length > 0) || wt.ended)) return G("read: emitReadable", wt.length, wt.ended), wt.length === 0 && wt.ended ? It(this) : xt(this), null;
        if ((_t = At(_t, wt)) === 0 && wt.ended) return wt.length === 0 && It(this), null;
        var J, ut = wt.needReadable;
        return G("need readable", ut), (wt.length === 0 || wt.length - _t < wt.highWaterMark) && G("length less than watermark", ut = !0), wt.ended || wt.reading ? G("reading or ended", ut = !1) : ut && (G("do read"), wt.reading = !0, wt.sync = !0, wt.length === 0 && (wt.needReadable = !0), this._read(wt.highWaterMark), wt.sync = !1, wt.reading || (_t = At(Rt, wt))), (J = _t > 0 ? nt(_t, wt) : null) === null ? (wt.needReadable = wt.length <= wt.highWaterMark, _t = 0) : (wt.length -= _t, wt.awaitDrain = 0), wt.length === 0 && (wt.ended || (wt.needReadable = !0), Rt !== _t && wt.ended && It(this)), J !== null && this.emit("data", J), J;
      }, vt.prototype._read = function(_t) {
        at(this, new it("_read()"));
      }, vt.prototype.pipe = function(_t, wt) {
        var Rt = this, J = this._readableState;
        switch (J.pipesCount) {
          case 0:
            J.pipes = _t;
            break;
          case 1:
            J.pipes = [J.pipes, _t];
            break;
          default:
            J.pipes.push(_t);
        }
        J.pipesCount += 1, G("pipe count=%d opts=%j", J.pipesCount, wt);
        var ut = wt && wt.end === !1 || _t === w.stdout || _t === w.stderr ? le : yt;
        function bt(ae, se) {
          G("onunpipe"), ae === Rt && se && se.hasUnpiped === !1 && (se.hasUnpiped = !0, Kt());
        }
        function yt() {
          G("onend"), _t.end();
        }
        J.endEmitted ? w.nextTick(ut) : Rt.once("end", ut), _t.on("unpipe", bt);
        var Lt = kt(Rt);
        _t.on("drain", Lt);
        var jt = !1;
        function Kt() {
          G("cleanup"), _t.removeListener("close", ee), _t.removeListener("finish", Jt), _t.removeListener("drain", Lt), _t.removeListener("error", Vt), _t.removeListener("unpipe", bt), Rt.removeListener("end", yt), Rt.removeListener("end", le), Rt.removeListener("data", te), jt = !0, !J.awaitDrain || _t._writableState && !_t._writableState.needDrain || Lt();
        }
        function te(ae) {
          G("ondata");
          var se = _t.write(ae);
          G("dest.write", se), se === !1 && ((J.pipesCount === 1 && J.pipes === _t || J.pipesCount > 1 && gt(J.pipes, _t) !== -1) && !jt && (G("false write response, pause", J.awaitDrain), J.awaitDrain++), Rt.pause());
        }
        function Vt(ae) {
          G("onerror", ae), le(), _t.removeListener("error", Vt), F(_t, "error") === 0 && at(_t, ae);
        }
        function ee() {
          _t.removeListener("finish", Jt), le();
        }
        function Jt() {
          G("onfinish"), _t.removeListener("close", ee), le();
        }
        function le() {
          G("unpipe"), Rt.unpipe(_t);
        }
        return Rt.on("data", te), K(_t, "error", Vt), _t.once("close", ee), _t.once("finish", Jt), _t.emit("pipe", Rt), J.flowing || (G("pipe resume"), Rt.resume()), _t;
      }, vt.prototype.unpipe = function(_t) {
        var wt = this._readableState, Rt = { hasUnpiped: !1 };
        if (wt.pipesCount === 0) return this;
        if (wt.pipesCount === 1) return _t && _t !== wt.pipes || (_t || (_t = wt.pipes), wt.pipes = null, wt.pipesCount = 0, wt.flowing = !1, _t && _t.emit("unpipe", this, Rt)), this;
        if (!_t) {
          var J = wt.pipes, ut = wt.pipesCount;
          wt.pipes = null, wt.pipesCount = 0, wt.flowing = !1;
          for (var bt = 0; bt < ut; bt++) J[bt].emit("unpipe", this, { hasUnpiped: !1 });
          return this;
        }
        var yt = gt(wt.pipes, _t);
        return yt === -1 || (wt.pipes.splice(yt, 1), wt.pipesCount -= 1, wt.pipesCount === 1 && (wt.pipes = wt.pipes[0]), _t.emit("unpipe", this, Rt)), this;
      }, vt.prototype.on = function(_t, wt) {
        var Rt = D.prototype.on.call(this, _t, wt), J = this._readableState;
        return _t === "data" ? (J.readableListening = this.listenerCount("readable") > 0, J.flowing !== !1 && this.resume()) : _t === "readable" && (J.endEmitted || J.readableListening || (J.readableListening = J.needReadable = !0, J.flowing = !1, J.emittedReadable = !1, G("on readable", J.length, J.reading), J.length ? xt(this) : J.reading || w.nextTick(Dt, this))), Rt;
      }, vt.prototype.addListener = vt.prototype.on, vt.prototype.removeListener = function(_t, wt) {
        var Rt = D.prototype.removeListener.call(this, _t, wt);
        return _t === "readable" && w.nextTick(Tt, this), Rt;
      }, vt.prototype.removeAllListeners = function(_t) {
        var wt = D.prototype.removeAllListeners.apply(this, arguments);
        return _t !== "readable" && _t !== void 0 || w.nextTick(Tt, this), wt;
      }, vt.prototype.resume = function() {
        var _t = this._readableState;
        return _t.flowing || (G("resume"), _t.flowing = !_t.readableListening, Zt(this, _t)), _t.paused = !1, this;
      }, vt.prototype.pause = function() {
        return G("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (G("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
      }, vt.prototype.wrap = function(_t) {
        var wt = this, Rt = this._readableState, J = !1;
        for (var ut in _t.on("end", function() {
          if (G("wrapped end"), Rt.decoder && !Rt.ended) {
            var yt = Rt.decoder.end();
            yt && yt.length && wt.push(yt);
          }
          wt.push(null);
        }), _t.on("data", function(yt) {
          G("wrapped data"), Rt.decoder && (yt = Rt.decoder.write(yt)), Rt.objectMode && yt == null || (Rt.objectMode || yt && yt.length) && (wt.push(yt) || (J = !0, _t.pause()));
        }), _t) this[ut] === void 0 && typeof _t[ut] == "function" && (this[ut] = /* @__PURE__ */ function(yt) {
          return function() {
            return _t[yt].apply(_t, arguments);
          };
        }(ut));
        for (var bt = 0; bt < ct.length; bt++) _t.on(ct[bt], this.emit.bind(this, ct[bt]));
        return this._read = function(yt) {
          G("wrapped _read", yt), J && (J = !1, _t.resume());
        }, this;
      }, typeof Symbol == "function" && (vt.prototype[Symbol.asyncIterator] = function() {
        return W === void 0 && (W = d("./internal/streams/async_iterator")), W(this);
      }), Object.defineProperty(vt.prototype, "readableHighWaterMark", { enumerable: !1, get: function() {
        return this._readableState.highWaterMark;
      } }), Object.defineProperty(vt.prototype, "readableBuffer", { enumerable: !1, get: function() {
        return this._readableState && this._readableState.buffer;
      } }), Object.defineProperty(vt.prototype, "readableFlowing", { enumerable: !1, get: function() {
        return this._readableState.flowing;
      }, set: function(_t) {
        this._readableState && (this._readableState.flowing = _t);
      } }), vt._fromList = nt, Object.defineProperty(vt.prototype, "readableLength", { enumerable: !1, get: function() {
        return this._readableState.length;
      } }), typeof Symbol == "function" && (vt.from = function(_t, wt) {
        return q === void 0 && (q = d("./internal/streams/from")), q(vt, _t, wt);
      });
    }).call(this);
  }).call(this, d("_process"), commonjsGlobal !== void 0 ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
}, { "../errors": 66, "./_stream_duplex": 67, "./internal/streams/async_iterator": 72, "./internal/streams/buffer_list": 73, "./internal/streams/destroy": 74, "./internal/streams/from": 76, "./internal/streams/state": 78, "./internal/streams/stream": 79, _process: 63, buffer: 32, events: 35, inherits: 46, "string_decoder/": 80, util: 29 }], 70: [function(d, m, g) {
  m.exports = $;
  var w = d("../errors").codes, I = w.ERR_METHOD_NOT_IMPLEMENTED, P = w.ERR_MULTIPLE_CALLBACK, F = w.ERR_TRANSFORM_ALREADY_TRANSFORMING, D = w.ERR_TRANSFORM_WITH_LENGTH_0, U = d("./_stream_duplex");
  function Z(Q, H) {
    var W = this._transformState;
    W.transforming = !1;
    var q = W.writecb;
    if (q === null) return this.emit("error", new P());
    W.writechunk = null, W.writecb = null, H != null && this.push(H), q(Q);
    var et = this._readableState;
    et.reading = !1, (et.needReadable || et.length < et.highWaterMark) && this._read(et.highWaterMark);
  }
  function $(Q) {
    if (!(this instanceof $)) return new $(Q);
    U.call(this, Q), this._transformState = { afterTransform: Z.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, Q && (typeof Q.transform == "function" && (this._transform = Q.transform), typeof Q.flush == "function" && (this._flush = Q.flush)), this.on("prefinish", j);
  }
  function j() {
    var Q = this;
    typeof this._flush != "function" || this._readableState.destroyed ? G(this, null, null) : this._flush(function(H, W) {
      G(Q, H, W);
    });
  }
  function G(Q, H, W) {
    if (H) return Q.emit("error", H);
    if (W != null && Q.push(W), Q._writableState.length) throw new D();
    if (Q._transformState.transforming) throw new F();
    return Q.push(null);
  }
  d("inherits")($, U), $.prototype.push = function(Q, H) {
    return this._transformState.needTransform = !1, U.prototype.push.call(this, Q, H);
  }, $.prototype._transform = function(Q, H, W) {
    W(new I("_transform()"));
  }, $.prototype._write = function(Q, H, W) {
    var q = this._transformState;
    if (q.writecb = W, q.writechunk = Q, q.writeencoding = H, !q.transforming) {
      var et = this._readableState;
      (q.needTransform || et.needReadable || et.length < et.highWaterMark) && this._read(et.highWaterMark);
    }
  }, $.prototype._read = function(Q) {
    var H = this._transformState;
    H.writechunk === null || H.transforming ? H.needTransform = !0 : (H.transforming = !0, this._transform(H.writechunk, H.writeencoding, H.afterTransform));
  }, $.prototype._destroy = function(Q, H) {
    U.prototype._destroy.call(this, Q, function(W) {
      H(W);
    });
  };
}, { "../errors": 66, "./_stream_duplex": 67, inherits: 46 }], 71: [function(d, m, g) {
  (function(w, I) {
    (function() {
      function P(Mt) {
        var nt = this;
        this.next = null, this.entry = null, this.finish = function() {
          $t(nt, Mt);
        };
      }
      var F;
      m.exports = lt, lt.WritableState = K;
      var D = { deprecate: d("util-deprecate") }, U = d("./internal/streams/stream"), Z = d("buffer").Buffer, $ = I.Uint8Array || function() {
      };
      function j(Mt) {
        return Z.from(Mt);
      }
      function G(Mt) {
        return Z.isBuffer(Mt) || Mt instanceof $;
      }
      var Q, H = d("./internal/streams/destroy"), W = d("./internal/streams/state").getHighWaterMark, q = d("../errors").codes, et = q.ERR_INVALID_ARG_TYPE, rt = q.ERR_METHOD_NOT_IMPLEMENTED, tt = q.ERR_MULTIPLE_CALLBACK, V = q.ERR_STREAM_CANNOT_PIPE, X = q.ERR_STREAM_DESTROYED, ot = q.ERR_STREAM_NULL_VALUES, it = q.ERR_STREAM_WRITE_AFTER_END, st = q.ERR_UNKNOWN_ENCODING, at = H.errorOrDestroy;
      function ct() {
      }
      function K(Mt, nt, It) {
        F = F || d("./_stream_duplex"), Mt = Mt || {}, typeof It != "boolean" && (It = nt instanceof F), this.objectMode = !!Mt.objectMode, It && (this.objectMode = this.objectMode || !!Mt.writableObjectMode), this.highWaterMark = W(this, Mt, "writableHighWaterMark", It), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        var mt = Mt.decodeStrings === !1;
        this.decodeStrings = !mt, this.defaultEncoding = Mt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(gt) {
          Ft(nt, gt);
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Mt.emitClose !== !1, this.autoDestroy = !!Mt.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new P(this);
      }
      function lt(Mt) {
        var nt = this instanceof (F = F || d("./_stream_duplex"));
        if (!nt && !Q.call(lt, this)) return new lt(Mt);
        this._writableState = new K(Mt, this, nt), this.writable = !0, Mt && (typeof Mt.write == "function" && (this._write = Mt.write), typeof Mt.writev == "function" && (this._writev = Mt.writev), typeof Mt.destroy == "function" && (this._destroy = Mt.destroy), typeof Mt.final == "function" && (this._final = Mt.final)), U.call(this);
      }
      function vt(Mt, nt) {
        var It = new it();
        at(Mt, It), w.nextTick(nt, It);
      }
      function dt(Mt, nt, It, mt) {
        var gt;
        return It === null ? gt = new ot() : typeof It == "string" || nt.objectMode || (gt = new et("chunk", ["string", "Buffer"], It)), !gt || (at(Mt, gt), w.nextTick(mt, gt), !1);
      }
      function ht(Mt, nt, It) {
        return Mt.objectMode || Mt.decodeStrings === !1 || typeof nt != "string" || (nt = Z.from(nt, It)), nt;
      }
      function pt(Mt, nt, It, mt, gt, _t) {
        if (!It) {
          var wt = ht(nt, mt, gt);
          mt !== wt && (It = !0, gt = "buffer", mt = wt);
        }
        var Rt = nt.objectMode ? 1 : mt.length;
        nt.length += Rt;
        var J = nt.length < nt.highWaterMark;
        if (J || (nt.needDrain = !0), nt.writing || nt.corked) {
          var ut = nt.lastBufferedRequest;
          nt.lastBufferedRequest = { chunk: mt, encoding: gt, isBuf: It, callback: _t, next: null }, ut ? ut.next = nt.lastBufferedRequest : nt.bufferedRequest = nt.lastBufferedRequest, nt.bufferedRequestCount += 1;
        } else Ct(Mt, nt, !1, Rt, mt, gt, _t);
        return J;
      }
      function Ct(Mt, nt, It, mt, gt, _t, wt) {
        nt.writelen = mt, nt.writecb = wt, nt.writing = !0, nt.sync = !0, nt.destroyed ? nt.onwrite(new X("write")) : It ? Mt._writev(gt, nt.onwrite) : Mt._write(gt, _t, nt.onwrite), nt.sync = !1;
      }
      function St(Mt, nt, It, mt, gt) {
        --nt.pendingcb, It ? (w.nextTick(gt, mt), w.nextTick(Dt, Mt, nt), Mt._writableState.errorEmitted = !0, at(Mt, mt)) : (gt(mt), Mt._writableState.errorEmitted = !0, at(Mt, mt), Dt(Mt, nt));
      }
      function At(Mt) {
        Mt.writing = !1, Mt.writecb = null, Mt.length -= Mt.writelen, Mt.writelen = 0;
      }
      function Ft(Mt, nt) {
        var It = Mt._writableState, mt = It.sync, gt = It.writecb;
        if (typeof gt != "function") throw new tt();
        if (At(It), nt) St(Mt, It, mt, nt, gt);
        else {
          var _t = Bt(It) || Mt.destroyed;
          _t || It.corked || It.bufferProcessing || !It.bufferedRequest || Ot(Mt, It), mt ? w.nextTick(xt, Mt, It, _t, gt) : xt(Mt, It, _t, gt);
        }
      }
      function xt(Mt, nt, It, mt) {
        It || Pt(Mt, nt), nt.pendingcb--, mt(), Dt(Mt, nt);
      }
      function Pt(Mt, nt) {
        nt.length === 0 && nt.needDrain && (nt.needDrain = !1, Mt.emit("drain"));
      }
      function Ot(Mt, nt) {
        nt.bufferProcessing = !0;
        var It = nt.bufferedRequest;
        if (Mt._writev && It && It.next) {
          var mt = nt.bufferedRequestCount, gt = new Array(mt), _t = nt.corkedRequestsFree;
          _t.entry = It;
          for (var wt = 0, Rt = !0; It; ) gt[wt] = It, It.isBuf || (Rt = !1), It = It.next, wt += 1;
          gt.allBuffers = Rt, Ct(Mt, nt, !0, nt.length, gt, "", _t.finish), nt.pendingcb++, nt.lastBufferedRequest = null, _t.next ? (nt.corkedRequestsFree = _t.next, _t.next = null) : nt.corkedRequestsFree = new P(nt), nt.bufferedRequestCount = 0;
        } else {
          for (; It; ) {
            var J = It.chunk, ut = It.encoding, bt = It.callback;
            if (Ct(Mt, nt, !1, nt.objectMode ? 1 : J.length, J, ut, bt), It = It.next, nt.bufferedRequestCount--, nt.writing) break;
          }
          It === null && (nt.lastBufferedRequest = null);
        }
        nt.bufferedRequest = It, nt.bufferProcessing = !1;
      }
      function Bt(Mt) {
        return Mt.ending && Mt.length === 0 && Mt.bufferedRequest === null && !Mt.finished && !Mt.writing;
      }
      function kt(Mt, nt) {
        Mt._final(function(It) {
          nt.pendingcb--, It && at(Mt, It), nt.prefinished = !0, Mt.emit("prefinish"), Dt(Mt, nt);
        });
      }
      function Tt(Mt, nt) {
        nt.prefinished || nt.finalCalled || (typeof Mt._final != "function" || nt.destroyed ? (nt.prefinished = !0, Mt.emit("prefinish")) : (nt.pendingcb++, nt.finalCalled = !0, w.nextTick(kt, Mt, nt)));
      }
      function Dt(Mt, nt) {
        var It = Bt(nt);
        if (It && (Tt(Mt, nt), nt.pendingcb === 0 && (nt.finished = !0, Mt.emit("finish"), nt.autoDestroy))) {
          var mt = Mt._readableState;
          (!mt || mt.autoDestroy && mt.endEmitted) && Mt.destroy();
        }
        return It;
      }
      function Zt(Mt, nt, It) {
        nt.ending = !0, Dt(Mt, nt), It && (nt.finished ? w.nextTick(It) : Mt.once("finish", It)), nt.ended = !0, Mt.writable = !1;
      }
      function $t(Mt, nt, It) {
        var mt = Mt.entry;
        for (Mt.entry = null; mt; ) {
          var gt = mt.callback;
          nt.pendingcb--, gt(It), mt = mt.next;
        }
        nt.corkedRequestsFree.next = Mt;
      }
      d("inherits")(lt, U), K.prototype.getBuffer = function() {
        for (var Mt = this.bufferedRequest, nt = []; Mt; ) nt.push(Mt), Mt = Mt.next;
        return nt;
      }, function() {
        try {
          Object.defineProperty(K.prototype, "buffer", { get: D.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
        } catch {
        }
      }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Q = Function.prototype[Symbol.hasInstance], Object.defineProperty(lt, Symbol.hasInstance, { value: function(Mt) {
        return !!Q.call(this, Mt) || this === lt && Mt && Mt._writableState instanceof K;
      } })) : Q = function(Mt) {
        return Mt instanceof this;
      }, lt.prototype.pipe = function() {
        at(this, new V());
      }, lt.prototype.write = function(Mt, nt, It) {
        var mt = this._writableState, gt = !1, _t = !mt.objectMode && G(Mt);
        return _t && !Z.isBuffer(Mt) && (Mt = j(Mt)), typeof nt == "function" && (It = nt, nt = null), _t ? nt = "buffer" : nt || (nt = mt.defaultEncoding), typeof It != "function" && (It = ct), mt.ending ? vt(this, It) : (_t || dt(this, mt, Mt, It)) && (mt.pendingcb++, gt = pt(this, mt, _t, Mt, nt, It)), gt;
      }, lt.prototype.cork = function() {
        this._writableState.corked++;
      }, lt.prototype.uncork = function() {
        var Mt = this._writableState;
        Mt.corked && (Mt.corked--, Mt.writing || Mt.corked || Mt.bufferProcessing || !Mt.bufferedRequest || Ot(this, Mt));
      }, lt.prototype.setDefaultEncoding = function(Mt) {
        if (typeof Mt == "string" && (Mt = Mt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Mt + "").toLowerCase()) > -1)) throw new st(Mt);
        return this._writableState.defaultEncoding = Mt, this;
      }, Object.defineProperty(lt.prototype, "writableBuffer", { enumerable: !1, get: function() {
        return this._writableState && this._writableState.getBuffer();
      } }), Object.defineProperty(lt.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
        return this._writableState.highWaterMark;
      } }), lt.prototype._write = function(Mt, nt, It) {
        It(new rt("_write()"));
      }, lt.prototype._writev = null, lt.prototype.end = function(Mt, nt, It) {
        var mt = this._writableState;
        return typeof Mt == "function" ? (It = Mt, Mt = null, nt = null) : typeof nt == "function" && (It = nt, nt = null), Mt != null && this.write(Mt, nt), mt.corked && (mt.corked = 1, this.uncork()), mt.ending || Zt(this, mt, It), this;
      }, Object.defineProperty(lt.prototype, "writableLength", { enumerable: !1, get: function() {
        return this._writableState.length;
      } }), Object.defineProperty(lt.prototype, "destroyed", { enumerable: !1, get: function() {
        return this._writableState !== void 0 && this._writableState.destroyed;
      }, set: function(Mt) {
        this._writableState && (this._writableState.destroyed = Mt);
      } }), lt.prototype.destroy = H.destroy, lt.prototype._undestroy = H.undestroy, lt.prototype._destroy = function(Mt, nt) {
        nt(Mt);
      };
    }).call(this);
  }).call(this, d("_process"), commonjsGlobal !== void 0 ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
}, { "../errors": 66, "./_stream_duplex": 67, "./internal/streams/destroy": 74, "./internal/streams/state": 78, "./internal/streams/stream": 79, _process: 63, buffer: 32, inherits: 46, "util-deprecate": 81 }], 72: [function(d, m, g) {
  (function(w) {
    (function() {
      var I;
      function P(X, ot, it) {
        return ot in X ? Object.defineProperty(X, ot, { value: it, enumerable: !0, configurable: !0, writable: !0 }) : X[ot] = it, X;
      }
      var F = d("./end-of-stream"), D = Symbol("lastResolve"), U = Symbol("lastReject"), Z = Symbol("error"), $ = Symbol("ended"), j = Symbol("lastPromise"), G = Symbol("handlePromise"), Q = Symbol("stream");
      function H(X, ot) {
        return { value: X, done: ot };
      }
      function W(X) {
        var ot = X[D];
        if (ot !== null) {
          var it = X[Q].read();
          it !== null && (X[j] = null, X[D] = null, X[U] = null, ot(H(it, !1)));
        }
      }
      function q(X) {
        w.nextTick(W, X);
      }
      function et(X, ot) {
        return function(it, st) {
          X.then(function() {
            ot[$] ? it(H(void 0, !0)) : ot[G](it, st);
          }, st);
        };
      }
      var rt = Object.getPrototypeOf(function() {
      }), tt = Object.setPrototypeOf((I = { get stream() {
        return this[Q];
      }, next: function() {
        var X = this, ot = this[Z];
        if (ot !== null) return Promise.reject(ot);
        if (this[$]) return Promise.resolve(H(void 0, !0));
        if (this[Q].destroyed) return new Promise(function(ct, K) {
          w.nextTick(function() {
            X[Z] ? K(X[Z]) : ct(H(void 0, !0));
          });
        });
        var it, st = this[j];
        if (st) it = new Promise(et(st, this));
        else {
          var at = this[Q].read();
          if (at !== null) return Promise.resolve(H(at, !1));
          it = new Promise(this[G]);
        }
        return this[j] = it, it;
      } }, P(I, Symbol.asyncIterator, function() {
        return this;
      }), P(I, "return", function() {
        var X = this;
        return new Promise(function(ot, it) {
          X[Q].destroy(null, function(st) {
            st ? it(st) : ot(H(void 0, !0));
          });
        });
      }), I), rt), V = function(X) {
        var ot, it = Object.create(tt, (P(ot = {}, Q, { value: X, writable: !0 }), P(ot, D, { value: null, writable: !0 }), P(ot, U, { value: null, writable: !0 }), P(ot, Z, { value: null, writable: !0 }), P(ot, $, { value: X._readableState.endEmitted, writable: !0 }), P(ot, G, { value: function(st, at) {
          var ct = it[Q].read();
          ct ? (it[j] = null, it[D] = null, it[U] = null, st(H(ct, !1))) : (it[D] = st, it[U] = at);
        }, writable: !0 }), ot));
        return it[j] = null, F(X, function(st) {
          if (st && st.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var at = it[U];
            return at !== null && (it[j] = null, it[D] = null, it[U] = null, at(st)), void (it[Z] = st);
          }
          var ct = it[D];
          ct !== null && (it[j] = null, it[D] = null, it[U] = null, ct(H(void 0, !0))), it[$] = !0;
        }), X.on("readable", q.bind(null, it)), it;
      };
      m.exports = V;
    }).call(this);
  }).call(this, d("_process"));
}, { "./end-of-stream": 75, _process: 63 }], 73: [function(d, m, g) {
  function w(Q, H) {
    var W = Object.keys(Q);
    if (Object.getOwnPropertySymbols) {
      var q = Object.getOwnPropertySymbols(Q);
      H && (q = q.filter(function(et) {
        return Object.getOwnPropertyDescriptor(Q, et).enumerable;
      })), W.push.apply(W, q);
    }
    return W;
  }
  function I(Q) {
    for (var H = 1; H < arguments.length; H++) {
      var W = arguments[H] != null ? arguments[H] : {};
      H % 2 ? w(Object(W), !0).forEach(function(q) {
        P(Q, q, W[q]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Q, Object.getOwnPropertyDescriptors(W)) : w(Object(W)).forEach(function(q) {
        Object.defineProperty(Q, q, Object.getOwnPropertyDescriptor(W, q));
      });
    }
    return Q;
  }
  function P(Q, H, W) {
    return H in Q ? Object.defineProperty(Q, H, { value: W, enumerable: !0, configurable: !0, writable: !0 }) : Q[H] = W, Q;
  }
  function F(Q, H) {
    if (!(Q instanceof H)) throw new TypeError("Cannot call a class as a function");
  }
  function D(Q, H) {
    for (var W = 0; W < H.length; W++) {
      var q = H[W];
      q.enumerable = q.enumerable || !1, q.configurable = !0, "value" in q && (q.writable = !0), Object.defineProperty(Q, q.key, q);
    }
  }
  function U(Q, H, W) {
    return H && D(Q.prototype, H), Q;
  }
  var Z = d("buffer").Buffer, $ = d("util").inspect, j = $ && $.custom || "inspect";
  function G(Q, H, W) {
    Z.prototype.copy.call(Q, H, W);
  }
  m.exports = function() {
    function Q() {
      F(this, Q), this.head = null, this.tail = null, this.length = 0;
    }
    return U(Q, [{ key: "push", value: function(H) {
      var W = { data: H, next: null };
      this.length > 0 ? this.tail.next = W : this.head = W, this.tail = W, ++this.length;
    } }, { key: "unshift", value: function(H) {
      var W = { data: H, next: this.head };
      this.length === 0 && (this.tail = W), this.head = W, ++this.length;
    } }, { key: "shift", value: function() {
      if (this.length !== 0) {
        var H = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, H;
      }
    } }, { key: "clear", value: function() {
      this.head = this.tail = null, this.length = 0;
    } }, { key: "join", value: function(H) {
      if (this.length === 0) return "";
      for (var W = this.head, q = "" + W.data; W = W.next; ) q += H + W.data;
      return q;
    } }, { key: "concat", value: function(H) {
      if (this.length === 0) return Z.alloc(0);
      for (var W = Z.allocUnsafe(H >>> 0), q = this.head, et = 0; q; ) G(q.data, W, et), et += q.data.length, q = q.next;
      return W;
    } }, { key: "consume", value: function(H, W) {
      var q;
      return H < this.head.data.length ? (q = this.head.data.slice(0, H), this.head.data = this.head.data.slice(H)) : q = H === this.head.data.length ? this.shift() : W ? this._getString(H) : this._getBuffer(H), q;
    } }, { key: "first", value: function() {
      return this.head.data;
    } }, { key: "_getString", value: function(H) {
      var W = this.head, q = 1, et = W.data;
      for (H -= et.length; W = W.next; ) {
        var rt = W.data, tt = H > rt.length ? rt.length : H;
        if (tt === rt.length ? et += rt : et += rt.slice(0, H), (H -= tt) == 0) {
          tt === rt.length ? (++q, W.next ? this.head = W.next : this.head = this.tail = null) : (this.head = W, W.data = rt.slice(tt));
          break;
        }
        ++q;
      }
      return this.length -= q, et;
    } }, { key: "_getBuffer", value: function(H) {
      var W = Z.allocUnsafe(H), q = this.head, et = 1;
      for (q.data.copy(W), H -= q.data.length; q = q.next; ) {
        var rt = q.data, tt = H > rt.length ? rt.length : H;
        if (rt.copy(W, W.length - H, 0, tt), (H -= tt) == 0) {
          tt === rt.length ? (++et, q.next ? this.head = q.next : this.head = this.tail = null) : (this.head = q, q.data = rt.slice(tt));
          break;
        }
        ++et;
      }
      return this.length -= et, W;
    } }, { key: j, value: function(H, W) {
      return $(this, I({}, W, { depth: 0, customInspect: !1 }));
    } }]), Q;
  }();
}, { buffer: 32, util: 29 }], 74: [function(d, m, g) {
  (function(w) {
    (function() {
      function I($, j) {
        var G = this, Q = this._readableState && this._readableState.destroyed, H = this._writableState && this._writableState.destroyed;
        return Q || H ? (j ? j($) : $ && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, w.nextTick(U, this, $)) : w.nextTick(U, this, $)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy($ || null, function(W) {
          !j && W ? G._writableState ? G._writableState.errorEmitted ? w.nextTick(F, G) : (G._writableState.errorEmitted = !0, w.nextTick(P, G, W)) : w.nextTick(P, G, W) : j ? (w.nextTick(F, G), j(W)) : w.nextTick(F, G);
        }), this);
      }
      function P($, j) {
        U($, j), F($);
      }
      function F($) {
        $._writableState && !$._writableState.emitClose || $._readableState && !$._readableState.emitClose || $.emit("close");
      }
      function D() {
        this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
      }
      function U($, j) {
        $.emit("error", j);
      }
      function Z($, j) {
        var G = $._readableState, Q = $._writableState;
        G && G.autoDestroy || Q && Q.autoDestroy ? $.destroy(j) : $.emit("error", j);
      }
      m.exports = { destroy: I, undestroy: D, errorOrDestroy: Z };
    }).call(this);
  }).call(this, d("_process"));
}, { _process: 63 }], 75: [function(d, m, g) {
  var w = d("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
  function I(U) {
    var Z = !1;
    return function() {
      if (!Z) {
        Z = !0;
        for (var $ = arguments.length, j = new Array($), G = 0; G < $; G++) j[G] = arguments[G];
        U.apply(this, j);
      }
    };
  }
  function P() {
  }
  function F(U) {
    return U.setHeader && typeof U.abort == "function";
  }
  function D(U, Z, $) {
    if (typeof Z == "function") return D(U, null, Z);
    Z || (Z = {}), $ = I($ || P);
    var j = Z.readable || Z.readable !== !1 && U.readable, G = Z.writable || Z.writable !== !1 && U.writable, Q = function() {
      U.writable || W();
    }, H = U._writableState && U._writableState.finished, W = function() {
      G = !1, H = !0, j || $.call(U);
    }, q = U._readableState && U._readableState.endEmitted, et = function() {
      j = !1, q = !0, G || $.call(U);
    }, rt = function(X) {
      $.call(U, X);
    }, tt = function() {
      var X;
      return j && !q ? (U._readableState && U._readableState.ended || (X = new w()), $.call(U, X)) : G && !H ? (U._writableState && U._writableState.ended || (X = new w()), $.call(U, X)) : void 0;
    }, V = function() {
      U.req.on("finish", W);
    };
    return F(U) ? (U.on("complete", W), U.on("abort", tt), U.req ? V() : U.on("request", V)) : G && !U._writableState && (U.on("end", Q), U.on("close", Q)), U.on("end", et), U.on("finish", W), Z.error !== !1 && U.on("error", rt), U.on("close", tt), function() {
      U.removeListener("complete", W), U.removeListener("abort", tt), U.removeListener("request", V), U.req && U.req.removeListener("finish", W), U.removeListener("end", Q), U.removeListener("close", Q), U.removeListener("finish", W), U.removeListener("end", et), U.removeListener("error", rt), U.removeListener("close", tt);
    };
  }
  m.exports = D;
}, { "../../../errors": 66 }], 76: [function(d, m, g) {
  m.exports = function() {
    throw new Error("Readable.from is not available in the browser");
  };
}, {}], 77: [function(d, m, g) {
  var w;
  function I(W) {
    var q = !1;
    return function() {
      q || (q = !0, W.apply(void 0, arguments));
    };
  }
  var P = d("../../../errors").codes, F = P.ERR_MISSING_ARGS, D = P.ERR_STREAM_DESTROYED;
  function U(W) {
    if (W) throw W;
  }
  function Z(W) {
    return W.setHeader && typeof W.abort == "function";
  }
  function $(W, q, et, rt) {
    rt = I(rt);
    var tt = !1;
    W.on("close", function() {
      tt = !0;
    }), w === void 0 && (w = d("./end-of-stream")), w(W, { readable: q, writable: et }, function(X) {
      if (X) return rt(X);
      tt = !0, rt();
    });
    var V = !1;
    return function(X) {
      if (!tt && !V) return V = !0, Z(W) ? W.abort() : typeof W.destroy == "function" ? W.destroy() : void rt(X || new D("pipe"));
    };
  }
  function j(W) {
    W();
  }
  function G(W, q) {
    return W.pipe(q);
  }
  function Q(W) {
    return W.length ? typeof W[W.length - 1] != "function" ? U : W.pop() : U;
  }
  function H() {
    for (var W = arguments.length, q = new Array(W), et = 0; et < W; et++) q[et] = arguments[et];
    var rt, tt = Q(q);
    if (Array.isArray(q[0]) && (q = q[0]), q.length < 2) throw new F("streams");
    var V = q.map(function(X, ot) {
      var it = ot < q.length - 1;
      return $(X, it, ot > 0, function(st) {
        rt || (rt = st), st && V.forEach(j), it || (V.forEach(j), tt(rt));
      });
    });
    return q.reduce(G);
  }
  m.exports = H;
}, { "../../../errors": 66, "./end-of-stream": 75 }], 78: [function(d, m, g) {
  var w = d("../../../errors").codes.ERR_INVALID_OPT_VALUE;
  function I(F, D, U) {
    return F.highWaterMark != null ? F.highWaterMark : D ? F[U] : null;
  }
  function P(F, D, U, Z) {
    var $ = I(D, Z, U);
    if ($ != null) {
      if (!isFinite($) || Math.floor($) !== $ || $ < 0) throw new w(Z ? U : "highWaterMark", $);
      return Math.floor($);
    }
    return F.objectMode ? 16 : 16384;
  }
  m.exports = { getHighWaterMark: P };
}, { "../../../errors": 66 }], 79: [function(d, m, g) {
  m.exports = d("events").EventEmitter;
}, { events: 35 }], 80: [function(d, m, g) {
  var w = d("safe-buffer").Buffer, I = w.isEncoding || function(V) {
    switch ((V = "" + V) && V.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function P(V) {
    if (!V) return "utf8";
    for (var X; ; ) switch (V) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return V;
      default:
        if (X) return;
        V = ("" + V).toLowerCase(), X = !0;
    }
  }
  function F(V) {
    var X = P(V);
    if (typeof X != "string" && (w.isEncoding === I || !I(V))) throw new Error("Unknown encoding: " + V);
    return X || V;
  }
  function D(V) {
    var X;
    switch (this.encoding = F(V), this.encoding) {
      case "utf16le":
        this.text = H, this.end = W, X = 4;
        break;
      case "utf8":
        this.fillLast = j, X = 4;
        break;
      case "base64":
        this.text = q, this.end = et, X = 3;
        break;
      default:
        return this.write = rt, void (this.end = tt);
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = w.allocUnsafe(X);
  }
  function U(V) {
    return V <= 127 ? 0 : V >> 5 == 6 ? 2 : V >> 4 == 14 ? 3 : V >> 3 == 30 ? 4 : V >> 6 == 2 ? -1 : -2;
  }
  function Z(V, X, ot) {
    var it = X.length - 1;
    if (it < ot) return 0;
    var st = U(X[it]);
    return st >= 0 ? (st > 0 && (V.lastNeed = st - 1), st) : --it < ot || st === -2 ? 0 : (st = U(X[it])) >= 0 ? (st > 0 && (V.lastNeed = st - 2), st) : --it < ot || st === -2 ? 0 : (st = U(X[it])) >= 0 ? (st > 0 && (st === 2 ? st = 0 : V.lastNeed = st - 3), st) : 0;
  }
  function $(V, X, ot) {
    if ((192 & X[0]) != 128) return V.lastNeed = 0, "";
    if (V.lastNeed > 1 && X.length > 1) {
      if ((192 & X[1]) != 128) return V.lastNeed = 1, "";
      if (V.lastNeed > 2 && X.length > 2 && (192 & X[2]) != 128) return V.lastNeed = 2, "";
    }
  }
  function j(V) {
    var X = this.lastTotal - this.lastNeed, ot = $(this, V);
    return ot !== void 0 ? ot : this.lastNeed <= V.length ? (V.copy(this.lastChar, X, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (V.copy(this.lastChar, X, 0, V.length), void (this.lastNeed -= V.length));
  }
  function G(V, X) {
    var ot = Z(this, V, X);
    if (!this.lastNeed) return V.toString("utf8", X);
    this.lastTotal = ot;
    var it = V.length - (ot - this.lastNeed);
    return V.copy(this.lastChar, 0, it), V.toString("utf8", X, it);
  }
  function Q(V) {
    var X = V && V.length ? this.write(V) : "";
    return this.lastNeed ? X + "" : X;
  }
  function H(V, X) {
    if ((V.length - X) % 2 == 0) {
      var ot = V.toString("utf16le", X);
      if (ot) {
        var it = ot.charCodeAt(ot.length - 1);
        if (it >= 55296 && it <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = V[V.length - 2], this.lastChar[1] = V[V.length - 1], ot.slice(0, -1);
      }
      return ot;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = V[V.length - 1], V.toString("utf16le", X, V.length - 1);
  }
  function W(V) {
    var X = V && V.length ? this.write(V) : "";
    if (this.lastNeed) {
      var ot = this.lastTotal - this.lastNeed;
      return X + this.lastChar.toString("utf16le", 0, ot);
    }
    return X;
  }
  function q(V, X) {
    var ot = (V.length - X) % 3;
    return ot === 0 ? V.toString("base64", X) : (this.lastNeed = 3 - ot, this.lastTotal = 3, ot === 1 ? this.lastChar[0] = V[V.length - 1] : (this.lastChar[0] = V[V.length - 2], this.lastChar[1] = V[V.length - 1]), V.toString("base64", X, V.length - ot));
  }
  function et(V) {
    var X = V && V.length ? this.write(V) : "";
    return this.lastNeed ? X + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : X;
  }
  function rt(V) {
    return V.toString(this.encoding);
  }
  function tt(V) {
    return V && V.length ? this.write(V) : "";
  }
  g.StringDecoder = D, D.prototype.write = function(V) {
    if (V.length === 0) return "";
    var X, ot;
    if (this.lastNeed) {
      if ((X = this.fillLast(V)) === void 0) return "";
      ot = this.lastNeed, this.lastNeed = 0;
    } else ot = 0;
    return ot < V.length ? X ? X + this.text(V, ot) : this.text(V, ot) : X || "";
  }, D.prototype.end = Q, D.prototype.text = G, D.prototype.fillLast = function(V) {
    if (this.lastNeed <= V.length) return V.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    V.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, V.length), this.lastNeed -= V.length;
  };
}, { "safe-buffer": 64 }], 81: [function(d, m, g) {
  (function(w) {
    (function() {
      function I(F, D) {
        if (P("noDeprecation")) return F;
        var U = !1;
        function Z() {
          if (!U) {
            if (P("throwDeprecation")) throw new Error(D);
            P("traceDeprecation") ? console.trace(D) : console.warn(D), U = !0;
          }
          return F.apply(this, arguments);
        }
        return Z;
      }
      function P(F) {
        try {
          if (!w.localStorage) return !1;
        } catch {
          return !1;
        }
        var D = w.localStorage[F];
        return D != null && String(D).toLowerCase() === "true";
      }
      m.exports = I;
    }).call(this);
  }).call(this, commonjsGlobal !== void 0 ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
}, {}], 82: [function(d, m, g) {
  arguments[4][25][0].apply(g, arguments);
}, { dup: 25 }], 83: [function(d, m, g) {
  var w = d("is-arguments"), I = d("is-generator-function"), P = d("which-typed-array"), F = d("is-typed-array");
  function D(yt) {
    return yt.call.bind(yt);
  }
  var U = typeof BigInt < "u", Z = typeof Symbol < "u", $ = D(Object.prototype.toString), j = D(Number.prototype.valueOf), G = D(String.prototype.valueOf), Q = D(Boolean.prototype.valueOf);
  if (U) var H = D(BigInt.prototype.valueOf);
  if (Z) var W = D(Symbol.prototype.valueOf);
  function q(yt, Lt) {
    if (typeof yt != "object") return !1;
    try {
      return Lt(yt), !0;
    } catch {
      return !1;
    }
  }
  function et(yt) {
    return typeof Promise < "u" && yt instanceof Promise || yt !== null && typeof yt == "object" && typeof yt.then == "function" && typeof yt.catch == "function";
  }
  function rt(yt) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(yt) : F(yt) || kt(yt);
  }
  function tt(yt) {
    return P(yt) === "Uint8Array";
  }
  function V(yt) {
    return P(yt) === "Uint8ClampedArray";
  }
  function X(yt) {
    return P(yt) === "Uint16Array";
  }
  function ot(yt) {
    return P(yt) === "Uint32Array";
  }
  function it(yt) {
    return P(yt) === "Int8Array";
  }
  function st(yt) {
    return P(yt) === "Int16Array";
  }
  function at(yt) {
    return P(yt) === "Int32Array";
  }
  function ct(yt) {
    return P(yt) === "Float32Array";
  }
  function K(yt) {
    return P(yt) === "Float64Array";
  }
  function lt(yt) {
    return P(yt) === "BigInt64Array";
  }
  function vt(yt) {
    return P(yt) === "BigUint64Array";
  }
  function dt(yt) {
    return $(yt) === "[object Map]";
  }
  function ht(yt) {
    return typeof Map < "u" && (dt.working ? dt(yt) : yt instanceof Map);
  }
  function pt(yt) {
    return $(yt) === "[object Set]";
  }
  function Ct(yt) {
    return typeof Set < "u" && (pt.working ? pt(yt) : yt instanceof Set);
  }
  function St(yt) {
    return $(yt) === "[object WeakMap]";
  }
  function At(yt) {
    return typeof WeakMap < "u" && (St.working ? St(yt) : yt instanceof WeakMap);
  }
  function Ft(yt) {
    return $(yt) === "[object WeakSet]";
  }
  function xt(yt) {
    return Ft(yt);
  }
  function Pt(yt) {
    return $(yt) === "[object ArrayBuffer]";
  }
  function Ot(yt) {
    return typeof ArrayBuffer < "u" && (Pt.working ? Pt(yt) : yt instanceof ArrayBuffer);
  }
  function Bt(yt) {
    return $(yt) === "[object DataView]";
  }
  function kt(yt) {
    return typeof DataView < "u" && (Bt.working ? Bt(yt) : yt instanceof DataView);
  }
  g.isArgumentsObject = w, g.isGeneratorFunction = I, g.isTypedArray = F, g.isPromise = et, g.isArrayBufferView = rt, g.isUint8Array = tt, g.isUint8ClampedArray = V, g.isUint16Array = X, g.isUint32Array = ot, g.isInt8Array = it, g.isInt16Array = st, g.isInt32Array = at, g.isFloat32Array = ct, g.isFloat64Array = K, g.isBigInt64Array = lt, g.isBigUint64Array = vt, dt.working = typeof Map < "u" && dt(/* @__PURE__ */ new Map()), g.isMap = ht, pt.working = typeof Set < "u" && pt(/* @__PURE__ */ new Set()), g.isSet = Ct, St.working = typeof WeakMap < "u" && St(/* @__PURE__ */ new WeakMap()), g.isWeakMap = At, Ft.working = typeof WeakSet < "u" && Ft(/* @__PURE__ */ new WeakSet()), g.isWeakSet = xt, Pt.working = typeof ArrayBuffer < "u" && Pt(new ArrayBuffer()), g.isArrayBuffer = Ot, Bt.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && Bt(new DataView(new ArrayBuffer(1), 0, 1)), g.isDataView = kt;
  var Tt = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function Dt(yt) {
    return $(yt) === "[object SharedArrayBuffer]";
  }
  function Zt(yt) {
    return Tt !== void 0 && (Dt.working === void 0 && (Dt.working = Dt(new Tt())), Dt.working ? Dt(yt) : yt instanceof Tt);
  }
  function $t(yt) {
    return $(yt) === "[object AsyncFunction]";
  }
  function Mt(yt) {
    return $(yt) === "[object Map Iterator]";
  }
  function nt(yt) {
    return $(yt) === "[object Set Iterator]";
  }
  function It(yt) {
    return $(yt) === "[object Generator]";
  }
  function mt(yt) {
    return $(yt) === "[object WebAssembly.Module]";
  }
  function gt(yt) {
    return q(yt, j);
  }
  function _t(yt) {
    return q(yt, G);
  }
  function wt(yt) {
    return q(yt, Q);
  }
  function Rt(yt) {
    return U && q(yt, H);
  }
  function J(yt) {
    return Z && q(yt, W);
  }
  function ut(yt) {
    return gt(yt) || _t(yt) || wt(yt) || Rt(yt) || J(yt);
  }
  function bt(yt) {
    return typeof Uint8Array < "u" && (Ot(yt) || Zt(yt));
  }
  g.isSharedArrayBuffer = Zt, g.isAsyncFunction = $t, g.isMapIterator = Mt, g.isSetIterator = nt, g.isGeneratorObject = It, g.isWebAssemblyCompiledModule = mt, g.isNumberObject = gt, g.isStringObject = _t, g.isBooleanObject = wt, g.isBigIntObject = Rt, g.isSymbolObject = J, g.isBoxedPrimitive = ut, g.isAnyArrayBuffer = bt, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(yt) {
    Object.defineProperty(g, yt, { enumerable: !1, value: function() {
      throw new Error(yt + " is not supported in userland");
    } });
  });
}, { "is-arguments": 47, "is-generator-function": 49, "is-typed-array": 50, "which-typed-array": 85 }], 84: [function(d, m, g) {
  (function(w) {
    (function() {
      var I = Object.getOwnPropertyDescriptors || function(kt) {
        for (var Tt = Object.keys(kt), Dt = {}, Zt = 0; Zt < Tt.length; Zt++) Dt[Tt[Zt]] = Object.getOwnPropertyDescriptor(kt, Tt[Zt]);
        return Dt;
      }, P = /%[sdj%]/g;
      g.format = function(kt) {
        if (!st(kt)) {
          for (var Tt = [], Dt = 0; Dt < arguments.length; Dt++) Tt.push(Z(arguments[Dt]));
          return Tt.join(" ");
        }
        Dt = 1;
        for (var Zt = arguments, $t = Zt.length, Mt = String(kt).replace(P, function(It) {
          if (It === "%%") return "%";
          if (Dt >= $t) return It;
          switch (It) {
            case "%s":
              return String(Zt[Dt++]);
            case "%d":
              return Number(Zt[Dt++]);
            case "%j":
              try {
                return JSON.stringify(Zt[Dt++]);
              } catch {
                return "[Circular]";
              }
            default:
              return It;
          }
        }), nt = Zt[Dt]; Dt < $t; nt = Zt[++Dt]) X(nt) || !lt(nt) ? Mt += " " + nt : Mt += " " + Z(nt);
        return Mt;
      }, g.deprecate = function(kt, Tt) {
        if (w !== void 0 && w.noDeprecation === !0) return kt;
        if (w === void 0) return function() {
          return g.deprecate(kt, Tt).apply(this, arguments);
        };
        var Dt = !1;
        function Zt() {
          if (!Dt) {
            if (w.throwDeprecation) throw new Error(Tt);
            w.traceDeprecation ? console.trace(Tt) : console.error(Tt), Dt = !0;
          }
          return kt.apply(this, arguments);
        }
        return Zt;
      };
      var F = {}, D = /^$/;
      if (w.env.NODE_DEBUG) {
        var U = w.env.NODE_DEBUG;
        U = U.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), D = new RegExp("^" + U + "$", "i");
      }
      function Z(kt, Tt) {
        var Dt = { seen: [], stylize: j };
        return arguments.length >= 3 && (Dt.depth = arguments[2]), arguments.length >= 4 && (Dt.colors = arguments[3]), V(Tt) ? Dt.showHidden = Tt : Tt && g._extend(Dt, Tt), ct(Dt.showHidden) && (Dt.showHidden = !1), ct(Dt.depth) && (Dt.depth = 2), ct(Dt.colors) && (Dt.colors = !1), ct(Dt.customInspect) && (Dt.customInspect = !0), Dt.colors && (Dt.stylize = $), Q(Dt, kt, Dt.depth);
      }
      function $(kt, Tt) {
        var Dt = Z.styles[Tt];
        return Dt ? "\x1B[" + Z.colors[Dt][0] + "m" + kt + "\x1B[" + Z.colors[Dt][1] + "m" : kt;
      }
      function j(kt, Tt) {
        return kt;
      }
      function G(kt) {
        var Tt = {};
        return kt.forEach(function(Dt, Zt) {
          Tt[Dt] = !0;
        }), Tt;
      }
      function Q(kt, Tt, Dt) {
        if (kt.customInspect && Tt && ht(Tt.inspect) && Tt.inspect !== g.inspect && (!Tt.constructor || Tt.constructor.prototype !== Tt)) {
          var Zt = Tt.inspect(Dt, kt);
          return st(Zt) || (Zt = Q(kt, Zt, Dt)), Zt;
        }
        var $t = H(kt, Tt);
        if ($t) return $t;
        var Mt = Object.keys(Tt), nt = G(Mt);
        if (kt.showHidden && (Mt = Object.getOwnPropertyNames(Tt)), dt(Tt) && (Mt.indexOf("message") >= 0 || Mt.indexOf("description") >= 0)) return W(Tt);
        if (Mt.length === 0) {
          if (ht(Tt)) {
            var It = Tt.name ? ": " + Tt.name : "";
            return kt.stylize("[Function" + It + "]", "special");
          }
          if (K(Tt)) return kt.stylize(RegExp.prototype.toString.call(Tt), "regexp");
          if (vt(Tt)) return kt.stylize(Date.prototype.toString.call(Tt), "date");
          if (dt(Tt)) return W(Tt);
        }
        var mt, gt = "", _t = !1, wt = ["{", "}"];
        return tt(Tt) && (_t = !0, wt = ["[", "]"]), ht(Tt) && (gt = " [Function" + (Tt.name ? ": " + Tt.name : "") + "]"), K(Tt) && (gt = " " + RegExp.prototype.toString.call(Tt)), vt(Tt) && (gt = " " + Date.prototype.toUTCString.call(Tt)), dt(Tt) && (gt = " " + W(Tt)), Mt.length !== 0 || _t && Tt.length != 0 ? Dt < 0 ? K(Tt) ? kt.stylize(RegExp.prototype.toString.call(Tt), "regexp") : kt.stylize("[Object]", "special") : (kt.seen.push(Tt), mt = _t ? q(kt, Tt, Dt, nt, Mt) : Mt.map(function(Rt) {
          return et(kt, Tt, Dt, nt, Rt, _t);
        }), kt.seen.pop(), rt(mt, gt, wt)) : wt[0] + gt + wt[1];
      }
      function H(kt, Tt) {
        if (ct(Tt)) return kt.stylize("undefined", "undefined");
        if (st(Tt)) {
          var Dt = "'" + JSON.stringify(Tt).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return kt.stylize(Dt, "string");
        }
        return it(Tt) ? kt.stylize("" + Tt, "number") : V(Tt) ? kt.stylize("" + Tt, "boolean") : X(Tt) ? kt.stylize("null", "null") : void 0;
      }
      function W(kt) {
        return "[" + Error.prototype.toString.call(kt) + "]";
      }
      function q(kt, Tt, Dt, Zt, $t) {
        for (var Mt = [], nt = 0, It = Tt.length; nt < It; ++nt) xt(Tt, String(nt)) ? Mt.push(et(kt, Tt, Dt, Zt, String(nt), !0)) : Mt.push("");
        return $t.forEach(function(mt) {
          mt.match(/^\d+$/) || Mt.push(et(kt, Tt, Dt, Zt, mt, !0));
        }), Mt;
      }
      function et(kt, Tt, Dt, Zt, $t, Mt) {
        var nt, It, mt;
        if ((mt = Object.getOwnPropertyDescriptor(Tt, $t) || { value: Tt[$t] }).get ? It = mt.set ? kt.stylize("[Getter/Setter]", "special") : kt.stylize("[Getter]", "special") : mt.set && (It = kt.stylize("[Setter]", "special")), xt(Zt, $t) || (nt = "[" + $t + "]"), It || (kt.seen.indexOf(mt.value) < 0 ? (It = X(Dt) ? Q(kt, mt.value, null) : Q(kt, mt.value, Dt - 1)).indexOf(`
`) > -1 && (It = Mt ? It.split(`
`).map(function(gt) {
          return "  " + gt;
        }).join(`
`).slice(2) : `
` + It.split(`
`).map(function(gt) {
          return "   " + gt;
        }).join(`
`)) : It = kt.stylize("[Circular]", "special")), ct(nt)) {
          if (Mt && $t.match(/^\d+$/)) return It;
          (nt = JSON.stringify("" + $t)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (nt = nt.slice(1, -1), nt = kt.stylize(nt, "name")) : (nt = nt.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), nt = kt.stylize(nt, "string"));
        }
        return nt + ": " + It;
      }
      function rt(kt, Tt, Dt) {
        return kt.reduce(function(Zt, $t) {
          return $t.indexOf(`
`), Zt + $t.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0) > 60 ? Dt[0] + (Tt === "" ? "" : Tt + `
 `) + " " + kt.join(`,
  `) + " " + Dt[1] : Dt[0] + Tt + " " + kt.join(", ") + " " + Dt[1];
      }
      function tt(kt) {
        return Array.isArray(kt);
      }
      function V(kt) {
        return typeof kt == "boolean";
      }
      function X(kt) {
        return kt === null;
      }
      function ot(kt) {
        return kt == null;
      }
      function it(kt) {
        return typeof kt == "number";
      }
      function st(kt) {
        return typeof kt == "string";
      }
      function at(kt) {
        return typeof kt == "symbol";
      }
      function ct(kt) {
        return kt === void 0;
      }
      function K(kt) {
        return lt(kt) && Ct(kt) === "[object RegExp]";
      }
      function lt(kt) {
        return typeof kt == "object" && kt !== null;
      }
      function vt(kt) {
        return lt(kt) && Ct(kt) === "[object Date]";
      }
      function dt(kt) {
        return lt(kt) && (Ct(kt) === "[object Error]" || kt instanceof Error);
      }
      function ht(kt) {
        return typeof kt == "function";
      }
      function pt(kt) {
        return kt === null || typeof kt == "boolean" || typeof kt == "number" || typeof kt == "string" || typeof kt == "symbol" || kt === void 0;
      }
      function Ct(kt) {
        return Object.prototype.toString.call(kt);
      }
      function St(kt) {
        return kt < 10 ? "0" + kt.toString(10) : kt.toString(10);
      }
      g.debuglog = function(kt) {
        if (kt = kt.toUpperCase(), !F[kt]) if (D.test(kt)) {
          var Tt = w.pid;
          F[kt] = function() {
            var Dt = g.format.apply(g, arguments);
            console.error("%s %d: %s", kt, Tt, Dt);
          };
        } else F[kt] = function() {
        };
        return F[kt];
      }, g.inspect = Z, Z.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, Z.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, g.types = d("./support/types"), g.isArray = tt, g.isBoolean = V, g.isNull = X, g.isNullOrUndefined = ot, g.isNumber = it, g.isString = st, g.isSymbol = at, g.isUndefined = ct, g.isRegExp = K, g.types.isRegExp = K, g.isObject = lt, g.isDate = vt, g.types.isDate = vt, g.isError = dt, g.types.isNativeError = dt, g.isFunction = ht, g.isPrimitive = pt, g.isBuffer = d("./support/isBuffer");
      var At = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      function Ft() {
        var kt = /* @__PURE__ */ new Date(), Tt = [St(kt.getHours()), St(kt.getMinutes()), St(kt.getSeconds())].join(":");
        return [kt.getDate(), At[kt.getMonth()], Tt].join(" ");
      }
      function xt(kt, Tt) {
        return Object.prototype.hasOwnProperty.call(kt, Tt);
      }
      g.log = function() {
        console.log("%s - %s", Ft(), g.format.apply(g, arguments));
      }, g.inherits = d("inherits"), g._extend = function(kt, Tt) {
        if (!Tt || !lt(Tt)) return kt;
        for (var Dt = Object.keys(Tt), Zt = Dt.length; Zt--; ) kt[Dt[Zt]] = Tt[Dt[Zt]];
        return kt;
      };
      var Pt = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
      function Ot(kt, Tt) {
        if (!kt) {
          var Dt = new Error("Promise was rejected with a falsy value");
          Dt.reason = kt, kt = Dt;
        }
        return Tt(kt);
      }
      function Bt(kt) {
        if (typeof kt != "function") throw new TypeError('The "original" argument must be of type Function');
        function Tt() {
          for (var Dt = [], Zt = 0; Zt < arguments.length; Zt++) Dt.push(arguments[Zt]);
          var $t = Dt.pop();
          if (typeof $t != "function") throw new TypeError("The last argument must be of type Function");
          var Mt = this, nt = function() {
            return $t.apply(Mt, arguments);
          };
          kt.apply(this, Dt).then(function(It) {
            w.nextTick(nt.bind(null, null, It));
          }, function(It) {
            w.nextTick(Ot.bind(null, It, nt));
          });
        }
        return Object.setPrototypeOf(Tt, Object.getPrototypeOf(kt)), Object.defineProperties(Tt, I(kt)), Tt;
      }
      g.promisify = function(kt) {
        if (typeof kt != "function") throw new TypeError('The "original" argument must be of type Function');
        if (Pt && kt[Pt]) {
          var Tt;
          if (typeof (Tt = kt[Pt]) != "function") throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          return Object.defineProperty(Tt, Pt, { value: Tt, enumerable: !1, writable: !1, configurable: !0 }), Tt;
        }
        function Tt() {
          for (var Dt, Zt, $t = new Promise(function(It, mt) {
            Dt = It, Zt = mt;
          }), Mt = [], nt = 0; nt < arguments.length; nt++) Mt.push(arguments[nt]);
          Mt.push(function(It, mt) {
            It ? Zt(It) : Dt(mt);
          });
          try {
            kt.apply(this, Mt);
          } catch (It) {
            Zt(It);
          }
          return $t;
        }
        return Object.setPrototypeOf(Tt, Object.getPrototypeOf(kt)), Pt && Object.defineProperty(Tt, Pt, { value: Tt, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(Tt, I(kt));
      }, g.promisify.custom = Pt, g.callbackify = Bt;
    }).call(this);
  }).call(this, d("_process"));
}, { "./support/isBuffer": 82, "./support/types": 83, _process: 63, inherits: 46 }], 85: [function(d, m, g) {
  (function(w) {
    (function() {
      var I = d("for-each"), P = d("available-typed-arrays"), F = d("call-bind/callBound"), D = d("gopd"), U = F("Object.prototype.toString"), Z = d("has-tostringtag/shams")(), $ = typeof globalThis > "u" ? w : globalThis, j = P(), G = F("String.prototype.slice"), Q = {}, H = Object.getPrototypeOf;
      Z && D && H && I(j, function(et) {
        if (typeof $[et] == "function") {
          var rt = new $[et]();
          if (Symbol.toStringTag in rt) {
            var tt = H(rt), V = D(tt, Symbol.toStringTag);
            if (!V) {
              var X = H(tt);
              V = D(X, Symbol.toStringTag);
            }
            Q[et] = V.get;
          }
        }
      });
      var W = function(et) {
        var rt = !1;
        return I(Q, function(tt, V) {
          if (!rt) try {
            var X = tt.call(et);
            X === V && (rt = X);
          } catch {
          }
        }), rt;
      }, q = d("is-typed-array");
      m.exports = function(et) {
        return !!q(et) && (Z && Symbol.toStringTag in et ? W(et) : G(U(et), 8, -1));
      };
    }).call(this);
  }).call(this, commonjsGlobal !== void 0 ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
}, { "available-typed-arrays": 27, "call-bind/callBound": 33, "for-each": 36, gopd: 40, "has-tostringtag/shams": 43, "is-typed-array": 50 }] }, {}, [20])(20);
var browserExports = browser$1.exports, PNGFilterType, PNGFilterType2, PNGColorType, PNGColorType2;
function png() {
  return { mime: "image/png", hasAlpha: !0, encode: (d, { deflateLevel: m = 9, deflateStrategy: g = 3, filterType: w = PNGFilterType.AUTO, colorType: I, inputHasAlpha: P = !0, ...F } = {}) => {
    const D = new browserExports.PNG({ width: d.width, height: d.height });
    return D.data = d.data, browserExports.PNG.sync.write(D, { ...F, deflateLevel: m, deflateStrategy: g, filterType: w, colorType: I !== void 0 ? I : P ? PNGColorType.COLOR_ALPHA : PNGColorType.COLOR, inputHasAlpha: P });
  }, decode: (d, m) => {
    const g = browserExports.PNG.sync.read(d, m);
    return { data: g.data, width: g.width, height: g.height };
  } };
}
PNGFilterType2 = PNGFilterType || (PNGFilterType = {}), PNGFilterType2[PNGFilterType2.AUTO = -1] = "AUTO", PNGFilterType2[PNGFilterType2.NONE = 0] = "NONE", PNGFilterType2[PNGFilterType2.SUB = 1] = "SUB", PNGFilterType2[PNGFilterType2.UP = 2] = "UP", PNGFilterType2[PNGFilterType2.AVERAGE = 3] = "AVERAGE", PNGFilterType2[PNGFilterType2.PATH = 4] = "PATH", PNGColorType2 = PNGColorType || (PNGColorType = {}), PNGColorType2[PNGColorType2.GRAYSCALE = 0] = "GRAYSCALE", PNGColorType2[PNGColorType2.COLOR = 2] = "COLOR", PNGColorType2[PNGColorType2.GRAYSCALE_ALPHA = 4] = "GRAYSCALE_ALPHA", PNGColorType2[PNGColorType2.COLOR_ALPHA = 6] = "COLOR_ALPHA";
var UTIF = { exports: {} }, common = {}, hasRequiredCommon;
function requireCommon() {
  return hasRequiredCommon || (hasRequiredCommon = 1, function(d) {
    var m = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
    function g(P, F) {
      return Object.prototype.hasOwnProperty.call(P, F);
    }
    d.assign = function(P) {
      for (var F = Array.prototype.slice.call(arguments, 1); F.length; ) {
        var D = F.shift();
        if (D) {
          if (typeof D != "object") throw new TypeError(D + "must be non-object");
          for (var U in D) g(D, U) && (P[U] = D[U]);
        }
      }
      return P;
    }, d.shrinkBuf = function(P, F) {
      return P.length === F ? P : P.subarray ? P.subarray(0, F) : (P.length = F, P);
    };
    var w = { arraySet: function(P, F, D, U, Z) {
      if (F.subarray && P.subarray) P.set(F.subarray(D, D + U), Z);
      else for (var $ = 0; $ < U; $++) P[Z + $] = F[D + $];
    }, flattenChunks: function(P) {
      var F, D, U, Z, $, j;
      for (U = 0, F = 0, D = P.length; F < D; F++) U += P[F].length;
      for (j = new Uint8Array(U), Z = 0, F = 0, D = P.length; F < D; F++) $ = P[F], j.set($, Z), Z += $.length;
      return j;
    } }, I = { arraySet: function(P, F, D, U, Z) {
      for (var $ = 0; $ < U; $++) P[Z + $] = F[D + $];
    }, flattenChunks: function(P) {
      return [].concat.apply([], P);
    } };
    d.setTyped = function(P) {
      P ? (d.Buf8 = Uint8Array, d.Buf16 = Uint16Array, d.Buf32 = Int32Array, d.assign(d, w)) : (d.Buf8 = Array, d.Buf16 = Array, d.Buf32 = Array, d.assign(d, I));
    }, d.setTyped(m);
  }(common)), common;
}
var deflate$1 = {}, deflate = {}, trees = {}, hasRequiredTrees, adler32_1, hasRequiredAdler32, crc32_1, hasRequiredCrc32, messages, hasRequiredMessages, hasRequiredDeflate$1;
function requireTrees() {
  if (hasRequiredTrees) return trees;
  hasRequiredTrees = 1;
  var d = requireCommon(), m = 0, g = 1;
  function w(mt) {
    for (var gt = mt.length; --gt >= 0; ) mt[gt] = 0;
  }
  var I = 0, P = 29, F = 256, D = F + 1 + P, U = 30, Z = 19, $ = 2 * D + 1, j = 15, G = 16, Q = 7, H = 256, W = 16, q = 17, et = 18, rt = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], tt = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], V = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], X = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], ot = new Array(2 * (D + 2));
  w(ot);
  var it = new Array(2 * U);
  w(it);
  var st = new Array(512);
  w(st);
  var at = new Array(256);
  w(at);
  var ct = new Array(P);
  w(ct);
  var K, lt, vt, dt = new Array(U);
  function ht(mt, gt, _t, wt, Rt) {
    this.static_tree = mt, this.extra_bits = gt, this.extra_base = _t, this.elems = wt, this.max_length = Rt, this.has_stree = mt && mt.length;
  }
  function pt(mt, gt) {
    this.dyn_tree = mt, this.max_code = 0, this.stat_desc = gt;
  }
  function Ct(mt) {
    return mt < 256 ? st[mt] : st[256 + (mt >>> 7)];
  }
  function St(mt, gt) {
    mt.pending_buf[mt.pending++] = 255 & gt, mt.pending_buf[mt.pending++] = gt >>> 8 & 255;
  }
  function At(mt, gt, _t) {
    mt.bi_valid > G - _t ? (mt.bi_buf |= gt << mt.bi_valid & 65535, St(mt, mt.bi_buf), mt.bi_buf = gt >> G - mt.bi_valid, mt.bi_valid += _t - G) : (mt.bi_buf |= gt << mt.bi_valid & 65535, mt.bi_valid += _t);
  }
  function Ft(mt, gt, _t) {
    At(mt, _t[2 * gt], _t[2 * gt + 1]);
  }
  function xt(mt, gt) {
    var _t = 0;
    do
      _t |= 1 & mt, mt >>>= 1, _t <<= 1;
    while (--gt > 0);
    return _t >>> 1;
  }
  function Pt(mt, gt, _t) {
    var wt, Rt, J = new Array(j + 1), ut = 0;
    for (wt = 1; wt <= j; wt++) J[wt] = ut = ut + _t[wt - 1] << 1;
    for (Rt = 0; Rt <= gt; Rt++) {
      var bt = mt[2 * Rt + 1];
      bt !== 0 && (mt[2 * Rt] = xt(J[bt]++, bt));
    }
  }
  function Ot(mt) {
    var gt;
    for (gt = 0; gt < D; gt++) mt.dyn_ltree[2 * gt] = 0;
    for (gt = 0; gt < U; gt++) mt.dyn_dtree[2 * gt] = 0;
    for (gt = 0; gt < Z; gt++) mt.bl_tree[2 * gt] = 0;
    mt.dyn_ltree[2 * H] = 1, mt.opt_len = mt.static_len = 0, mt.last_lit = mt.matches = 0;
  }
  function Bt(mt) {
    mt.bi_valid > 8 ? St(mt, mt.bi_buf) : mt.bi_valid > 0 && (mt.pending_buf[mt.pending++] = mt.bi_buf), mt.bi_buf = 0, mt.bi_valid = 0;
  }
  function kt(mt, gt, _t, wt) {
    var Rt = 2 * gt, J = 2 * _t;
    return mt[Rt] < mt[J] || mt[Rt] === mt[J] && wt[gt] <= wt[_t];
  }
  function Tt(mt, gt, _t) {
    for (var wt = mt.heap[_t], Rt = _t << 1; Rt <= mt.heap_len && (Rt < mt.heap_len && kt(gt, mt.heap[Rt + 1], mt.heap[Rt], mt.depth) && Rt++, !kt(gt, wt, mt.heap[Rt], mt.depth)); ) mt.heap[_t] = mt.heap[Rt], _t = Rt, Rt <<= 1;
    mt.heap[_t] = wt;
  }
  function Dt(mt, gt, _t) {
    var wt, Rt, J, ut, bt = 0;
    if (mt.last_lit !== 0) do
      wt = mt.pending_buf[mt.d_buf + 2 * bt] << 8 | mt.pending_buf[mt.d_buf + 2 * bt + 1], Rt = mt.pending_buf[mt.l_buf + bt], bt++, wt === 0 ? Ft(mt, Rt, gt) : (Ft(mt, (J = at[Rt]) + F + 1, gt), (ut = rt[J]) !== 0 && At(mt, Rt -= ct[J], ut), Ft(mt, J = Ct(--wt), _t), (ut = tt[J]) !== 0 && At(mt, wt -= dt[J], ut));
    while (bt < mt.last_lit);
    Ft(mt, H, gt);
  }
  function Zt(mt, gt) {
    var _t, wt, Rt, J = gt.dyn_tree, ut = gt.stat_desc.static_tree, bt = gt.stat_desc.has_stree, yt = gt.stat_desc.elems, Lt = -1;
    for (mt.heap_len = 0, mt.heap_max = $, _t = 0; _t < yt; _t++) J[2 * _t] !== 0 ? (mt.heap[++mt.heap_len] = Lt = _t, mt.depth[_t] = 0) : J[2 * _t + 1] = 0;
    for (; mt.heap_len < 2; ) J[2 * (Rt = mt.heap[++mt.heap_len] = Lt < 2 ? ++Lt : 0)] = 1, mt.depth[Rt] = 0, mt.opt_len--, bt && (mt.static_len -= ut[2 * Rt + 1]);
    for (gt.max_code = Lt, _t = mt.heap_len >> 1; _t >= 1; _t--) Tt(mt, J, _t);
    Rt = yt;
    do
      _t = mt.heap[1], mt.heap[1] = mt.heap[mt.heap_len--], Tt(mt, J, 1), wt = mt.heap[1], mt.heap[--mt.heap_max] = _t, mt.heap[--mt.heap_max] = wt, J[2 * Rt] = J[2 * _t] + J[2 * wt], mt.depth[Rt] = (mt.depth[_t] >= mt.depth[wt] ? mt.depth[_t] : mt.depth[wt]) + 1, J[2 * _t + 1] = J[2 * wt + 1] = Rt, mt.heap[1] = Rt++, Tt(mt, J, 1);
    while (mt.heap_len >= 2);
    mt.heap[--mt.heap_max] = mt.heap[1], function(jt, Kt) {
      var te, Vt, ee, Jt, le, ae, se = Kt.dyn_tree, fe = Kt.max_code, ne = Kt.stat_desc.static_tree, Nt = Kt.stat_desc.has_stree, Xt = Kt.stat_desc.extra_bits, Ut = Kt.stat_desc.extra_base, Wt = Kt.stat_desc.max_length, Et = 0;
      for (Jt = 0; Jt <= j; Jt++) jt.bl_count[Jt] = 0;
      for (se[2 * jt.heap[jt.heap_max] + 1] = 0, te = jt.heap_max + 1; te < $; te++) (Jt = se[2 * se[2 * (Vt = jt.heap[te]) + 1] + 1] + 1) > Wt && (Jt = Wt, Et++), se[2 * Vt + 1] = Jt, Vt > fe || (jt.bl_count[Jt]++, le = 0, Vt >= Ut && (le = Xt[Vt - Ut]), ae = se[2 * Vt], jt.opt_len += ae * (Jt + le), Nt && (jt.static_len += ae * (ne[2 * Vt + 1] + le)));
      if (Et !== 0) {
        do {
          for (Jt = Wt - 1; jt.bl_count[Jt] === 0; ) Jt--;
          jt.bl_count[Jt]--, jt.bl_count[Jt + 1] += 2, jt.bl_count[Wt]--, Et -= 2;
        } while (Et > 0);
        for (Jt = Wt; Jt !== 0; Jt--) for (Vt = jt.bl_count[Jt]; Vt !== 0; ) (ee = jt.heap[--te]) > fe || (se[2 * ee + 1] !== Jt && (jt.opt_len += (Jt - se[2 * ee + 1]) * se[2 * ee], se[2 * ee + 1] = Jt), Vt--);
      }
    }(mt, gt), Pt(J, Lt, mt.bl_count);
  }
  function $t(mt, gt, _t) {
    var wt, Rt, J = -1, ut = gt[1], bt = 0, yt = 7, Lt = 4;
    for (ut === 0 && (yt = 138, Lt = 3), gt[2 * (_t + 1) + 1] = 65535, wt = 0; wt <= _t; wt++) Rt = ut, ut = gt[2 * (wt + 1) + 1], ++bt < yt && Rt === ut || (bt < Lt ? mt.bl_tree[2 * Rt] += bt : Rt !== 0 ? (Rt !== J && mt.bl_tree[2 * Rt]++, mt.bl_tree[2 * W]++) : bt <= 10 ? mt.bl_tree[2 * q]++ : mt.bl_tree[2 * et]++, bt = 0, J = Rt, ut === 0 ? (yt = 138, Lt = 3) : Rt === ut ? (yt = 6, Lt = 3) : (yt = 7, Lt = 4));
  }
  function Mt(mt, gt, _t) {
    var wt, Rt, J = -1, ut = gt[1], bt = 0, yt = 7, Lt = 4;
    for (ut === 0 && (yt = 138, Lt = 3), wt = 0; wt <= _t; wt++) if (Rt = ut, ut = gt[2 * (wt + 1) + 1], !(++bt < yt && Rt === ut)) {
      if (bt < Lt) do
        Ft(mt, Rt, mt.bl_tree);
      while (--bt != 0);
      else Rt !== 0 ? (Rt !== J && (Ft(mt, Rt, mt.bl_tree), bt--), Ft(mt, W, mt.bl_tree), At(mt, bt - 3, 2)) : bt <= 10 ? (Ft(mt, q, mt.bl_tree), At(mt, bt - 3, 3)) : (Ft(mt, et, mt.bl_tree), At(mt, bt - 11, 7));
      bt = 0, J = Rt, ut === 0 ? (yt = 138, Lt = 3) : Rt === ut ? (yt = 6, Lt = 3) : (yt = 7, Lt = 4);
    }
  }
  w(dt);
  var nt = !1;
  function It(mt, gt, _t, wt) {
    At(mt, (I << 1) + (wt ? 1 : 0), 3), function(Rt, J, ut, bt) {
      Bt(Rt), St(Rt, ut), St(Rt, ~ut), d.arraySet(Rt.pending_buf, Rt.window, J, ut, Rt.pending), Rt.pending += ut;
    }(mt, gt, _t);
  }
  return trees._tr_init = function(mt) {
    nt || (function() {
      var gt, _t, wt, Rt, J, ut = new Array(j + 1);
      for (wt = 0, Rt = 0; Rt < P - 1; Rt++) for (ct[Rt] = wt, gt = 0; gt < 1 << rt[Rt]; gt++) at[wt++] = Rt;
      for (at[wt - 1] = Rt, J = 0, Rt = 0; Rt < 16; Rt++) for (dt[Rt] = J, gt = 0; gt < 1 << tt[Rt]; gt++) st[J++] = Rt;
      for (J >>= 7; Rt < U; Rt++) for (dt[Rt] = J << 7, gt = 0; gt < 1 << tt[Rt] - 7; gt++) st[256 + J++] = Rt;
      for (_t = 0; _t <= j; _t++) ut[_t] = 0;
      for (gt = 0; gt <= 143; ) ot[2 * gt + 1] = 8, gt++, ut[8]++;
      for (; gt <= 255; ) ot[2 * gt + 1] = 9, gt++, ut[9]++;
      for (; gt <= 279; ) ot[2 * gt + 1] = 7, gt++, ut[7]++;
      for (; gt <= 287; ) ot[2 * gt + 1] = 8, gt++, ut[8]++;
      for (Pt(ot, D + 1, ut), gt = 0; gt < U; gt++) it[2 * gt + 1] = 5, it[2 * gt] = xt(gt, 5);
      K = new ht(ot, rt, F + 1, D, j), lt = new ht(it, tt, 0, U, j), vt = new ht(new Array(0), V, 0, Z, Q);
    }(), nt = !0), mt.l_desc = new pt(mt.dyn_ltree, K), mt.d_desc = new pt(mt.dyn_dtree, lt), mt.bl_desc = new pt(mt.bl_tree, vt), mt.bi_buf = 0, mt.bi_valid = 0, Ot(mt);
  }, trees._tr_stored_block = It, trees._tr_flush_block = function(mt, gt, _t, wt) {
    var Rt, J, ut = 0;
    mt.level > 0 ? (mt.strm.data_type === 2 && (mt.strm.data_type = function(bt) {
      var yt, Lt = 4093624447;
      for (yt = 0; yt <= 31; yt++, Lt >>>= 1) if (1 & Lt && bt.dyn_ltree[2 * yt] !== 0) return m;
      if (bt.dyn_ltree[18] !== 0 || bt.dyn_ltree[20] !== 0 || bt.dyn_ltree[26] !== 0) return g;
      for (yt = 32; yt < F; yt++) if (bt.dyn_ltree[2 * yt] !== 0) return g;
      return m;
    }(mt)), Zt(mt, mt.l_desc), Zt(mt, mt.d_desc), ut = function(bt) {
      var yt;
      for ($t(bt, bt.dyn_ltree, bt.l_desc.max_code), $t(bt, bt.dyn_dtree, bt.d_desc.max_code), Zt(bt, bt.bl_desc), yt = Z - 1; yt >= 3 && bt.bl_tree[2 * X[yt] + 1] === 0; yt--) ;
      return bt.opt_len += 3 * (yt + 1) + 5 + 5 + 4, yt;
    }(mt), Rt = mt.opt_len + 3 + 7 >>> 3, (J = mt.static_len + 3 + 7 >>> 3) <= Rt && (Rt = J)) : Rt = J = _t + 5, _t + 4 <= Rt && gt !== -1 ? It(mt, gt, _t, wt) : mt.strategy === 4 || J === Rt ? (At(mt, 2 + (wt ? 1 : 0), 3), Dt(mt, ot, it)) : (At(mt, 4 + (wt ? 1 : 0), 3), function(bt, yt, Lt, jt) {
      var Kt;
      for (At(bt, yt - 257, 5), At(bt, Lt - 1, 5), At(bt, jt - 4, 4), Kt = 0; Kt < jt; Kt++) At(bt, bt.bl_tree[2 * X[Kt] + 1], 3);
      Mt(bt, bt.dyn_ltree, yt - 1), Mt(bt, bt.dyn_dtree, Lt - 1);
    }(mt, mt.l_desc.max_code + 1, mt.d_desc.max_code + 1, ut + 1), Dt(mt, mt.dyn_ltree, mt.dyn_dtree)), Ot(mt), wt && Bt(mt);
  }, trees._tr_tally = function(mt, gt, _t) {
    return mt.pending_buf[mt.d_buf + 2 * mt.last_lit] = gt >>> 8 & 255, mt.pending_buf[mt.d_buf + 2 * mt.last_lit + 1] = 255 & gt, mt.pending_buf[mt.l_buf + mt.last_lit] = 255 & _t, mt.last_lit++, gt === 0 ? mt.dyn_ltree[2 * _t]++ : (mt.matches++, gt--, mt.dyn_ltree[2 * (at[_t] + F + 1)]++, mt.dyn_dtree[2 * Ct(gt)]++), mt.last_lit === mt.lit_bufsize - 1;
  }, trees._tr_align = function(mt) {
    At(mt, 2, 3), Ft(mt, H, ot), function(gt) {
      gt.bi_valid === 16 ? (St(gt, gt.bi_buf), gt.bi_buf = 0, gt.bi_valid = 0) : gt.bi_valid >= 8 && (gt.pending_buf[gt.pending++] = 255 & gt.bi_buf, gt.bi_buf >>= 8, gt.bi_valid -= 8);
    }(mt);
  }, trees;
}
function requireAdler32() {
  return hasRequiredAdler32 || (hasRequiredAdler32 = 1, adler32_1 = function(d, m, g, w) {
    for (var I = 65535 & d, P = d >>> 16 & 65535, F = 0; g !== 0; ) {
      g -= F = g > 2e3 ? 2e3 : g;
      do
        P = P + (I = I + m[w++] | 0) | 0;
      while (--F);
      I %= 65521, P %= 65521;
    }
    return I | P << 16;
  }), adler32_1;
}
function requireCrc32() {
  if (hasRequiredCrc32) return crc32_1;
  hasRequiredCrc32 = 1;
  var d = function() {
    for (var m, g = [], w = 0; w < 256; w++) {
      m = w;
      for (var I = 0; I < 8; I++) m = 1 & m ? 3988292384 ^ m >>> 1 : m >>> 1;
      g[w] = m;
    }
    return g;
  }();
  return crc32_1 = function(m, g, w, I) {
    var P = d, F = I + w;
    m ^= -1;
    for (var D = I; D < F; D++) m = m >>> 8 ^ P[255 & (m ^ g[D])];
    return ~m;
  }, crc32_1;
}
function requireMessages() {
  return hasRequiredMessages ? messages : (hasRequiredMessages = 1, messages = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" });
}
function requireDeflate$1() {
  if (hasRequiredDeflate$1) return deflate;
  hasRequiredDeflate$1 = 1;
  var d, m = requireCommon(), g = requireTrees(), w = requireAdler32(), I = requireCrc32(), P = requireMessages(), F = 0, D = 4, U = 0, Z = -2, $ = -1, j = 4, G = 2, Q = 8, H = 9, W = 286, q = 30, et = 19, rt = 2 * W + 1, tt = 15, V = 3, X = 258, ot = X + V + 1, it = 42, st = 103, at = 113, ct = 666, K = 1, lt = 2, vt = 3, dt = 4;
  function ht(nt, It) {
    return nt.msg = P[It], It;
  }
  function pt(nt) {
    return (nt << 1) - (nt > 4 ? 9 : 0);
  }
  function Ct(nt) {
    for (var It = nt.length; --It >= 0; ) nt[It] = 0;
  }
  function St(nt) {
    var It = nt.state, mt = It.pending;
    mt > nt.avail_out && (mt = nt.avail_out), mt !== 0 && (m.arraySet(nt.output, It.pending_buf, It.pending_out, mt, nt.next_out), nt.next_out += mt, It.pending_out += mt, nt.total_out += mt, nt.avail_out -= mt, It.pending -= mt, It.pending === 0 && (It.pending_out = 0));
  }
  function At(nt, It) {
    g._tr_flush_block(nt, nt.block_start >= 0 ? nt.block_start : -1, nt.strstart - nt.block_start, It), nt.block_start = nt.strstart, St(nt.strm);
  }
  function Ft(nt, It) {
    nt.pending_buf[nt.pending++] = It;
  }
  function xt(nt, It) {
    nt.pending_buf[nt.pending++] = It >>> 8 & 255, nt.pending_buf[nt.pending++] = 255 & It;
  }
  function Pt(nt, It) {
    var mt, gt, _t = nt.max_chain_length, wt = nt.strstart, Rt = nt.prev_length, J = nt.nice_match, ut = nt.strstart > nt.w_size - ot ? nt.strstart - (nt.w_size - ot) : 0, bt = nt.window, yt = nt.w_mask, Lt = nt.prev, jt = nt.strstart + X, Kt = bt[wt + Rt - 1], te = bt[wt + Rt];
    nt.prev_length >= nt.good_match && (_t >>= 2), J > nt.lookahead && (J = nt.lookahead);
    do
      if (bt[(mt = It) + Rt] === te && bt[mt + Rt - 1] === Kt && bt[mt] === bt[wt] && bt[++mt] === bt[wt + 1]) {
        wt += 2, mt++;
        do
          ;
        while (bt[++wt] === bt[++mt] && bt[++wt] === bt[++mt] && bt[++wt] === bt[++mt] && bt[++wt] === bt[++mt] && bt[++wt] === bt[++mt] && bt[++wt] === bt[++mt] && bt[++wt] === bt[++mt] && bt[++wt] === bt[++mt] && wt < jt);
        if (gt = X - (jt - wt), wt = jt - X, gt > Rt) {
          if (nt.match_start = It, Rt = gt, gt >= J) break;
          Kt = bt[wt + Rt - 1], te = bt[wt + Rt];
        }
      }
    while ((It = Lt[It & yt]) > ut && --_t != 0);
    return Rt <= nt.lookahead ? Rt : nt.lookahead;
  }
  function Ot(nt) {
    var It, mt, gt, _t, wt, Rt, J, ut, bt, yt, Lt = nt.w_size;
    do {
      if (_t = nt.window_size - nt.lookahead - nt.strstart, nt.strstart >= Lt + (Lt - ot)) {
        m.arraySet(nt.window, nt.window, Lt, Lt, 0), nt.match_start -= Lt, nt.strstart -= Lt, nt.block_start -= Lt, It = mt = nt.hash_size;
        do
          gt = nt.head[--It], nt.head[It] = gt >= Lt ? gt - Lt : 0;
        while (--mt);
        It = mt = Lt;
        do
          gt = nt.prev[--It], nt.prev[It] = gt >= Lt ? gt - Lt : 0;
        while (--mt);
        _t += Lt;
      }
      if (nt.strm.avail_in === 0) break;
      if (Rt = nt.strm, J = nt.window, ut = nt.strstart + nt.lookahead, bt = _t, yt = void 0, (yt = Rt.avail_in) > bt && (yt = bt), mt = yt === 0 ? 0 : (Rt.avail_in -= yt, m.arraySet(J, Rt.input, Rt.next_in, yt, ut), Rt.state.wrap === 1 ? Rt.adler = w(Rt.adler, J, yt, ut) : Rt.state.wrap === 2 && (Rt.adler = I(Rt.adler, J, yt, ut)), Rt.next_in += yt, Rt.total_in += yt, yt), nt.lookahead += mt, nt.lookahead + nt.insert >= V) for (wt = nt.strstart - nt.insert, nt.ins_h = nt.window[wt], nt.ins_h = (nt.ins_h << nt.hash_shift ^ nt.window[wt + 1]) & nt.hash_mask; nt.insert && (nt.ins_h = (nt.ins_h << nt.hash_shift ^ nt.window[wt + V - 1]) & nt.hash_mask, nt.prev[wt & nt.w_mask] = nt.head[nt.ins_h], nt.head[nt.ins_h] = wt, wt++, nt.insert--, !(nt.lookahead + nt.insert < V)); ) ;
    } while (nt.lookahead < ot && nt.strm.avail_in !== 0);
  }
  function Bt(nt, It) {
    for (var mt, gt; ; ) {
      if (nt.lookahead < ot) {
        if (Ot(nt), nt.lookahead < ot && It === F) return K;
        if (nt.lookahead === 0) break;
      }
      if (mt = 0, nt.lookahead >= V && (nt.ins_h = (nt.ins_h << nt.hash_shift ^ nt.window[nt.strstart + V - 1]) & nt.hash_mask, mt = nt.prev[nt.strstart & nt.w_mask] = nt.head[nt.ins_h], nt.head[nt.ins_h] = nt.strstart), mt !== 0 && nt.strstart - mt <= nt.w_size - ot && (nt.match_length = Pt(nt, mt)), nt.match_length >= V) if (gt = g._tr_tally(nt, nt.strstart - nt.match_start, nt.match_length - V), nt.lookahead -= nt.match_length, nt.match_length <= nt.max_lazy_match && nt.lookahead >= V) {
        nt.match_length--;
        do
          nt.strstart++, nt.ins_h = (nt.ins_h << nt.hash_shift ^ nt.window[nt.strstart + V - 1]) & nt.hash_mask, mt = nt.prev[nt.strstart & nt.w_mask] = nt.head[nt.ins_h], nt.head[nt.ins_h] = nt.strstart;
        while (--nt.match_length != 0);
        nt.strstart++;
      } else nt.strstart += nt.match_length, nt.match_length = 0, nt.ins_h = nt.window[nt.strstart], nt.ins_h = (nt.ins_h << nt.hash_shift ^ nt.window[nt.strstart + 1]) & nt.hash_mask;
      else gt = g._tr_tally(nt, 0, nt.window[nt.strstart]), nt.lookahead--, nt.strstart++;
      if (gt && (At(nt, !1), nt.strm.avail_out === 0)) return K;
    }
    return nt.insert = nt.strstart < V - 1 ? nt.strstart : V - 1, It === D ? (At(nt, !0), nt.strm.avail_out === 0 ? vt : dt) : nt.last_lit && (At(nt, !1), nt.strm.avail_out === 0) ? K : lt;
  }
  function kt(nt, It) {
    for (var mt, gt, _t; ; ) {
      if (nt.lookahead < ot) {
        if (Ot(nt), nt.lookahead < ot && It === F) return K;
        if (nt.lookahead === 0) break;
      }
      if (mt = 0, nt.lookahead >= V && (nt.ins_h = (nt.ins_h << nt.hash_shift ^ nt.window[nt.strstart + V - 1]) & nt.hash_mask, mt = nt.prev[nt.strstart & nt.w_mask] = nt.head[nt.ins_h], nt.head[nt.ins_h] = nt.strstart), nt.prev_length = nt.match_length, nt.prev_match = nt.match_start, nt.match_length = V - 1, mt !== 0 && nt.prev_length < nt.max_lazy_match && nt.strstart - mt <= nt.w_size - ot && (nt.match_length = Pt(nt, mt), nt.match_length <= 5 && (nt.strategy === 1 || nt.match_length === V && nt.strstart - nt.match_start > 4096) && (nt.match_length = V - 1)), nt.prev_length >= V && nt.match_length <= nt.prev_length) {
        _t = nt.strstart + nt.lookahead - V, gt = g._tr_tally(nt, nt.strstart - 1 - nt.prev_match, nt.prev_length - V), nt.lookahead -= nt.prev_length - 1, nt.prev_length -= 2;
        do
          ++nt.strstart <= _t && (nt.ins_h = (nt.ins_h << nt.hash_shift ^ nt.window[nt.strstart + V - 1]) & nt.hash_mask, mt = nt.prev[nt.strstart & nt.w_mask] = nt.head[nt.ins_h], nt.head[nt.ins_h] = nt.strstart);
        while (--nt.prev_length != 0);
        if (nt.match_available = 0, nt.match_length = V - 1, nt.strstart++, gt && (At(nt, !1), nt.strm.avail_out === 0)) return K;
      } else if (nt.match_available) {
        if ((gt = g._tr_tally(nt, 0, nt.window[nt.strstart - 1])) && At(nt, !1), nt.strstart++, nt.lookahead--, nt.strm.avail_out === 0) return K;
      } else nt.match_available = 1, nt.strstart++, nt.lookahead--;
    }
    return nt.match_available && (gt = g._tr_tally(nt, 0, nt.window[nt.strstart - 1]), nt.match_available = 0), nt.insert = nt.strstart < V - 1 ? nt.strstart : V - 1, It === D ? (At(nt, !0), nt.strm.avail_out === 0 ? vt : dt) : nt.last_lit && (At(nt, !1), nt.strm.avail_out === 0) ? K : lt;
  }
  function Tt(nt, It, mt, gt, _t) {
    this.good_length = nt, this.max_lazy = It, this.nice_length = mt, this.max_chain = gt, this.func = _t;
  }
  function Dt() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Q, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new m.Buf16(2 * rt), this.dyn_dtree = new m.Buf16(2 * (2 * q + 1)), this.bl_tree = new m.Buf16(2 * (2 * et + 1)), Ct(this.dyn_ltree), Ct(this.dyn_dtree), Ct(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new m.Buf16(tt + 1), this.heap = new m.Buf16(2 * W + 1), Ct(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new m.Buf16(2 * W + 1), Ct(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
  }
  function Zt(nt) {
    var It;
    return nt && nt.state ? (nt.total_in = nt.total_out = 0, nt.data_type = G, (It = nt.state).pending = 0, It.pending_out = 0, It.wrap < 0 && (It.wrap = -It.wrap), It.status = It.wrap ? it : at, nt.adler = It.wrap === 2 ? 0 : 1, It.last_flush = F, g._tr_init(It), U) : ht(nt, Z);
  }
  function $t(nt) {
    var It = Zt(nt);
    return It === U && function(mt) {
      mt.window_size = 2 * mt.w_size, Ct(mt.head), mt.max_lazy_match = d[mt.level].max_lazy, mt.good_match = d[mt.level].good_length, mt.nice_match = d[mt.level].nice_length, mt.max_chain_length = d[mt.level].max_chain, mt.strstart = 0, mt.block_start = 0, mt.lookahead = 0, mt.insert = 0, mt.match_length = mt.prev_length = V - 1, mt.match_available = 0, mt.ins_h = 0;
    }(nt.state), It;
  }
  function Mt(nt, It, mt, gt, _t, wt) {
    if (!nt) return Z;
    var Rt = 1;
    if (It === $ && (It = 6), gt < 0 ? (Rt = 0, gt = -gt) : gt > 15 && (Rt = 2, gt -= 16), _t < 1 || _t > H || mt !== Q || gt < 8 || gt > 15 || It < 0 || It > 9 || wt < 0 || wt > j) return ht(nt, Z);
    gt === 8 && (gt = 9);
    var J = new Dt();
    return nt.state = J, J.strm = nt, J.wrap = Rt, J.gzhead = null, J.w_bits = gt, J.w_size = 1 << J.w_bits, J.w_mask = J.w_size - 1, J.hash_bits = _t + 7, J.hash_size = 1 << J.hash_bits, J.hash_mask = J.hash_size - 1, J.hash_shift = ~~((J.hash_bits + V - 1) / V), J.window = new m.Buf8(2 * J.w_size), J.head = new m.Buf16(J.hash_size), J.prev = new m.Buf16(J.w_size), J.lit_bufsize = 1 << _t + 6, J.pending_buf_size = 4 * J.lit_bufsize, J.pending_buf = new m.Buf8(J.pending_buf_size), J.d_buf = 1 * J.lit_bufsize, J.l_buf = 3 * J.lit_bufsize, J.level = It, J.strategy = wt, J.method = mt, $t(nt);
  }
  return d = [new Tt(0, 0, 0, 0, function(nt, It) {
    var mt = 65535;
    for (mt > nt.pending_buf_size - 5 && (mt = nt.pending_buf_size - 5); ; ) {
      if (nt.lookahead <= 1) {
        if (Ot(nt), nt.lookahead === 0 && It === F) return K;
        if (nt.lookahead === 0) break;
      }
      nt.strstart += nt.lookahead, nt.lookahead = 0;
      var gt = nt.block_start + mt;
      if ((nt.strstart === 0 || nt.strstart >= gt) && (nt.lookahead = nt.strstart - gt, nt.strstart = gt, At(nt, !1), nt.strm.avail_out === 0) || nt.strstart - nt.block_start >= nt.w_size - ot && (At(nt, !1), nt.strm.avail_out === 0)) return K;
    }
    return nt.insert = 0, It === D ? (At(nt, !0), nt.strm.avail_out === 0 ? vt : dt) : (nt.strstart > nt.block_start && (At(nt, !1), nt.strm.avail_out), K);
  }), new Tt(4, 4, 8, 4, Bt), new Tt(4, 5, 16, 8, Bt), new Tt(4, 6, 32, 32, Bt), new Tt(4, 4, 16, 16, kt), new Tt(8, 16, 32, 32, kt), new Tt(8, 16, 128, 128, kt), new Tt(8, 32, 128, 256, kt), new Tt(32, 128, 258, 1024, kt), new Tt(32, 258, 258, 4096, kt)], deflate.deflateInit = function(nt, It) {
    return Mt(nt, It, Q, 15, 8, 0);
  }, deflate.deflateInit2 = Mt, deflate.deflateReset = $t, deflate.deflateResetKeep = Zt, deflate.deflateSetHeader = function(nt, It) {
    return nt && nt.state ? nt.state.wrap !== 2 ? Z : (nt.state.gzhead = It, U) : Z;
  }, deflate.deflate = function(nt, It) {
    var mt, gt, _t, wt;
    if (!nt || !nt.state || It > 5 || It < 0) return nt ? ht(nt, Z) : Z;
    if (gt = nt.state, !nt.output || !nt.input && nt.avail_in !== 0 || gt.status === ct && It !== D) return ht(nt, nt.avail_out === 0 ? -5 : Z);
    if (gt.strm = nt, mt = gt.last_flush, gt.last_flush = It, gt.status === it) if (gt.wrap === 2) nt.adler = 0, Ft(gt, 31), Ft(gt, 139), Ft(gt, 8), gt.gzhead ? (Ft(gt, (gt.gzhead.text ? 1 : 0) + (gt.gzhead.hcrc ? 2 : 0) + (gt.gzhead.extra ? 4 : 0) + (gt.gzhead.name ? 8 : 0) + (gt.gzhead.comment ? 16 : 0)), Ft(gt, 255 & gt.gzhead.time), Ft(gt, gt.gzhead.time >> 8 & 255), Ft(gt, gt.gzhead.time >> 16 & 255), Ft(gt, gt.gzhead.time >> 24 & 255), Ft(gt, gt.level === 9 ? 2 : gt.strategy >= 2 || gt.level < 2 ? 4 : 0), Ft(gt, 255 & gt.gzhead.os), gt.gzhead.extra && gt.gzhead.extra.length && (Ft(gt, 255 & gt.gzhead.extra.length), Ft(gt, gt.gzhead.extra.length >> 8 & 255)), gt.gzhead.hcrc && (nt.adler = I(nt.adler, gt.pending_buf, gt.pending, 0)), gt.gzindex = 0, gt.status = 69) : (Ft(gt, 0), Ft(gt, 0), Ft(gt, 0), Ft(gt, 0), Ft(gt, 0), Ft(gt, gt.level === 9 ? 2 : gt.strategy >= 2 || gt.level < 2 ? 4 : 0), Ft(gt, 3), gt.status = at);
    else {
      var Rt = Q + (gt.w_bits - 8 << 4) << 8;
      Rt |= (gt.strategy >= 2 || gt.level < 2 ? 0 : gt.level < 6 ? 1 : gt.level === 6 ? 2 : 3) << 6, gt.strstart !== 0 && (Rt |= 32), Rt += 31 - Rt % 31, gt.status = at, xt(gt, Rt), gt.strstart !== 0 && (xt(gt, nt.adler >>> 16), xt(gt, 65535 & nt.adler)), nt.adler = 1;
    }
    if (gt.status === 69) if (gt.gzhead.extra) {
      for (_t = gt.pending; gt.gzindex < (65535 & gt.gzhead.extra.length) && (gt.pending !== gt.pending_buf_size || (gt.gzhead.hcrc && gt.pending > _t && (nt.adler = I(nt.adler, gt.pending_buf, gt.pending - _t, _t)), St(nt), _t = gt.pending, gt.pending !== gt.pending_buf_size)); ) Ft(gt, 255 & gt.gzhead.extra[gt.gzindex]), gt.gzindex++;
      gt.gzhead.hcrc && gt.pending > _t && (nt.adler = I(nt.adler, gt.pending_buf, gt.pending - _t, _t)), gt.gzindex === gt.gzhead.extra.length && (gt.gzindex = 0, gt.status = 73);
    } else gt.status = 73;
    if (gt.status === 73) if (gt.gzhead.name) {
      _t = gt.pending;
      do {
        if (gt.pending === gt.pending_buf_size && (gt.gzhead.hcrc && gt.pending > _t && (nt.adler = I(nt.adler, gt.pending_buf, gt.pending - _t, _t)), St(nt), _t = gt.pending, gt.pending === gt.pending_buf_size)) {
          wt = 1;
          break;
        }
        wt = gt.gzindex < gt.gzhead.name.length ? 255 & gt.gzhead.name.charCodeAt(gt.gzindex++) : 0, Ft(gt, wt);
      } while (wt !== 0);
      gt.gzhead.hcrc && gt.pending > _t && (nt.adler = I(nt.adler, gt.pending_buf, gt.pending - _t, _t)), wt === 0 && (gt.gzindex = 0, gt.status = 91);
    } else gt.status = 91;
    if (gt.status === 91) if (gt.gzhead.comment) {
      _t = gt.pending;
      do {
        if (gt.pending === gt.pending_buf_size && (gt.gzhead.hcrc && gt.pending > _t && (nt.adler = I(nt.adler, gt.pending_buf, gt.pending - _t, _t)), St(nt), _t = gt.pending, gt.pending === gt.pending_buf_size)) {
          wt = 1;
          break;
        }
        wt = gt.gzindex < gt.gzhead.comment.length ? 255 & gt.gzhead.comment.charCodeAt(gt.gzindex++) : 0, Ft(gt, wt);
      } while (wt !== 0);
      gt.gzhead.hcrc && gt.pending > _t && (nt.adler = I(nt.adler, gt.pending_buf, gt.pending - _t, _t)), wt === 0 && (gt.status = st);
    } else gt.status = st;
    if (gt.status === st && (gt.gzhead.hcrc ? (gt.pending + 2 > gt.pending_buf_size && St(nt), gt.pending + 2 <= gt.pending_buf_size && (Ft(gt, 255 & nt.adler), Ft(gt, nt.adler >> 8 & 255), nt.adler = 0, gt.status = at)) : gt.status = at), gt.pending !== 0) {
      if (St(nt), nt.avail_out === 0) return gt.last_flush = -1, U;
    } else if (nt.avail_in === 0 && pt(It) <= pt(mt) && It !== D) return ht(nt, -5);
    if (gt.status === ct && nt.avail_in !== 0) return ht(nt, -5);
    if (nt.avail_in !== 0 || gt.lookahead !== 0 || It !== F && gt.status !== ct) {
      var J = gt.strategy === 2 ? function(ut, bt) {
        for (var yt; ; ) {
          if (ut.lookahead === 0 && (Ot(ut), ut.lookahead === 0)) {
            if (bt === F) return K;
            break;
          }
          if (ut.match_length = 0, yt = g._tr_tally(ut, 0, ut.window[ut.strstart]), ut.lookahead--, ut.strstart++, yt && (At(ut, !1), ut.strm.avail_out === 0)) return K;
        }
        return ut.insert = 0, bt === D ? (At(ut, !0), ut.strm.avail_out === 0 ? vt : dt) : ut.last_lit && (At(ut, !1), ut.strm.avail_out === 0) ? K : lt;
      }(gt, It) : gt.strategy === 3 ? function(ut, bt) {
        for (var yt, Lt, jt, Kt, te = ut.window; ; ) {
          if (ut.lookahead <= X) {
            if (Ot(ut), ut.lookahead <= X && bt === F) return K;
            if (ut.lookahead === 0) break;
          }
          if (ut.match_length = 0, ut.lookahead >= V && ut.strstart > 0 && (Lt = te[jt = ut.strstart - 1]) === te[++jt] && Lt === te[++jt] && Lt === te[++jt]) {
            Kt = ut.strstart + X;
            do
              ;
            while (Lt === te[++jt] && Lt === te[++jt] && Lt === te[++jt] && Lt === te[++jt] && Lt === te[++jt] && Lt === te[++jt] && Lt === te[++jt] && Lt === te[++jt] && jt < Kt);
            ut.match_length = X - (Kt - jt), ut.match_length > ut.lookahead && (ut.match_length = ut.lookahead);
          }
          if (ut.match_length >= V ? (yt = g._tr_tally(ut, 1, ut.match_length - V), ut.lookahead -= ut.match_length, ut.strstart += ut.match_length, ut.match_length = 0) : (yt = g._tr_tally(ut, 0, ut.window[ut.strstart]), ut.lookahead--, ut.strstart++), yt && (At(ut, !1), ut.strm.avail_out === 0)) return K;
        }
        return ut.insert = 0, bt === D ? (At(ut, !0), ut.strm.avail_out === 0 ? vt : dt) : ut.last_lit && (At(ut, !1), ut.strm.avail_out === 0) ? K : lt;
      }(gt, It) : d[gt.level].func(gt, It);
      if (J !== vt && J !== dt || (gt.status = ct), J === K || J === vt) return nt.avail_out === 0 && (gt.last_flush = -1), U;
      if (J === lt && (It === 1 ? g._tr_align(gt) : It !== 5 && (g._tr_stored_block(gt, 0, 0, !1), It === 3 && (Ct(gt.head), gt.lookahead === 0 && (gt.strstart = 0, gt.block_start = 0, gt.insert = 0))), St(nt), nt.avail_out === 0)) return gt.last_flush = -1, U;
    }
    return It !== D ? U : gt.wrap <= 0 ? 1 : (gt.wrap === 2 ? (Ft(gt, 255 & nt.adler), Ft(gt, nt.adler >> 8 & 255), Ft(gt, nt.adler >> 16 & 255), Ft(gt, nt.adler >> 24 & 255), Ft(gt, 255 & nt.total_in), Ft(gt, nt.total_in >> 8 & 255), Ft(gt, nt.total_in >> 16 & 255), Ft(gt, nt.total_in >> 24 & 255)) : (xt(gt, nt.adler >>> 16), xt(gt, 65535 & nt.adler)), St(nt), gt.wrap > 0 && (gt.wrap = -gt.wrap), gt.pending !== 0 ? U : 1);
  }, deflate.deflateEnd = function(nt) {
    var It;
    return nt && nt.state ? (It = nt.state.status) !== it && It !== 69 && It !== 73 && It !== 91 && It !== st && It !== at && It !== ct ? ht(nt, Z) : (nt.state = null, It === at ? ht(nt, -3) : U) : Z;
  }, deflate.deflateSetDictionary = function(nt, It) {
    var mt, gt, _t, wt, Rt, J, ut, bt, yt = It.length;
    if (!nt || !nt.state || (wt = (mt = nt.state).wrap) === 2 || wt === 1 && mt.status !== it || mt.lookahead) return Z;
    for (wt === 1 && (nt.adler = w(nt.adler, It, yt, 0)), mt.wrap = 0, yt >= mt.w_size && (wt === 0 && (Ct(mt.head), mt.strstart = 0, mt.block_start = 0, mt.insert = 0), bt = new m.Buf8(mt.w_size), m.arraySet(bt, It, yt - mt.w_size, mt.w_size, 0), It = bt, yt = mt.w_size), Rt = nt.avail_in, J = nt.next_in, ut = nt.input, nt.avail_in = yt, nt.next_in = 0, nt.input = It, Ot(mt); mt.lookahead >= V; ) {
      gt = mt.strstart, _t = mt.lookahead - (V - 1);
      do
        mt.ins_h = (mt.ins_h << mt.hash_shift ^ mt.window[gt + V - 1]) & mt.hash_mask, mt.prev[gt & mt.w_mask] = mt.head[mt.ins_h], mt.head[mt.ins_h] = gt, gt++;
      while (--_t);
      mt.strstart = gt, mt.lookahead = V - 1, Ot(mt);
    }
    return mt.strstart += mt.lookahead, mt.block_start = mt.strstart, mt.insert = mt.lookahead, mt.lookahead = 0, mt.match_length = mt.prev_length = V - 1, mt.match_available = 0, nt.next_in = J, nt.input = ut, nt.avail_in = Rt, mt.wrap = wt, U;
  }, deflate.deflateInfo = "pako deflate (from Nodeca project)", deflate;
}
var strings = {}, hasRequiredStrings, zstream, hasRequiredZstream, hasRequiredDeflate;
function requireStrings() {
  if (hasRequiredStrings) return strings;
  hasRequiredStrings = 1;
  var d = requireCommon(), m = !0, g = !0;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch {
    m = !1;
  }
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch {
    g = !1;
  }
  for (var w = new d.Buf8(256), I = 0; I < 256; I++) w[I] = I >= 252 ? 6 : I >= 248 ? 5 : I >= 240 ? 4 : I >= 224 ? 3 : I >= 192 ? 2 : 1;
  function P(F, D) {
    if (D < 65534 && (F.subarray && g || !F.subarray && m)) return String.fromCharCode.apply(null, d.shrinkBuf(F, D));
    for (var U = "", Z = 0; Z < D; Z++) U += String.fromCharCode(F[Z]);
    return U;
  }
  return w[254] = w[254] = 1, strings.string2buf = function(F) {
    var D, U, Z, $, j, G = F.length, Q = 0;
    for ($ = 0; $ < G; $++) (64512 & (U = F.charCodeAt($))) == 55296 && $ + 1 < G && (64512 & (Z = F.charCodeAt($ + 1))) == 56320 && (U = 65536 + (U - 55296 << 10) + (Z - 56320), $++), Q += U < 128 ? 1 : U < 2048 ? 2 : U < 65536 ? 3 : 4;
    for (D = new d.Buf8(Q), j = 0, $ = 0; j < Q; $++) (64512 & (U = F.charCodeAt($))) == 55296 && $ + 1 < G && (64512 & (Z = F.charCodeAt($ + 1))) == 56320 && (U = 65536 + (U - 55296 << 10) + (Z - 56320), $++), U < 128 ? D[j++] = U : U < 2048 ? (D[j++] = 192 | U >>> 6, D[j++] = 128 | 63 & U) : U < 65536 ? (D[j++] = 224 | U >>> 12, D[j++] = 128 | U >>> 6 & 63, D[j++] = 128 | 63 & U) : (D[j++] = 240 | U >>> 18, D[j++] = 128 | U >>> 12 & 63, D[j++] = 128 | U >>> 6 & 63, D[j++] = 128 | 63 & U);
    return D;
  }, strings.buf2binstring = function(F) {
    return P(F, F.length);
  }, strings.binstring2buf = function(F) {
    for (var D = new d.Buf8(F.length), U = 0, Z = D.length; U < Z; U++) D[U] = F.charCodeAt(U);
    return D;
  }, strings.buf2string = function(F, D) {
    var U, Z, $, j, G = D || F.length, Q = new Array(2 * G);
    for (Z = 0, U = 0; U < G; ) if (($ = F[U++]) < 128) Q[Z++] = $;
    else if ((j = w[$]) > 4) Q[Z++] = 65533, U += j - 1;
    else {
      for ($ &= j === 2 ? 31 : j === 3 ? 15 : 7; j > 1 && U < G; ) $ = $ << 6 | 63 & F[U++], j--;
      j > 1 ? Q[Z++] = 65533 : $ < 65536 ? Q[Z++] = $ : ($ -= 65536, Q[Z++] = 55296 | $ >> 10 & 1023, Q[Z++] = 56320 | 1023 & $);
    }
    return P(Q, Z);
  }, strings.utf8border = function(F, D) {
    var U;
    for ((D = D || F.length) > F.length && (D = F.length), U = D - 1; U >= 0 && (192 & F[U]) == 128; ) U--;
    return U < 0 || U === 0 ? D : U + w[F[U]] > D ? U : D;
  }, strings;
}
function requireZstream() {
  return hasRequiredZstream ? zstream : (hasRequiredZstream = 1, zstream = function() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
  });
}
function requireDeflate() {
  if (hasRequiredDeflate) return deflate$1;
  hasRequiredDeflate = 1;
  var d = requireDeflate$1(), m = requireCommon(), g = requireStrings(), w = requireMessages(), I = requireZstream(), P = Object.prototype.toString, F = 0, D = -1, U = 0, Z = 8;
  function $(G) {
    if (!(this instanceof $)) return new $(G);
    this.options = m.assign({ level: D, method: Z, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: U, to: "" }, G || {});
    var Q = this.options;
    Q.raw && Q.windowBits > 0 ? Q.windowBits = -Q.windowBits : Q.gzip && Q.windowBits > 0 && Q.windowBits < 16 && (Q.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new I(), this.strm.avail_out = 0;
    var H = d.deflateInit2(this.strm, Q.level, Q.method, Q.windowBits, Q.memLevel, Q.strategy);
    if (H !== F) throw new Error(w[H]);
    if (Q.header && d.deflateSetHeader(this.strm, Q.header), Q.dictionary) {
      var W;
      if (W = typeof Q.dictionary == "string" ? g.string2buf(Q.dictionary) : P.call(Q.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(Q.dictionary) : Q.dictionary, (H = d.deflateSetDictionary(this.strm, W)) !== F) throw new Error(w[H]);
      this._dict_set = !0;
    }
  }
  function j(G, Q) {
    var H = new $(Q);
    if (H.push(G, !0), H.err) throw H.msg || w[H.err];
    return H.result;
  }
  return $.prototype.push = function(G, Q) {
    var H, W, q = this.strm, et = this.options.chunkSize;
    if (this.ended) return !1;
    W = Q === ~~Q ? Q : Q === !0 ? 4 : 0, typeof G == "string" ? q.input = g.string2buf(G) : P.call(G) === "[object ArrayBuffer]" ? q.input = new Uint8Array(G) : q.input = G, q.next_in = 0, q.avail_in = q.input.length;
    do {
      if (q.avail_out === 0 && (q.output = new m.Buf8(et), q.next_out = 0, q.avail_out = et), (H = d.deflate(q, W)) !== 1 && H !== F) return this.onEnd(H), this.ended = !0, !1;
      q.avail_out !== 0 && (q.avail_in !== 0 || W !== 4 && W !== 2) || (this.options.to === "string" ? this.onData(g.buf2binstring(m.shrinkBuf(q.output, q.next_out))) : this.onData(m.shrinkBuf(q.output, q.next_out)));
    } while ((q.avail_in > 0 || q.avail_out === 0) && H !== 1);
    return W === 4 ? (H = d.deflateEnd(this.strm), this.onEnd(H), this.ended = !0, H === F) : W !== 2 || (this.onEnd(F), q.avail_out = 0, !0);
  }, $.prototype.onData = function(G) {
    this.chunks.push(G);
  }, $.prototype.onEnd = function(G) {
    G === F && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = m.flattenChunks(this.chunks)), this.chunks = [], this.err = G, this.msg = this.strm.msg;
  }, deflate$1.Deflate = $, deflate$1.deflate = j, deflate$1.deflateRaw = function(G, Q) {
    return (Q = Q || {}).raw = !0, j(G, Q);
  }, deflate$1.gzip = function(G, Q) {
    return (Q = Q || {}).gzip = !0, j(G, Q);
  }, deflate$1;
}
var inflate$1 = {}, inflate = {}, inffast, hasRequiredInffast, inftrees, hasRequiredInftrees, hasRequiredInflate$1, constants, hasRequiredConstants, gzheader, hasRequiredGzheader, hasRequiredInflate, pako_1, hasRequiredPako;
function requireInffast() {
  return hasRequiredInffast ? inffast : (hasRequiredInffast = 1, inffast = function(d, m) {
    var g, w, I, P, F, D, U, Z, $, j, G, Q, H, W, q, et, rt, tt, V, X, ot, it, st, at, ct;
    g = d.state, w = d.next_in, at = d.input, I = w + (d.avail_in - 5), P = d.next_out, ct = d.output, F = P - (m - d.avail_out), D = P + (d.avail_out - 257), U = g.dmax, Z = g.wsize, $ = g.whave, j = g.wnext, G = g.window, Q = g.hold, H = g.bits, W = g.lencode, q = g.distcode, et = (1 << g.lenbits) - 1, rt = (1 << g.distbits) - 1;
    t: do {
      H < 15 && (Q += at[w++] << H, H += 8, Q += at[w++] << H, H += 8), tt = W[Q & et];
      e: for (; ; ) {
        if (Q >>>= V = tt >>> 24, H -= V, (V = tt >>> 16 & 255) === 0) ct[P++] = 65535 & tt;
        else {
          if (!(16 & V)) {
            if (64 & V) {
              if (32 & V) {
                g.mode = 12;
                break t;
              }
              d.msg = "invalid literal/length code", g.mode = 30;
              break t;
            }
            tt = W[(65535 & tt) + (Q & (1 << V) - 1)];
            continue e;
          }
          for (X = 65535 & tt, (V &= 15) && (H < V && (Q += at[w++] << H, H += 8), X += Q & (1 << V) - 1, Q >>>= V, H -= V), H < 15 && (Q += at[w++] << H, H += 8, Q += at[w++] << H, H += 8), tt = q[Q & rt]; ; ) {
            if (Q >>>= V = tt >>> 24, H -= V, 16 & (V = tt >>> 16 & 255)) {
              if (ot = 65535 & tt, H < (V &= 15) && (Q += at[w++] << H, (H += 8) < V && (Q += at[w++] << H, H += 8)), (ot += Q & (1 << V) - 1) > U) {
                d.msg = "invalid distance too far back", g.mode = 30;
                break t;
              }
              if (Q >>>= V, H -= V, ot > (V = P - F)) {
                if ((V = ot - V) > $ && g.sane) {
                  d.msg = "invalid distance too far back", g.mode = 30;
                  break t;
                }
                if (it = 0, st = G, j === 0) {
                  if (it += Z - V, V < X) {
                    X -= V;
                    do
                      ct[P++] = G[it++];
                    while (--V);
                    it = P - ot, st = ct;
                  }
                } else if (j < V) {
                  if (it += Z + j - V, (V -= j) < X) {
                    X -= V;
                    do
                      ct[P++] = G[it++];
                    while (--V);
                    if (it = 0, j < X) {
                      X -= V = j;
                      do
                        ct[P++] = G[it++];
                      while (--V);
                      it = P - ot, st = ct;
                    }
                  }
                } else if (it += j - V, V < X) {
                  X -= V;
                  do
                    ct[P++] = G[it++];
                  while (--V);
                  it = P - ot, st = ct;
                }
                for (; X > 2; ) ct[P++] = st[it++], ct[P++] = st[it++], ct[P++] = st[it++], X -= 3;
                X && (ct[P++] = st[it++], X > 1 && (ct[P++] = st[it++]));
              } else {
                it = P - ot;
                do
                  ct[P++] = ct[it++], ct[P++] = ct[it++], ct[P++] = ct[it++], X -= 3;
                while (X > 2);
                X && (ct[P++] = ct[it++], X > 1 && (ct[P++] = ct[it++]));
              }
              break;
            }
            if (64 & V) {
              d.msg = "invalid distance code", g.mode = 30;
              break t;
            }
            tt = q[(65535 & tt) + (Q & (1 << V) - 1)];
          }
        }
        break;
      }
    } while (w < I && P < D);
    w -= X = H >> 3, Q &= (1 << (H -= X << 3)) - 1, d.next_in = w, d.next_out = P, d.avail_in = w < I ? I - w + 5 : 5 - (w - I), d.avail_out = P < D ? D - P + 257 : 257 - (P - D), g.hold = Q, g.bits = H;
  }, inffast);
}
function requireInftrees() {
  if (hasRequiredInftrees) return inftrees;
  hasRequiredInftrees = 1;
  var d = requireCommon(), m = 15, g = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], w = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], I = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
  return inftrees = function(F, D, U, Z, $, j, G, Q) {
    var H, W, q, et, rt, tt, V, X, ot, it = Q.bits, st = 0, at = 0, ct = 0, K = 0, lt = 0, vt = 0, dt = 0, ht = 0, pt = 0, Ct = 0, St = null, At = 0, Ft = new d.Buf16(16), xt = new d.Buf16(16), Pt = null, Ot = 0;
    for (st = 0; st <= m; st++) Ft[st] = 0;
    for (at = 0; at < Z; at++) Ft[D[U + at]]++;
    for (lt = it, K = m; K >= 1 && Ft[K] === 0; K--) ;
    if (lt > K && (lt = K), K === 0) return $[j++] = 20971520, $[j++] = 20971520, Q.bits = 1, 0;
    for (ct = 1; ct < K && Ft[ct] === 0; ct++) ;
    for (lt < ct && (lt = ct), ht = 1, st = 1; st <= m; st++) if (ht <<= 1, (ht -= Ft[st]) < 0) return -1;
    if (ht > 0 && (F === 0 || K !== 1)) return -1;
    for (xt[1] = 0, st = 1; st < m; st++) xt[st + 1] = xt[st] + Ft[st];
    for (at = 0; at < Z; at++) D[U + at] !== 0 && (G[xt[D[U + at]]++] = at);
    if (F === 0 ? (St = Pt = G, tt = 19) : F === 1 ? (St = g, At -= 257, Pt = w, Ot -= 257, tt = 256) : (St = I, Pt = P, tt = -1), Ct = 0, at = 0, st = ct, rt = j, vt = lt, dt = 0, q = -1, et = (pt = 1 << lt) - 1, F === 1 && pt > 852 || F === 2 && pt > 592) return 1;
    for (; ; ) {
      V = st - dt, G[at] < tt ? (X = 0, ot = G[at]) : G[at] > tt ? (X = Pt[Ot + G[at]], ot = St[At + G[at]]) : (X = 96, ot = 0), H = 1 << st - dt, ct = W = 1 << vt;
      do
        $[rt + (Ct >> dt) + (W -= H)] = V << 24 | X << 16 | ot;
      while (W !== 0);
      for (H = 1 << st - 1; Ct & H; ) H >>= 1;
      if (H !== 0 ? (Ct &= H - 1, Ct += H) : Ct = 0, at++, --Ft[st] == 0) {
        if (st === K) break;
        st = D[U + G[at]];
      }
      if (st > lt && (Ct & et) !== q) {
        for (dt === 0 && (dt = lt), rt += ct, ht = 1 << (vt = st - dt); vt + dt < K && !((ht -= Ft[vt + dt]) <= 0); ) vt++, ht <<= 1;
        if (pt += 1 << vt, F === 1 && pt > 852 || F === 2 && pt > 592) return 1;
        $[q = Ct & et] = lt << 24 | vt << 16 | rt - j;
      }
    }
    return Ct !== 0 && ($[rt + Ct] = st - dt << 24 | 64 << 16), Q.bits = lt, 0;
  };
}
function requireInflate$1() {
  if (hasRequiredInflate$1) return inflate;
  hasRequiredInflate$1 = 1;
  var d = requireCommon(), m = requireAdler32(), g = requireCrc32(), w = requireInffast(), I = requireInftrees(), P = 1, F = 2, D = 0, U = -2, Z = 1, $ = 12, j = 30, G = 852, Q = 592;
  function H(at) {
    return (at >>> 24 & 255) + (at >>> 8 & 65280) + ((65280 & at) << 8) + ((255 & at) << 24);
  }
  function W() {
    this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new d.Buf16(320), this.work = new d.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
  }
  function q(at) {
    var ct;
    return at && at.state ? (ct = at.state, at.total_in = at.total_out = ct.total = 0, at.msg = "", ct.wrap && (at.adler = 1 & ct.wrap), ct.mode = Z, ct.last = 0, ct.havedict = 0, ct.dmax = 32768, ct.head = null, ct.hold = 0, ct.bits = 0, ct.lencode = ct.lendyn = new d.Buf32(G), ct.distcode = ct.distdyn = new d.Buf32(Q), ct.sane = 1, ct.back = -1, D) : U;
  }
  function et(at) {
    var ct;
    return at && at.state ? ((ct = at.state).wsize = 0, ct.whave = 0, ct.wnext = 0, q(at)) : U;
  }
  function rt(at, ct) {
    var K, lt;
    return at && at.state ? (lt = at.state, ct < 0 ? (K = 0, ct = -ct) : (K = 1 + (ct >> 4), ct < 48 && (ct &= 15)), ct && (ct < 8 || ct > 15) ? U : (lt.window !== null && lt.wbits !== ct && (lt.window = null), lt.wrap = K, lt.wbits = ct, et(at))) : U;
  }
  function tt(at, ct) {
    var K, lt;
    return at ? (lt = new W(), at.state = lt, lt.window = null, (K = rt(at, ct)) !== D && (at.state = null), K) : U;
  }
  var V, X, ot = !0;
  function it(at) {
    if (ot) {
      var ct;
      for (V = new d.Buf32(512), X = new d.Buf32(32), ct = 0; ct < 144; ) at.lens[ct++] = 8;
      for (; ct < 256; ) at.lens[ct++] = 9;
      for (; ct < 280; ) at.lens[ct++] = 7;
      for (; ct < 288; ) at.lens[ct++] = 8;
      for (I(P, at.lens, 0, 288, V, 0, at.work, { bits: 9 }), ct = 0; ct < 32; ) at.lens[ct++] = 5;
      I(F, at.lens, 0, 32, X, 0, at.work, { bits: 5 }), ot = !1;
    }
    at.lencode = V, at.lenbits = 9, at.distcode = X, at.distbits = 5;
  }
  function st(at, ct, K, lt) {
    var vt, dt = at.state;
    return dt.window === null && (dt.wsize = 1 << dt.wbits, dt.wnext = 0, dt.whave = 0, dt.window = new d.Buf8(dt.wsize)), lt >= dt.wsize ? (d.arraySet(dt.window, ct, K - dt.wsize, dt.wsize, 0), dt.wnext = 0, dt.whave = dt.wsize) : ((vt = dt.wsize - dt.wnext) > lt && (vt = lt), d.arraySet(dt.window, ct, K - lt, vt, dt.wnext), (lt -= vt) ? (d.arraySet(dt.window, ct, K - lt, lt, 0), dt.wnext = lt, dt.whave = dt.wsize) : (dt.wnext += vt, dt.wnext === dt.wsize && (dt.wnext = 0), dt.whave < dt.wsize && (dt.whave += vt))), 0;
  }
  return inflate.inflateReset = et, inflate.inflateReset2 = rt, inflate.inflateResetKeep = q, inflate.inflateInit = function(at) {
    return tt(at, 15);
  }, inflate.inflateInit2 = tt, inflate.inflate = function(at, ct) {
    var K, lt, vt, dt, ht, pt, Ct, St, At, Ft, xt, Pt, Ot, Bt, kt, Tt, Dt, Zt, $t, Mt, nt, It, mt, gt, _t = 0, wt = new d.Buf8(4), Rt = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    if (!at || !at.state || !at.output || !at.input && at.avail_in !== 0) return U;
    (K = at.state).mode === $ && (K.mode = 13), ht = at.next_out, vt = at.output, Ct = at.avail_out, dt = at.next_in, lt = at.input, pt = at.avail_in, St = K.hold, At = K.bits, Ft = pt, xt = Ct, It = D;
    t: for (; ; ) switch (K.mode) {
      case Z:
        if (K.wrap === 0) {
          K.mode = 13;
          break;
        }
        for (; At < 16; ) {
          if (pt === 0) break t;
          pt--, St += lt[dt++] << At, At += 8;
        }
        if (2 & K.wrap && St === 35615) {
          K.check = 0, wt[0] = 255 & St, wt[1] = St >>> 8 & 255, K.check = g(K.check, wt, 2, 0), St = 0, At = 0, K.mode = 2;
          break;
        }
        if (K.flags = 0, K.head && (K.head.done = !1), !(1 & K.wrap) || (((255 & St) << 8) + (St >> 8)) % 31) {
          at.msg = "incorrect header check", K.mode = j;
          break;
        }
        if ((15 & St) != 8) {
          at.msg = "unknown compression method", K.mode = j;
          break;
        }
        if (At -= 4, nt = 8 + (15 & (St >>>= 4)), K.wbits === 0) K.wbits = nt;
        else if (nt > K.wbits) {
          at.msg = "invalid window size", K.mode = j;
          break;
        }
        K.dmax = 1 << nt, at.adler = K.check = 1, K.mode = 512 & St ? 10 : $, St = 0, At = 0;
        break;
      case 2:
        for (; At < 16; ) {
          if (pt === 0) break t;
          pt--, St += lt[dt++] << At, At += 8;
        }
        if (K.flags = St, (255 & K.flags) != 8) {
          at.msg = "unknown compression method", K.mode = j;
          break;
        }
        if (57344 & K.flags) {
          at.msg = "unknown header flags set", K.mode = j;
          break;
        }
        K.head && (K.head.text = St >> 8 & 1), 512 & K.flags && (wt[0] = 255 & St, wt[1] = St >>> 8 & 255, K.check = g(K.check, wt, 2, 0)), St = 0, At = 0, K.mode = 3;
      case 3:
        for (; At < 32; ) {
          if (pt === 0) break t;
          pt--, St += lt[dt++] << At, At += 8;
        }
        K.head && (K.head.time = St), 512 & K.flags && (wt[0] = 255 & St, wt[1] = St >>> 8 & 255, wt[2] = St >>> 16 & 255, wt[3] = St >>> 24 & 255, K.check = g(K.check, wt, 4, 0)), St = 0, At = 0, K.mode = 4;
      case 4:
        for (; At < 16; ) {
          if (pt === 0) break t;
          pt--, St += lt[dt++] << At, At += 8;
        }
        K.head && (K.head.xflags = 255 & St, K.head.os = St >> 8), 512 & K.flags && (wt[0] = 255 & St, wt[1] = St >>> 8 & 255, K.check = g(K.check, wt, 2, 0)), St = 0, At = 0, K.mode = 5;
      case 5:
        if (1024 & K.flags) {
          for (; At < 16; ) {
            if (pt === 0) break t;
            pt--, St += lt[dt++] << At, At += 8;
          }
          K.length = St, K.head && (K.head.extra_len = St), 512 & K.flags && (wt[0] = 255 & St, wt[1] = St >>> 8 & 255, K.check = g(K.check, wt, 2, 0)), St = 0, At = 0;
        } else K.head && (K.head.extra = null);
        K.mode = 6;
      case 6:
        if (1024 & K.flags && ((Pt = K.length) > pt && (Pt = pt), Pt && (K.head && (nt = K.head.extra_len - K.length, K.head.extra || (K.head.extra = new Array(K.head.extra_len)), d.arraySet(K.head.extra, lt, dt, Pt, nt)), 512 & K.flags && (K.check = g(K.check, lt, Pt, dt)), pt -= Pt, dt += Pt, K.length -= Pt), K.length)) break t;
        K.length = 0, K.mode = 7;
      case 7:
        if (2048 & K.flags) {
          if (pt === 0) break t;
          Pt = 0;
          do
            nt = lt[dt + Pt++], K.head && nt && K.length < 65536 && (K.head.name += String.fromCharCode(nt));
          while (nt && Pt < pt);
          if (512 & K.flags && (K.check = g(K.check, lt, Pt, dt)), pt -= Pt, dt += Pt, nt) break t;
        } else K.head && (K.head.name = null);
        K.length = 0, K.mode = 8;
      case 8:
        if (4096 & K.flags) {
          if (pt === 0) break t;
          Pt = 0;
          do
            nt = lt[dt + Pt++], K.head && nt && K.length < 65536 && (K.head.comment += String.fromCharCode(nt));
          while (nt && Pt < pt);
          if (512 & K.flags && (K.check = g(K.check, lt, Pt, dt)), pt -= Pt, dt += Pt, nt) break t;
        } else K.head && (K.head.comment = null);
        K.mode = 9;
      case 9:
        if (512 & K.flags) {
          for (; At < 16; ) {
            if (pt === 0) break t;
            pt--, St += lt[dt++] << At, At += 8;
          }
          if (St !== (65535 & K.check)) {
            at.msg = "header crc mismatch", K.mode = j;
            break;
          }
          St = 0, At = 0;
        }
        K.head && (K.head.hcrc = K.flags >> 9 & 1, K.head.done = !0), at.adler = K.check = 0, K.mode = $;
        break;
      case 10:
        for (; At < 32; ) {
          if (pt === 0) break t;
          pt--, St += lt[dt++] << At, At += 8;
        }
        at.adler = K.check = H(St), St = 0, At = 0, K.mode = 11;
      case 11:
        if (K.havedict === 0) return at.next_out = ht, at.avail_out = Ct, at.next_in = dt, at.avail_in = pt, K.hold = St, K.bits = At, 2;
        at.adler = K.check = 1, K.mode = $;
      case $:
        if (ct === 5 || ct === 6) break t;
      case 13:
        if (K.last) {
          St >>>= 7 & At, At -= 7 & At, K.mode = 27;
          break;
        }
        for (; At < 3; ) {
          if (pt === 0) break t;
          pt--, St += lt[dt++] << At, At += 8;
        }
        switch (K.last = 1 & St, At -= 1, 3 & (St >>>= 1)) {
          case 0:
            K.mode = 14;
            break;
          case 1:
            if (it(K), K.mode = 20, ct === 6) {
              St >>>= 2, At -= 2;
              break t;
            }
            break;
          case 2:
            K.mode = 17;
            break;
          case 3:
            at.msg = "invalid block type", K.mode = j;
        }
        St >>>= 2, At -= 2;
        break;
      case 14:
        for (St >>>= 7 & At, At -= 7 & At; At < 32; ) {
          if (pt === 0) break t;
          pt--, St += lt[dt++] << At, At += 8;
        }
        if ((65535 & St) != (St >>> 16 ^ 65535)) {
          at.msg = "invalid stored block lengths", K.mode = j;
          break;
        }
        if (K.length = 65535 & St, St = 0, At = 0, K.mode = 15, ct === 6) break t;
      case 15:
        K.mode = 16;
      case 16:
        if (Pt = K.length) {
          if (Pt > pt && (Pt = pt), Pt > Ct && (Pt = Ct), Pt === 0) break t;
          d.arraySet(vt, lt, dt, Pt, ht), pt -= Pt, dt += Pt, Ct -= Pt, ht += Pt, K.length -= Pt;
          break;
        }
        K.mode = $;
        break;
      case 17:
        for (; At < 14; ) {
          if (pt === 0) break t;
          pt--, St += lt[dt++] << At, At += 8;
        }
        if (K.nlen = 257 + (31 & St), St >>>= 5, At -= 5, K.ndist = 1 + (31 & St), St >>>= 5, At -= 5, K.ncode = 4 + (15 & St), St >>>= 4, At -= 4, K.nlen > 286 || K.ndist > 30) {
          at.msg = "too many length or distance symbols", K.mode = j;
          break;
        }
        K.have = 0, K.mode = 18;
      case 18:
        for (; K.have < K.ncode; ) {
          for (; At < 3; ) {
            if (pt === 0) break t;
            pt--, St += lt[dt++] << At, At += 8;
          }
          K.lens[Rt[K.have++]] = 7 & St, St >>>= 3, At -= 3;
        }
        for (; K.have < 19; ) K.lens[Rt[K.have++]] = 0;
        if (K.lencode = K.lendyn, K.lenbits = 7, mt = { bits: K.lenbits }, It = I(0, K.lens, 0, 19, K.lencode, 0, K.work, mt), K.lenbits = mt.bits, It) {
          at.msg = "invalid code lengths set", K.mode = j;
          break;
        }
        K.have = 0, K.mode = 19;
      case 19:
        for (; K.have < K.nlen + K.ndist; ) {
          for (; Tt = (_t = K.lencode[St & (1 << K.lenbits) - 1]) >>> 16 & 255, Dt = 65535 & _t, !((kt = _t >>> 24) <= At); ) {
            if (pt === 0) break t;
            pt--, St += lt[dt++] << At, At += 8;
          }
          if (Dt < 16) St >>>= kt, At -= kt, K.lens[K.have++] = Dt;
          else {
            if (Dt === 16) {
              for (gt = kt + 2; At < gt; ) {
                if (pt === 0) break t;
                pt--, St += lt[dt++] << At, At += 8;
              }
              if (St >>>= kt, At -= kt, K.have === 0) {
                at.msg = "invalid bit length repeat", K.mode = j;
                break;
              }
              nt = K.lens[K.have - 1], Pt = 3 + (3 & St), St >>>= 2, At -= 2;
            } else if (Dt === 17) {
              for (gt = kt + 3; At < gt; ) {
                if (pt === 0) break t;
                pt--, St += lt[dt++] << At, At += 8;
              }
              At -= kt, nt = 0, Pt = 3 + (7 & (St >>>= kt)), St >>>= 3, At -= 3;
            } else {
              for (gt = kt + 7; At < gt; ) {
                if (pt === 0) break t;
                pt--, St += lt[dt++] << At, At += 8;
              }
              At -= kt, nt = 0, Pt = 11 + (127 & (St >>>= kt)), St >>>= 7, At -= 7;
            }
            if (K.have + Pt > K.nlen + K.ndist) {
              at.msg = "invalid bit length repeat", K.mode = j;
              break;
            }
            for (; Pt--; ) K.lens[K.have++] = nt;
          }
        }
        if (K.mode === j) break;
        if (K.lens[256] === 0) {
          at.msg = "invalid code -- missing end-of-block", K.mode = j;
          break;
        }
        if (K.lenbits = 9, mt = { bits: K.lenbits }, It = I(P, K.lens, 0, K.nlen, K.lencode, 0, K.work, mt), K.lenbits = mt.bits, It) {
          at.msg = "invalid literal/lengths set", K.mode = j;
          break;
        }
        if (K.distbits = 6, K.distcode = K.distdyn, mt = { bits: K.distbits }, It = I(F, K.lens, K.nlen, K.ndist, K.distcode, 0, K.work, mt), K.distbits = mt.bits, It) {
          at.msg = "invalid distances set", K.mode = j;
          break;
        }
        if (K.mode = 20, ct === 6) break t;
      case 20:
        K.mode = 21;
      case 21:
        if (pt >= 6 && Ct >= 258) {
          at.next_out = ht, at.avail_out = Ct, at.next_in = dt, at.avail_in = pt, K.hold = St, K.bits = At, w(at, xt), ht = at.next_out, vt = at.output, Ct = at.avail_out, dt = at.next_in, lt = at.input, pt = at.avail_in, St = K.hold, At = K.bits, K.mode === $ && (K.back = -1);
          break;
        }
        for (K.back = 0; Tt = (_t = K.lencode[St & (1 << K.lenbits) - 1]) >>> 16 & 255, Dt = 65535 & _t, !((kt = _t >>> 24) <= At); ) {
          if (pt === 0) break t;
          pt--, St += lt[dt++] << At, At += 8;
        }
        if (Tt && !(240 & Tt)) {
          for (Zt = kt, $t = Tt, Mt = Dt; Tt = (_t = K.lencode[Mt + ((St & (1 << Zt + $t) - 1) >> Zt)]) >>> 16 & 255, Dt = 65535 & _t, !(Zt + (kt = _t >>> 24) <= At); ) {
            if (pt === 0) break t;
            pt--, St += lt[dt++] << At, At += 8;
          }
          St >>>= Zt, At -= Zt, K.back += Zt;
        }
        if (St >>>= kt, At -= kt, K.back += kt, K.length = Dt, Tt === 0) {
          K.mode = 26;
          break;
        }
        if (32 & Tt) {
          K.back = -1, K.mode = $;
          break;
        }
        if (64 & Tt) {
          at.msg = "invalid literal/length code", K.mode = j;
          break;
        }
        K.extra = 15 & Tt, K.mode = 22;
      case 22:
        if (K.extra) {
          for (gt = K.extra; At < gt; ) {
            if (pt === 0) break t;
            pt--, St += lt[dt++] << At, At += 8;
          }
          K.length += St & (1 << K.extra) - 1, St >>>= K.extra, At -= K.extra, K.back += K.extra;
        }
        K.was = K.length, K.mode = 23;
      case 23:
        for (; Tt = (_t = K.distcode[St & (1 << K.distbits) - 1]) >>> 16 & 255, Dt = 65535 & _t, !((kt = _t >>> 24) <= At); ) {
          if (pt === 0) break t;
          pt--, St += lt[dt++] << At, At += 8;
        }
        if (!(240 & Tt)) {
          for (Zt = kt, $t = Tt, Mt = Dt; Tt = (_t = K.distcode[Mt + ((St & (1 << Zt + $t) - 1) >> Zt)]) >>> 16 & 255, Dt = 65535 & _t, !(Zt + (kt = _t >>> 24) <= At); ) {
            if (pt === 0) break t;
            pt--, St += lt[dt++] << At, At += 8;
          }
          St >>>= Zt, At -= Zt, K.back += Zt;
        }
        if (St >>>= kt, At -= kt, K.back += kt, 64 & Tt) {
          at.msg = "invalid distance code", K.mode = j;
          break;
        }
        K.offset = Dt, K.extra = 15 & Tt, K.mode = 24;
      case 24:
        if (K.extra) {
          for (gt = K.extra; At < gt; ) {
            if (pt === 0) break t;
            pt--, St += lt[dt++] << At, At += 8;
          }
          K.offset += St & (1 << K.extra) - 1, St >>>= K.extra, At -= K.extra, K.back += K.extra;
        }
        if (K.offset > K.dmax) {
          at.msg = "invalid distance too far back", K.mode = j;
          break;
        }
        K.mode = 25;
      case 25:
        if (Ct === 0) break t;
        if (Pt = xt - Ct, K.offset > Pt) {
          if ((Pt = K.offset - Pt) > K.whave && K.sane) {
            at.msg = "invalid distance too far back", K.mode = j;
            break;
          }
          Pt > K.wnext ? (Pt -= K.wnext, Ot = K.wsize - Pt) : Ot = K.wnext - Pt, Pt > K.length && (Pt = K.length), Bt = K.window;
        } else Bt = vt, Ot = ht - K.offset, Pt = K.length;
        Pt > Ct && (Pt = Ct), Ct -= Pt, K.length -= Pt;
        do
          vt[ht++] = Bt[Ot++];
        while (--Pt);
        K.length === 0 && (K.mode = 21);
        break;
      case 26:
        if (Ct === 0) break t;
        vt[ht++] = K.length, Ct--, K.mode = 21;
        break;
      case 27:
        if (K.wrap) {
          for (; At < 32; ) {
            if (pt === 0) break t;
            pt--, St |= lt[dt++] << At, At += 8;
          }
          if (xt -= Ct, at.total_out += xt, K.total += xt, xt && (at.adler = K.check = K.flags ? g(K.check, vt, xt, ht - xt) : m(K.check, vt, xt, ht - xt)), xt = Ct, (K.flags ? St : H(St)) !== K.check) {
            at.msg = "incorrect data check", K.mode = j;
            break;
          }
          St = 0, At = 0;
        }
        K.mode = 28;
      case 28:
        if (K.wrap && K.flags) {
          for (; At < 32; ) {
            if (pt === 0) break t;
            pt--, St += lt[dt++] << At, At += 8;
          }
          if (St !== (4294967295 & K.total)) {
            at.msg = "incorrect length check", K.mode = j;
            break;
          }
          St = 0, At = 0;
        }
        K.mode = 29;
      case 29:
        It = 1;
        break t;
      case j:
        It = -3;
        break t;
      case 31:
        return -4;
      default:
        return U;
    }
    return at.next_out = ht, at.avail_out = Ct, at.next_in = dt, at.avail_in = pt, K.hold = St, K.bits = At, (K.wsize || xt !== at.avail_out && K.mode < j && (K.mode < 27 || ct !== 4)) && st(at, at.output, at.next_out, xt - at.avail_out), Ft -= at.avail_in, xt -= at.avail_out, at.total_in += Ft, at.total_out += xt, K.total += xt, K.wrap && xt && (at.adler = K.check = K.flags ? g(K.check, vt, xt, at.next_out - xt) : m(K.check, vt, xt, at.next_out - xt)), at.data_type = K.bits + (K.last ? 64 : 0) + (K.mode === $ ? 128 : 0) + (K.mode === 20 || K.mode === 15 ? 256 : 0), (Ft === 0 && xt === 0 || ct === 4) && It === D && (It = -5), It;
  }, inflate.inflateEnd = function(at) {
    if (!at || !at.state) return U;
    var ct = at.state;
    return ct.window && (ct.window = null), at.state = null, D;
  }, inflate.inflateGetHeader = function(at, ct) {
    var K;
    return at && at.state && 2 & (K = at.state).wrap ? (K.head = ct, ct.done = !1, D) : U;
  }, inflate.inflateSetDictionary = function(at, ct) {
    var K, lt = ct.length;
    return at && at.state ? (K = at.state).wrap !== 0 && K.mode !== 11 ? U : K.mode === 11 && m(1, ct, lt, 0) !== K.check ? -3 : st(at, ct, lt, lt) ? (K.mode = 31, -4) : (K.havedict = 1, D) : U;
  }, inflate.inflateInfo = "pako inflate (from Nodeca project)", inflate;
}
function requireConstants() {
  return hasRequiredConstants ? constants : (hasRequiredConstants = 1, constants = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 });
}
function requireGzheader() {
  return hasRequiredGzheader ? gzheader : (hasRequiredGzheader = 1, gzheader = function() {
    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
  });
}
function requireInflate() {
  if (hasRequiredInflate) return inflate$1;
  hasRequiredInflate = 1;
  var d = requireInflate$1(), m = requireCommon(), g = requireStrings(), w = requireConstants(), I = requireMessages(), P = requireZstream(), F = requireGzheader(), D = Object.prototype.toString;
  function U($) {
    if (!(this instanceof U)) return new U($);
    this.options = m.assign({ chunkSize: 16384, windowBits: 0, to: "" }, $ || {});
    var j = this.options;
    j.raw && j.windowBits >= 0 && j.windowBits < 16 && (j.windowBits = -j.windowBits, j.windowBits === 0 && (j.windowBits = -15)), !(j.windowBits >= 0 && j.windowBits < 16) || $ && $.windowBits || (j.windowBits += 32), j.windowBits > 15 && j.windowBits < 48 && (15 & j.windowBits || (j.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new P(), this.strm.avail_out = 0;
    var G = d.inflateInit2(this.strm, j.windowBits);
    if (G !== w.Z_OK) throw new Error(I[G]);
    if (this.header = new F(), d.inflateGetHeader(this.strm, this.header), j.dictionary && (typeof j.dictionary == "string" ? j.dictionary = g.string2buf(j.dictionary) : D.call(j.dictionary) === "[object ArrayBuffer]" && (j.dictionary = new Uint8Array(j.dictionary)), j.raw && (G = d.inflateSetDictionary(this.strm, j.dictionary)) !== w.Z_OK)) throw new Error(I[G]);
  }
  function Z($, j) {
    var G = new U(j);
    if (G.push($, !0), G.err) throw G.msg || I[G.err];
    return G.result;
  }
  return U.prototype.push = function($, j) {
    var G, Q, H, W, q, et = this.strm, rt = this.options.chunkSize, tt = this.options.dictionary, V = !1;
    if (this.ended) return !1;
    Q = j === ~~j ? j : j === !0 ? w.Z_FINISH : w.Z_NO_FLUSH, typeof $ == "string" ? et.input = g.binstring2buf($) : D.call($) === "[object ArrayBuffer]" ? et.input = new Uint8Array($) : et.input = $, et.next_in = 0, et.avail_in = et.input.length;
    do {
      if (et.avail_out === 0 && (et.output = new m.Buf8(rt), et.next_out = 0, et.avail_out = rt), (G = d.inflate(et, w.Z_NO_FLUSH)) === w.Z_NEED_DICT && tt && (G = d.inflateSetDictionary(this.strm, tt)), G === w.Z_BUF_ERROR && V === !0 && (G = w.Z_OK, V = !1), G !== w.Z_STREAM_END && G !== w.Z_OK) return this.onEnd(G), this.ended = !0, !1;
      et.next_out && (et.avail_out !== 0 && G !== w.Z_STREAM_END && (et.avail_in !== 0 || Q !== w.Z_FINISH && Q !== w.Z_SYNC_FLUSH) || (this.options.to === "string" ? (H = g.utf8border(et.output, et.next_out), W = et.next_out - H, q = g.buf2string(et.output, H), et.next_out = W, et.avail_out = rt - W, W && m.arraySet(et.output, et.output, H, W, 0), this.onData(q)) : this.onData(m.shrinkBuf(et.output, et.next_out)))), et.avail_in === 0 && et.avail_out === 0 && (V = !0);
    } while ((et.avail_in > 0 || et.avail_out === 0) && G !== w.Z_STREAM_END);
    return G === w.Z_STREAM_END && (Q = w.Z_FINISH), Q === w.Z_FINISH ? (G = d.inflateEnd(this.strm), this.onEnd(G), this.ended = !0, G === w.Z_OK) : Q !== w.Z_SYNC_FLUSH || (this.onEnd(w.Z_OK), et.avail_out = 0, !0);
  }, U.prototype.onData = function($) {
    this.chunks.push($);
  }, U.prototype.onEnd = function($) {
    $ === w.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = m.flattenChunks(this.chunks)), this.chunks = [], this.err = $, this.msg = this.strm.msg;
  }, inflate$1.Inflate = U, inflate$1.inflate = Z, inflate$1.inflateRaw = function($, j) {
    return (j = j || {}).raw = !0, Z($, j);
  }, inflate$1.ungzip = Z, inflate$1;
}
function requirePako() {
  if (hasRequiredPako) return pako_1;
  hasRequiredPako = 1;
  var d = {};
  return (0, requireCommon().assign)(d, requireDeflate(), requireInflate(), requireConstants()), pako_1 = d;
}
(function(d) {
  (function() {
    var m = {};
    function g() {
      typeof process < "u" && process.env.NODE_ENV != "development" || console.log.apply(console, arguments);
    }
    d.exports = m, function(w, I) {
      (function() {
        var P = function() {
          function U(Z) {
            this.message = "JPEG error: " + Z;
          }
          return U.prototype = new Error(), U.prototype.name = "JpegError", U.constructor = U, U;
        }(), F = function() {
          var U = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), Z = 4017, $ = 799, j = 3406, G = 2276, Q = 1567, H = 3784, W = 5793, q = 2896;
          function et(st) {
            st == null && (st = {}), st.w == null && (st.w = -1), this.V = st.n, this.N = st.w;
          }
          function rt(st, at) {
            for (var ct, K, lt, vt = 0, dt = [], ht = 16; ht > 0 && !st[ht - 1]; ) ht--;
            dt.push({ children: [], index: 0 });
            var pt = dt[0];
            for (ct = 0; ct < ht; ct++) {
              for (K = 0; K < st[ct]; K++) {
                for ((pt = dt.pop()).children[pt.index] = at[vt]; pt.index > 0; ) pt = dt.pop();
                for (pt.index++, dt.push(pt); dt.length <= ct; ) dt.push(lt = { children: [], index: 0 }), pt.children[pt.index] = lt.children, pt = lt;
                vt++;
              }
              ct + 1 < ht && (dt.push(lt = { children: [], index: 0 }), pt.children[pt.index] = lt.children, pt = lt);
            }
            return dt[0].children;
          }
          function tt(st, at, ct) {
            return 64 * ((st.P + 1) * at + ct);
          }
          function V(st, at, ct, K, lt, vt, dt, ht, pt, Ct) {
            Ct == null && (Ct = !1);
            var St, At, Ft, xt, Pt, Ot, Bt, kt, Tt, Dt, Zt, $t = ct.m, Mt = ct.Z, nt = at, It = 0, mt = 0, gt = 0, _t = 0, wt = 0, Rt = 0;
            function J() {
              if (mt > 0) return mt--, It >> mt & 1;
              if ((It = st[at++]) === 255) {
                var Vt = st[at++];
                if (Vt) {
                  if (Vt === 220 && Ct) {
                    var ee = D(st, at += 2);
                    if (at += 2, ee > 0 && ee !== ct.s) throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", ee);
                  } else if (Vt === 217) {
                    if (Ct) {
                      var Jt = 8 * wt;
                      if (Jt > 0 && Jt < ct.s / 10) throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", Jt);
                    }
                    throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
                  }
                  throw new P("unexpected marker");
                }
              }
              return mt = 7, It >>> 7;
            }
            function ut(Vt) {
              for (var ee = Vt; ; ) {
                switch (typeof (ee = ee[J()])) {
                  case "number":
                    return ee;
                  case "object":
                    continue;
                }
                throw new P("invalid huffman sequence");
              }
            }
            function bt(Vt) {
              for (var ee = 0; Vt > 0; ) ee = ee << 1 | J(), Vt--;
              return ee;
            }
            function yt(Vt) {
              if (Vt === 1) return J() === 1 ? 1 : -1;
              var ee = bt(Vt);
              return ee >= 1 << Vt - 1 ? ee : ee + (-1 << Vt) + 1;
            }
            function Lt(Vt, ee, Jt, le, ae) {
              var se = Jt % $t;
              wt = (Jt / $t | 0) * Vt.A + le;
              var fe = se * Vt.h + ae;
              ee(Vt, tt(Vt, wt, fe));
            }
            function jt(Vt, ee, Jt) {
              wt = Jt / Vt.P | 0;
              var le = Jt % Vt.P;
              ee(Vt, tt(Vt, wt, le));
            }
            var Kt = K.length;
            for (Bt = Mt ? vt === 0 ? ht === 0 ? function(Vt, ee) {
              var Jt = ut(Vt.J), le = Jt === 0 ? 0 : yt(Jt) << pt;
              Vt.D[ee] = Vt.Q += le;
            } : function(Vt, ee) {
              Vt.D[ee] |= J() << pt;
            } : ht === 0 ? function(Vt, ee) {
              if (gt > 0) gt--;
              else for (var Jt = vt, le = dt; Jt <= le; ) {
                var ae = ut(Vt.i), se = 15 & ae, fe = ae >> 4;
                if (se !== 0) {
                  var ne = U[Jt += fe];
                  Vt.D[ee + ne] = yt(se) * (1 << pt), Jt++;
                } else {
                  if (fe < 15) {
                    gt = bt(fe) + (1 << fe) - 1;
                    break;
                  }
                  Jt += 16;
                }
              }
            } : function(Vt, ee) {
              for (var Jt, le, ae = vt, se = dt, fe = 0; ae <= se; ) {
                var ne = ee + U[ae], Nt = Vt.D[ne] < 0 ? -1 : 1;
                switch (_t) {
                  case 0:
                    if (fe = (le = ut(Vt.i)) >> 4, (Jt = 15 & le) == 0) fe < 15 ? (gt = bt(fe) + (1 << fe), _t = 4) : (fe = 16, _t = 1);
                    else {
                      if (Jt !== 1) throw new P("invalid ACn encoding");
                      St = yt(Jt), _t = fe ? 2 : 3;
                    }
                    continue;
                  case 1:
                  case 2:
                    Vt.D[ne] ? Vt.D[ne] += Nt * (J() << pt) : --fe == 0 && (_t = _t === 2 ? 3 : 0);
                    break;
                  case 3:
                    Vt.D[ne] ? Vt.D[ne] += Nt * (J() << pt) : (Vt.D[ne] = St << pt, _t = 0);
                    break;
                  case 4:
                    Vt.D[ne] && (Vt.D[ne] += Nt * (J() << pt));
                }
                ae++;
              }
              _t === 4 && --gt == 0 && (_t = 0);
            } : function(Vt, ee) {
              var Jt = ut(Vt.J), le = Jt === 0 ? 0 : yt(Jt), ae = 1;
              for (Vt.D[ee] = Vt.Q += le; ae < 64; ) {
                var se = ut(Vt.i), fe = 15 & se, ne = se >> 4;
                if (fe !== 0) {
                  var Nt = U[ae += ne];
                  Vt.D[ee + Nt] = yt(fe), ae++;
                } else {
                  if (ne < 15) break;
                  ae += 16;
                }
              }
            }, Tt = Kt === 1 ? K[0].P * K[0].c : $t * ct.R; Rt <= Tt; ) {
              var te = lt ? Math.min(Tt - Rt, lt) : Tt;
              if (te > 0) {
                for (Ft = 0; Ft < Kt; Ft++) K[Ft].Q = 0;
                if (gt = 0, Kt === 1) for (At = K[0], Ot = 0; Ot < te; Ot++) jt(At, Bt, Rt), Rt++;
                else for (Ot = 0; Ot < te; Ot++) {
                  for (Ft = 0; Ft < Kt; Ft++) for (Dt = (At = K[Ft]).h, Zt = At.A, xt = 0; xt < Zt; xt++) for (Pt = 0; Pt < Dt; Pt++) Lt(At, Bt, Rt, xt, Pt);
                  Rt++;
                }
              }
              if (mt = 0, !(kt = it(st, at)) || (kt.u && (at = kt.offset), !(kt.M >= 65488 && kt.M <= 65495))) break;
              at += 2;
            }
            return at - nt;
          }
          function X(st, at, ct) {
            var K, lt, vt, dt, ht, pt, Ct, St, At, Ft, xt, Pt, Ot, Bt, kt, Tt, Dt, Zt = st.$, $t = st.D;
            if (!Zt) throw new P("missing required Quantization Table.");
            for (var Mt = 0; Mt < 64; Mt += 8) At = $t[at + Mt], Ft = $t[at + Mt + 1], xt = $t[at + Mt + 2], Pt = $t[at + Mt + 3], Ot = $t[at + Mt + 4], Bt = $t[at + Mt + 5], kt = $t[at + Mt + 6], Tt = $t[at + Mt + 7], At *= Zt[Mt], Ft | xt | Pt | Ot | Bt | kt | Tt ? (Ft *= Zt[Mt + 1], xt *= Zt[Mt + 2], Pt *= Zt[Mt + 3], Ot *= Zt[Mt + 4], Bt *= Zt[Mt + 5], kt *= Zt[Mt + 6], Tt *= Zt[Mt + 7], lt = (K = (K = W * At + 128 >> 8) + (lt = W * Ot + 128 >> 8) + 1 >> 1) - lt, Dt = (vt = xt) * H + (dt = kt) * Q + 128 >> 8, vt = vt * Q - dt * H + 128 >> 8, Ct = (ht = (ht = q * (Ft - Tt) + 128 >> 8) + (Ct = Bt << 4) + 1 >> 1) - Ct, pt = (St = (St = q * (Ft + Tt) + 128 >> 8) + (pt = Pt << 4) + 1 >> 1) - pt, dt = (K = K + (dt = Dt) + 1 >> 1) - dt, vt = (lt = lt + vt + 1 >> 1) - vt, Dt = ht * G + St * j + 2048 >> 12, ht = ht * j - St * G + 2048 >> 12, St = Dt, Dt = pt * $ + Ct * Z + 2048 >> 12, pt = pt * Z - Ct * $ + 2048 >> 12, Ct = Dt, ct[Mt] = K + St, ct[Mt + 7] = K - St, ct[Mt + 1] = lt + Ct, ct[Mt + 6] = lt - Ct, ct[Mt + 2] = vt + pt, ct[Mt + 5] = vt - pt, ct[Mt + 3] = dt + ht, ct[Mt + 4] = dt - ht) : (Dt = W * At + 512 >> 10, ct[Mt] = Dt, ct[Mt + 1] = Dt, ct[Mt + 2] = Dt, ct[Mt + 3] = Dt, ct[Mt + 4] = Dt, ct[Mt + 5] = Dt, ct[Mt + 6] = Dt, ct[Mt + 7] = Dt);
            for (var nt = 0; nt < 8; ++nt) At = ct[nt], (Ft = ct[nt + 8]) | (xt = ct[nt + 16]) | (Pt = ct[nt + 24]) | (Ot = ct[nt + 32]) | (Bt = ct[nt + 40]) | (kt = ct[nt + 48]) | (Tt = ct[nt + 56]) ? (lt = (K = 4112 + ((K = W * At + 2048 >> 12) + (lt = W * Ot + 2048 >> 12) + 1 >> 1)) - lt, Dt = (vt = xt) * H + (dt = kt) * Q + 2048 >> 12, vt = vt * Q - dt * H + 2048 >> 12, dt = Dt, Ct = (ht = (ht = q * (Ft - Tt) + 2048 >> 12) + (Ct = Bt) + 1 >> 1) - Ct, pt = (St = (St = q * (Ft + Tt) + 2048 >> 12) + (pt = Pt) + 1 >> 1) - pt, Dt = ht * G + St * j + 2048 >> 12, ht = ht * j - St * G + 2048 >> 12, St = Dt, Dt = pt * $ + Ct * Z + 2048 >> 12, pt = pt * Z - Ct * $ + 2048 >> 12, (At = (K = K + dt + 1 >> 1) + St) < 16 ? At = 0 : At >= 4080 ? At = 255 : At >>= 4, (Ft = (lt = lt + vt + 1 >> 1) + (Ct = Dt)) < 16 ? Ft = 0 : Ft >= 4080 ? Ft = 255 : Ft >>= 4, (xt = (vt = lt - vt) + pt) < 16 ? xt = 0 : xt >= 4080 ? xt = 255 : xt >>= 4, (Pt = (dt = K - dt) + ht) < 16 ? Pt = 0 : Pt >= 4080 ? Pt = 255 : Pt >>= 4, (Ot = dt - ht) < 16 ? Ot = 0 : Ot >= 4080 ? Ot = 255 : Ot >>= 4, (Bt = vt - pt) < 16 ? Bt = 0 : Bt >= 4080 ? Bt = 255 : Bt >>= 4, (kt = lt - Ct) < 16 ? kt = 0 : kt >= 4080 ? kt = 255 : kt >>= 4, (Tt = K - St) < 16 ? Tt = 0 : Tt >= 4080 ? Tt = 255 : Tt >>= 4, $t[at + nt] = At, $t[at + nt + 8] = Ft, $t[at + nt + 16] = xt, $t[at + nt + 24] = Pt, $t[at + nt + 32] = Ot, $t[at + nt + 40] = Bt, $t[at + nt + 48] = kt, $t[at + nt + 56] = Tt) : (Dt = (Dt = W * At + 8192 >> 14) < -2040 ? 0 : Dt >= 2024 ? 255 : Dt + 2056 >> 4, $t[at + nt] = Dt, $t[at + nt + 8] = Dt, $t[at + nt + 16] = Dt, $t[at + nt + 24] = Dt, $t[at + nt + 32] = Dt, $t[at + nt + 40] = Dt, $t[at + nt + 48] = Dt, $t[at + nt + 56] = Dt);
          }
          function ot(st, at) {
            for (var ct = at.P, K = at.c, lt = new Int16Array(64), vt = 0; vt < K; vt++) for (var dt = 0; dt < ct; dt++)
              X(at, tt(at, vt, dt), lt);
            return at.D;
          }
          function it(st, at, ct) {
            ct == null && (ct = at);
            var K = st.length - 1, lt = ct < at ? ct : at;
            if (at >= K) return null;
            var vt = D(st, at);
            if (vt >= 65472 && vt <= 65534) return { u: null, M: vt, offset: at };
            for (var dt = D(st, lt); !(dt >= 65472 && dt <= 65534); ) {
              if (++lt >= K) return null;
              dt = D(st, lt);
            }
            return { u: vt.toString(16), M: dt, offset: lt };
          }
          return et.prototype = { parse(st, at) {
            at == null && (at = {});
            var ct, K, lt = at.F, vt = 0, dt = null, ht = null, pt = 0;
            function Ct() {
              var Ut = D(st, vt), Wt = (vt += 2) + Ut - 2, Et = it(st, Wt, vt);
              Et && Et.u && (Wt = Et.offset);
              var Yt = st.subarray(vt, Wt);
              return vt += Yt.length, Yt;
            }
            function St(Ut) {
              for (var Wt = Math.ceil(Ut.o / 8 / Ut.X), Et = Math.ceil(Ut.s / 8 / Ut.B), Yt = 0; Yt < Ut.W.length; Yt++) {
                jt = Ut.W[Yt];
                var ce = Math.ceil(Math.ceil(Ut.o / 8) * jt.h / Ut.X), ft = Math.ceil(Math.ceil(Ut.s / 8) * jt.A / Ut.B), qt = Wt * jt.h, Gt = 64 * (Et * jt.A) * (qt + 1);
                jt.D = new Int16Array(Gt), jt.P = ce, jt.c = ft;
              }
              Ut.m = Wt, Ut.R = Et;
            }
            var At = [], Ft = [], xt = [], Pt = D(st, vt);
            if (vt += 2, Pt !== 65496) throw new P("SOI not found");
            Pt = D(st, vt), vt += 2;
            t: for (; Pt !== 65497; ) {
              var Ot, Bt, kt;
              switch (Pt) {
                case 65504:
                case 65505:
                case 65506:
                case 65507:
                case 65508:
                case 65509:
                case 65510:
                case 65511:
                case 65512:
                case 65513:
                case 65514:
                case 65515:
                case 65516:
                case 65517:
                case 65518:
                case 65519:
                case 65534:
                  var Tt = Ct();
                  Pt === 65504 && Tt[0] === 74 && Tt[1] === 70 && Tt[2] === 73 && Tt[3] === 70 && Tt[4] === 0 && (dt = { version: { d: Tt[5], T: Tt[6] }, K: Tt[7], j: Tt[8] << 8 | Tt[9], H: Tt[10] << 8 | Tt[11], S: Tt[12], I: Tt[13], C: Tt.subarray(14, 14 + 3 * Tt[12] * Tt[13]) }), Pt === 65518 && Tt[0] === 65 && Tt[1] === 100 && Tt[2] === 111 && Tt[3] === 98 && Tt[4] === 101 && (ht = { version: Tt[5] << 8 | Tt[6], k: Tt[7] << 8 | Tt[8], q: Tt[9] << 8 | Tt[10], a: Tt[11] });
                  break;
                case 65499:
                  for (var Dt = D(st, vt) + (vt += 2) - 2; vt < Dt; ) {
                    var Zt = st[vt++], $t = new Uint16Array(64);
                    if (Zt >> 4) {
                      if (Zt >> 4 != 1) throw new P("DQT - invalid table spec");
                      for (Bt = 0; Bt < 64; Bt++) $t[U[Bt]] = D(st, vt), vt += 2;
                    } else for (Bt = 0; Bt < 64; Bt++) $t[U[Bt]] = st[vt++];
                    At[15 & Zt] = $t;
                  }
                  break;
                case 65472:
                case 65473:
                case 65474:
                  if (ct) throw new P("Only single frame JPEGs supported");
                  vt += 2, (ct = {}).G = Pt === 65473, ct.Z = Pt === 65474, ct.precision = st[vt++];
                  var Mt, nt = D(st, vt), It = 0, mt = 0;
                  vt += 2, ct.s = lt || nt, ct.o = D(st, vt), vt += 2, ct.W = [], ct._ = {};
                  var gt = st[vt++];
                  for (Ot = 0; Ot < gt; Ot++) {
                    Mt = st[vt];
                    var _t = st[vt + 1] >> 4, wt = 15 & st[vt + 1];
                    It < _t && (It = _t), mt < wt && (mt = wt);
                    var Rt = st[vt + 2];
                    kt = ct.W.push({ h: _t, A: wt, L: Rt, $: null }), ct._[Mt] = kt - 1, vt += 3;
                  }
                  ct.X = It, ct.B = mt, St(ct);
                  break;
                case 65476:
                  var J = D(st, vt);
                  for (vt += 2, Ot = 2; Ot < J; ) {
                    var ut = st[vt++], bt = new Uint8Array(16), yt = 0;
                    for (Bt = 0; Bt < 16; Bt++, vt++) yt += bt[Bt] = st[vt];
                    var Lt = new Uint8Array(yt);
                    for (Bt = 0; Bt < yt; Bt++, vt++) Lt[Bt] = st[vt];
                    Ot += 17 + yt, (ut >> 4 ? Ft : xt)[15 & ut] = rt(bt, Lt);
                  }
                  break;
                case 65501:
                  K = D(st, vt += 2), vt += 2;
                  break;
                case 65498:
                  var jt, Kt = ++pt == 1 && !lt;
                  vt += 2;
                  var te = st[vt++], Vt = [];
                  for (Ot = 0; Ot < te; Ot++) {
                    var ee = st[vt++], Jt = ct._[ee];
                    (jt = ct.W[Jt]).index = ee;
                    var le = st[vt++];
                    jt.J = xt[le >> 4], jt.i = Ft[15 & le], Vt.push(jt);
                  }
                  var ae = st[vt++], se = st[vt++], fe = st[vt++];
                  try {
                    var ne = V(st, vt, ct, Vt, K, ae, se, fe >> 4, 15 & fe, Kt);
                    vt += ne;
                  } catch (Ut) {
                    if (Ut instanceof DNLMarkerError) return this.parse(st, { F: Ut.s });
                    if (Ut instanceof EOIMarkerError) break t;
                    throw Ut;
                  }
                  break;
                case 65500:
                  vt += 4;
                  break;
                case 65535:
                  st[vt] !== 255 && vt--;
                  break;
                default:
                  var Nt = it(st, vt - 2, vt - 3);
                  if (Nt && Nt.u) {
                    vt = Nt.offset;
                    break;
                  }
                  if (vt >= st.length - 1) break t;
                  throw new P("JpegImage.parse - unknown marker: " + Pt.toString(16));
              }
              Pt = D(st, vt), vt += 2;
            }
            for (this.width = ct.o, this.height = ct.s, this.g = dt, this.b = ht, this.W = [], Ot = 0; Ot < ct.W.length; Ot++) {
              var Xt = At[(jt = ct.W[Ot]).L];
              Xt && (jt.$ = Xt), this.W.push({ index: jt.index, e: ot(0, jt), l: jt.h / ct.X, t: jt.A / ct.B, P: jt.P, c: jt.c });
            }
            this.p = this.W.length;
          }, Y(st, at, ct) {
            ct == null && (ct = !1);
            var K, lt, vt, dt, ht, pt, Ct, St, At, Ft, xt, Pt, Ot = this.width / st, Bt = this.height / at, kt = 0, Tt = this.W.length, Dt = st * at * Tt, Zt = new Uint8ClampedArray(Dt), $t = new Uint32Array(st), Mt = 4294967288;
            for (Ct = 0; Ct < Tt; Ct++) {
              if (lt = (K = this.W[Ct]).l * Ot, vt = K.t * Bt, kt = Ct, xt = K.e, dt = K.P + 1 << 3, lt !== Pt) {
                for (ht = 0; ht < st; ht++) St = 0 | ht * lt, $t[ht] = (St & Mt) << 3 | 7 & St;
                Pt = lt;
              }
              for (pt = 0; pt < at; pt++) for (Ft = dt * ((St = 0 | pt * vt) & Mt) | (7 & St) << 3, ht = 0; ht < st; ht++) Zt[kt] = xt[Ft + $t[ht]], kt += Tt;
            }
            var nt = this.V;
            if (ct || Tt !== 4 || nt || (nt = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255])), nt) for (Ct = 0; Ct < Dt; ) for (St = 0, At = 0; St < Tt; St++, Ct++, At += 2) Zt[Ct] = (Zt[Ct] * nt[At] >> 8) + nt[At + 1];
            return Zt;
          }, get f() {
            return this.b ? !!this.b.a : this.p === 3 ? this.N !== 0 && (this.W[0].index !== 82 || this.W[1].index !== 71 || this.W[2].index !== 66) : this.N === 1;
          }, z: function(st) {
            for (var at, ct, K, lt = 0, vt = st.length; lt < vt; lt += 3) at = st[lt], ct = st[lt + 1], K = st[lt + 2], st[lt] = at - 179.456 + 1.402 * K, st[lt + 1] = at + 135.459 - 0.344 * ct - 0.714 * K, st[lt + 2] = at - 226.816 + 1.772 * ct;
            return st;
          }, O: function(st) {
            for (var at, ct, K, lt, vt = 0, dt = 0, ht = st.length; dt < ht; dt += 4) at = st[dt], ct = st[dt + 1], K = st[dt + 2], lt = st[dt + 3], st[vt++] = ct * (-660635669420364e-19 * ct + 437130475926232e-18 * K - 54080610064599e-18 * at + 48449797120281e-17 * lt - 0.154362151871126) - 122.67195406894 + K * (-957964378445773e-18 * K + 817076911346625e-18 * at - 0.00477271405408747 * lt + 1.53380253221734) + at * (961250184130688e-18 * at - 0.00266257332283933 * lt + 0.48357088451265) + lt * (-336197177618394e-18 * lt + 0.484791561490776), st[vt++] = 107.268039397724 + ct * (219927104525741e-19 * ct - 640992018297945e-18 * K + 659397001245577e-18 * at + 426105652938837e-18 * lt - 0.176491792462875) + K * (-778269941513683e-18 * K + 0.00130872261408275 * at + 770482631801132e-18 * lt - 0.151051492775562) + at * (0.00126935368114843 * at - 0.00265090189010898 * lt + 0.25802910206845) + lt * (-318913117588328e-18 * lt - 0.213742400323665), st[vt++] = ct * (-570115196973677e-18 * ct - 263409051004589e-19 * K + 0.0020741088115012 * at - 0.00288260236853442 * lt + 0.814272968359295) - 20.810012546947 + K * (-153496057440975e-19 * K - 132689043961446e-18 * at + 560833691242812e-18 * lt - 0.195152027534049) + at * (0.00174418132927582 * at - 0.00255243321439347 * lt + 0.116935020465145) + lt * (-343531996510555e-18 * lt + 0.24165260232407);
            return st.subarray(0, vt);
          }, r: function(st) {
            for (var at, ct, K, lt = 0, vt = st.length; lt < vt; lt += 4) at = st[lt], ct = st[lt + 1], K = st[lt + 2], st[lt] = 434.456 - at - 1.402 * K, st[lt + 1] = 119.541 - at + 0.344 * ct + 0.714 * K, st[lt + 2] = 481.816 - at - 1.772 * ct;
            return st;
          }, U: function(st) {
            for (var at, ct, K, lt, vt = 0, dt = 0, ht = st.length; dt < ht; dt += 4) at = st[dt], ct = st[dt + 1], K = st[dt + 2], lt = st[dt + 3], st[vt++] = 255 + at * (-6747147073602441e-20 * at + 8379262121013727e-19 * ct + 2894718188643294e-19 * K + 0.003264231057537806 * lt - 1.1185611867203937) + ct * (26374107616089405e-21 * ct - 8626949158638572e-20 * K - 2748769067499491e-19 * lt - 0.02155688794978967) + K * (-3878099212869363e-20 * K - 3267808279485286e-19 * lt + 0.0686742238595345) - lt * (3361971776183937e-19 * lt + 0.7430659151342254), st[vt++] = 255 + at * (13596372813588848e-20 * at + 924537132573585e-18 * ct + 10567359618683593e-20 * K + 4791864687436512e-19 * lt - 0.3109689587515875) + ct * (-23545346108370344e-20 * ct + 2702845253534714e-19 * K + 0.0020200308977307156 * lt - 0.7488052167015494) + K * (6834815998235662e-20 * K + 15168452363460973e-20 * lt - 0.09751927774728933) - lt * (3189131175883281e-19 * lt + 0.7364883807733168), st[vt++] = 255 + at * (13598650411385307e-21 * at + 12423956175490851e-20 * ct + 4751985097583589e-19 * K - 36729317476630422e-22 * lt - 0.05562186980264034) + ct * (16141380598724676e-20 * ct + 9692239130725186e-19 * K + 7782692450036253e-19 * lt - 0.44015232367526463) + K * (5068882914068769e-22 * K + 0.0017778369011375071 * lt - 0.7591454649749609) - lt * (3435319965105553e-19 * lt + 0.7063770186160144);
            return st.subarray(0, vt);
          }, getData: function(st) {
            var at = st.width, ct = st.height, K = st.forceRGB, lt = st.isSourcePDF;
            if (this.p > 4) throw new P("Unsupported color mode");
            var vt = this.Y(at, ct, lt);
            if (this.p === 1 && K) {
              for (var dt = vt.length, ht = new Uint8ClampedArray(3 * dt), pt = 0, Ct = 0; Ct < dt; Ct++) {
                var St = vt[Ct];
                ht[pt++] = St, ht[pt++] = St, ht[pt++] = St;
              }
              return ht;
            }
            if (this.p === 3 && this.f) return this.z(vt);
            if (this.p === 4) {
              if (this.f) return K ? this.O(vt) : this.r(vt);
              if (K) return this.U(vt);
            }
            return vt;
          } }, et;
        }();
        function D(U, Z) {
          return U[Z] << 8 | U[Z + 1];
        }
        w.JpegDecoder = F;
      })(), w.encodeImage = function(P, F, D, U) {
        var Z = { t256: [F], t257: [D], t258: [8, 8, 8, 8], t259: [1], t262: [2], t273: [1e3], t277: [4], t278: [D], t279: [F * D * 4], t282: [[72, 1]], t283: [[72, 1]], t284: [1], t286: [[0, 1]], t287: [[0, 1]], t296: [1], t305: ["Photopea (UTIF.js)"], t338: [1] };
        if (U) for (var $ in U) Z[$] = U[$];
        var j = new Uint8Array(w.encode([Z])), G = new Uint8Array(P), Q = new Uint8Array(1e3 + F * D * 4);
        for ($ = 0; $ < j.length; $++) Q[$] = j[$];
        for ($ = 0; $ < G.length; $++) Q[1e3 + $] = G[$];
        return Q.buffer;
      }, w.encode = function(P) {
        var F = new Uint8Array(2e4), D = 4, U = w._binBE;
        F[0] = F[1] = 77, U.writeUshort(F, 2, 42);
        var Z = 8;
        U.writeUint(F, D, Z), D += 4;
        for (var $ = 0; $ < P.length; $++) {
          var j = w._writeIFD(U, w._types.basic, F, Z, P[$]);
          Z = j[1], $ < P.length - 1 && (3 & Z && (Z += 4 - (3 & Z)), U.writeUint(F, j[0], Z));
        }
        return F.slice(0, Z).buffer;
      }, w.decode = function(P, F) {
        F == null && (F = { parseMN: !0, debug: !1 });
        var D = new Uint8Array(P), U = 0, Z = w._binBE.readASCII(D, U, 2);
        U += 2;
        var $ = Z == "II" ? w._binLE : w._binBE;
        $.readUshort(D, U), U += 2;
        var j = $.readUint(D, U);
        U += 4;
        for (var G = []; ; ) {
          var Q = $.readUshort(D, j), H = $.readUshort(D, j + 4);
          if (Q != 0 && (H < 1 || 13 < H)) {
            g("error in TIFF");
            break;
          }
          if (w._readIFD($, D, j, G, 0, F), (j = $.readUint(D, j + 2 + 12 * Q)) == 0) break;
        }
        return G;
      }, w.decodeImage = function(P, F, D) {
        if (!F.data) {
          var U = new Uint8Array(P), Z = w._binBE.readASCII(U, 0, 2);
          if (F.t256 != null) {
            F.isLE = Z == "II", F.width = F.t256[0], F.height = F.t257[0];
            var $ = F.t259 ? F.t259[0] : 1, j = F.t266 ? F.t266[0] : 1;
            F.t284 && F.t284[0] == 2 && g("PlanarConfiguration 2 should not be used!"), $ == 7 && F.t258 && F.t258.length > 3 && (F.t258 = F.t258.slice(0, 3));
            var G = F.t277 ? F.t277[0] : 1, Q = (F.t258 ? F.t258[0] : 1) * G;
            $ == 1 && F.t279 != null && F.t278 && F.t262[0] == 32803 && (Q = Math.round(8 * F.t279[0] / (F.width * F.t278[0]))), F.t50885 && F.t50885[0] == 4 && (Q = 3 * F.t258[0]);
            var H = 8 * Math.ceil(F.width * Q / 8), W = F.t273;
            (W == null || F.t322) && (W = F.t324);
            var q = F.t279;
            $ == 1 && W.length == 1 && (q = [F.height * (H >>> 3)]), (q == null || F.t322) && (q = F.t325);
            var et = new Uint8Array(F.height * (H >>> 3)), rt = 0;
            if (F.t322 != null) {
              var tt = F.t322[0], V = F.t323[0], X = Math.floor((F.width + tt - 1) / tt), ot = Math.floor((F.height + V - 1) / V), it = new Uint8Array(0 | Math.ceil(tt * V * Q / 8));
              console.log("====", X, ot);
              for (var st = 0; st < ot; st++) for (var at = 0; at < X; at++) {
                var ct = st * X + at;
                it.fill(0), w.decode._decompress(F, D, U, W[ct], q[ct], $, it, 0, j, tt, V), $ == 6 ? et = it : w._copyTile(it, 0 | Math.ceil(tt * Q / 8), V, et, 0 | Math.ceil(F.width * Q / 8), F.height, 0 | Math.ceil(at * tt * Q / 8), st * V);
              }
              rt = 8 * et.length;
            } else {
              if (W == null) return;
              var K = F.t278 ? F.t278[0] : F.height;
              for (K = Math.min(K, F.height), ct = 0; ct < W.length; ct++) w.decode._decompress(F, D, U, W[ct], q[ct], $, et, 0 | Math.ceil(rt / 8), j, F.width, K), rt += H * K;
              rt = Math.min(rt, 8 * et.length);
            }
            F.data = new Uint8Array(et.buffer, 0, 0 | Math.ceil(rt / 8));
          }
        }
      }, w.decode._decompress = function(P, F, D, U, Z, $, j, G, Q, H, W) {
        if (P.t271 && P.t271[0] == "Panasonic" && P.t45 && P.t45[0] == 6 && ($ = 34316), $ == 1) for (var q = 0; q < Z; q++) j[G + q] = D[U + q];
        else if ($ == 2) w.decode._decodeG2(D, U, Z, j, G, H, Q);
        else if ($ == 3) w.decode._decodeG3(D, U, Z, j, G, H, Q, !!P.t292 && !(1 & ~P.t292[0]));
        else if ($ == 4) w.decode._decodeG4(D, U, Z, j, G, H, Q);
        else if ($ == 5) w.decode._decodeLZW(D, U, Z, j, G, 8);
        else if ($ == 6) w.decode._decodeOldJPEG(P, D, U, Z, j, G);
        else if ($ == 7 || $ == 34892) w.decode._decodeNewJPEG(P, D, U, Z, j, G);
        else if ($ == 8 || $ == 32946) {
          var et = new Uint8Array(D.buffer, U + 2, Z - 6), rt = I.inflateRaw(et);
          G + rt.length <= j.length && j.set(rt, G);
        } else $ == 9 ? w.decode._decodeVC5(D, U, Z, j, G, P.t33422) : $ == 32767 ? w.decode._decodeARW(P, D, U, Z, j, G) : $ == 32773 ? w.decode._decodePackBits(D, U, Z, j, G) : $ == 32809 ? w.decode._decodeThunder(D, U, Z, j, G) : $ == 34316 ? w.decode._decodePanasonic(P, D, U, Z, j, G) : $ == 34713 ? w.decode._decodeNikon(P, F, D, U, Z, j, G) : $ == 34676 ? w.decode._decodeLogLuv32(P, D, U, Z, j, G) : g("Unknown compression", $);
        var tt = P.t258 ? Math.min(32, P.t258[0]) : 1, V = P.t277 ? P.t277[0] : 1, X = tt * V >>> 3, ot = Math.ceil(tt * V * H / 8);
        if (tt == 16 && !P.isLE && P.t33422 == null) for (var it = 0; it < W; it++) for (var st = G + it * ot, at = 1; at < ot; at += 2) {
          var ct = j[st + at];
          j[st + at] = j[st + at - 1], j[st + at - 1] = ct;
        }
        if (P.t317 && P.t317[0] == 2) for (it = 0; it < W; it++) {
          var K = G + it * ot;
          if (tt == 16) for (q = X; q < ot; q += 2) {
            var lt = (j[K + q + 1] << 8 | j[K + q]) + (j[K + q - X + 1] << 8 | j[K + q - X]);
            j[K + q] = 255 & lt, j[K + q + 1] = lt >>> 8 & 255;
          }
          else if (V == 3) for (q = 3; q < ot; q += 3) j[K + q] = j[K + q] + j[K + q - 3] & 255, j[K + q + 1] = j[K + q + 1] + j[K + q - 2] & 255, j[K + q + 2] = j[K + q + 2] + j[K + q - 1] & 255;
          else for (q = X; q < ot; q++) j[K + q] = j[K + q] + j[K + q - X] & 255;
        }
      }, w.decode._decodePanasonic = function(P, F, D, U, Z, $) {
        var j, G, Q, H, W, q, et, rt, tt = F.buffer, V = P.t2[0], X = P.t3[0], ot = P.t10[0], it = P.t45[0], st = 0, at = 0, ct = 0, K = 0, lt = it == 6 ? new Uint32Array(18) : new Uint8Array(16), vt = [0, 0], dt = [0, 0], ht = 0, pt = new Uint8Array(16384), Ct = new Uint16Array(Z.buffer);
        function St(Rt) {
          if (ct == 0) {
            var J = new Uint8Array(tt, D + at + 8184, 8200), ut = new Uint8Array(tt, D + at, 8184);
            pt.set(J), pt.set(ut, J.length), at += 16384;
          }
          if (it != 5) return (pt[K = (ct = ct - Rt & 131071) >> 3 ^ 16368] | pt[K + 1] << 8) >> (7 & ct) & ~(-1 << Rt);
          for (j = 0; j < 16; j++) lt[j] = pt[ct++], ct &= 16383;
        }
        function At(Rt) {
          return pt[ct + 15 - Rt];
        }
        function Ft() {
          vt[0] = 0, vt[1] = 0, dt[0] = 0, dt[1] = 0;
        }
        if (it == 7) throw it;
        if (it == 6) {
          var xt = ot == 12, Pt = xt ? function() {
            lt[0] = At(0) << 4 | At(1) >> 4, lt[1] = 4095 & ((15 & At(1)) << 8 | At(2)), lt[2] = At(3) >> 6 & 3, lt[3] = (63 & At(3)) << 2 | At(4) >> 6, lt[4] = (63 & At(4)) << 2 | At(5) >> 6, lt[5] = (63 & At(5)) << 2 | At(6) >> 6, lt[6] = At(6) >> 4 & 3, lt[7] = (15 & At(6)) << 4 | At(7) >> 4, lt[8] = (15 & At(7)) << 4 | At(8) >> 4, lt[9] = (15 & At(8)) << 4 | At(9) >> 4, lt[10] = At(9) >> 2 & 3, lt[11] = (3 & At(9)) << 6 | At(10) >> 2, lt[12] = (3 & At(10)) << 6 | At(11) >> 2, lt[13] = (3 & At(11)) << 6 | At(12) >> 2, lt[14] = 3 & At(12), lt[15] = At(13), lt[16] = At(14), lt[17] = At(15), ct += 16, K = 0;
          } : function() {
            lt[0] = At(0) << 6 | At(1) >> 2, lt[1] = 16383 & ((3 & At(1)) << 12 | At(2) << 4 | At(3) >> 4), lt[2] = At(3) >> 2 & 3, lt[3] = (3 & At(3)) << 8 | At(4), lt[4] = At(5) << 2 | At(6) >> 6, lt[5] = (63 & At(6)) << 4 | At(7) >> 4, lt[6] = At(7) >> 2 & 3, lt[7] = (3 & At(7)) << 8 | At(8), lt[8] = At(9) << 2 & 1020 | At(10) >> 6, lt[9] = 1023 & (At(10) << 4 | At(11) >> 4), lt[10] = At(11) >> 2 & 3, lt[11] = (3 & At(11)) << 8 | At(12), lt[12] = 1023 & (At(13) << 2 & 1020 | At(14) >> 6), lt[13] = 1023 & (At(14) << 4 | At(15) >> 4), ct += 16, K = 0;
          }, Ot = xt ? 14 : 11, Bt = xt ? 128 : 512, kt = xt ? 2048 : 8192, Tt = xt ? 16383 : 65535, Dt = xt ? 4095 : 16383, Zt = V / Ot, $t = 16 * Zt, Mt = xt ? 18 : 14;
          for (q = 0; q < X - 15; q += 16) {
            var nt = Math.min(16, X - q), It = $t * nt;
            for (pt = new Uint8Array(tt, D + st, It), ct = 0, st += It, rt = 0, et = 0; rt < nt; rt++, et = 0) {
              ht = (q + rt) * V;
              for (var mt = 0; mt < Zt; mt++) for (Pt(), Ft(), Q = 0, W = 0, j = 0; j < Ot; j++) {
                if (H = 1 & j, j % 3 == 2) {
                  var gt = K < Mt ? lt[K++] : 0;
                  gt == 3 && (gt = 4), W = Bt << gt, Q = 1 << gt;
                }
                var _t = K < Mt ? lt[K++] : 0;
                vt[H] ? (_t *= Q, W < kt && dt[H] > W && (_t += dt[H] - W), dt[H] = _t) : (vt[H] = _t, _t ? dt[H] = _t : _t = dt[H]), Ct[ht + et++] = _t - 15 <= Tt ? _t - 15 & Tt : _t + 2147483633 >> 31 & Dt;
              }
            }
          }
        } else if (it == 5) {
          var wt = ot == 12 ? 10 : 9;
          for (q = 0; q < X; q++) for (et = 0; et < V; et += wt) St(0), ot == 12 ? (Ct[ht++] = ((15 & lt[1]) << 8) + lt[0], Ct[ht++] = 16 * lt[2] + (lt[1] >> 4), Ct[ht++] = ((15 & lt[4]) << 8) + lt[3], Ct[ht++] = 16 * lt[5] + (lt[4] >> 4), Ct[ht++] = ((15 & lt[7]) << 8) + lt[6], Ct[ht++] = 16 * lt[8] + (lt[7] >> 4), Ct[ht++] = ((15 & lt[10]) << 8) + lt[9], Ct[ht++] = 16 * lt[11] + (lt[10] >> 4), Ct[ht++] = ((15 & lt[13]) << 8) + lt[12], Ct[ht++] = 16 * lt[14] + (lt[13] >> 4)) : ot == 14 && (Ct[ht++] = lt[0] + ((63 & lt[1]) << 8), Ct[ht++] = (lt[1] >> 6) + 4 * lt[2] + ((15 & lt[3]) << 10), Ct[ht++] = (lt[3] >> 4) + 16 * lt[4] + ((3 & lt[5]) << 12), Ct[ht++] = ((252 & lt[5]) >> 2) + (lt[6] << 6), Ct[ht++] = lt[7] + ((63 & lt[8]) << 8), Ct[ht++] = (lt[8] >> 6) + 4 * lt[9] + ((15 & lt[10]) << 10), Ct[ht++] = (lt[10] >> 4) + 16 * lt[11] + ((3 & lt[12]) << 12), Ct[ht++] = ((252 & lt[12]) >> 2) + (lt[13] << 6), Ct[ht++] = lt[14] + ((63 & lt[15]) << 8));
        } else {
          if (it != 4) throw it;
          for (q = 0; q < X; q++) for (et = 0; et < V; et++) H = 1 & (j = et % 14), j == 0 && Ft(), j % 3 == 2 && (Q = 4 >> 3 - St(2)), dt[H] ? (G = St(8)) != 0 && (vt[H] -= 128 << Q, (vt[H] < 0 || Q == 4) && (vt[H] &= ~(-1 << Q)), vt[H] += G << Q) : (dt[H] = St(8), (dt[H] || j > 11) && (vt[H] = dt[H] << 4 | St(4))), Ct[ht++] = vt[1 & et];
        }
      }, w.decode._decodeVC5 = /* @__PURE__ */ function() {
        var P, F, D, U = [1, 0, 1, 0, 2, 2, 1, 1, 3, 7, 1, 2, 5, 25, 1, 3, 6, 48, 1, 4, 6, 54, 1, 5, 7, 111, 1, 8, 7, 99, 1, 6, 7, 105, 12, 0, 7, 107, 1, 7, 8, 209, 20, 0, 8, 212, 1, 9, 8, 220, 1, 10, 9, 393, 1, 11, 9, 394, 32, 0, 9, 416, 1, 12, 9, 427, 1, 13, 10, 887, 1, 18, 10, 784, 1, 14, 10, 790, 1, 15, 10, 835, 60, 0, 10, 852, 1, 16, 10, 885, 1, 17, 11, 1571, 1, 19, 11, 1668, 1, 20, 11, 1669, 100, 0, 11, 1707, 1, 21, 11, 1772, 1, 22, 12, 3547, 1, 29, 12, 3164, 1, 24, 12, 3166, 1, 25, 12, 3140, 1, 23, 12, 3413, 1, 26, 12, 3537, 1, 27, 12, 3539, 1, 28, 13, 7093, 1, 35, 13, 6283, 1, 30, 13, 6331, 1, 31, 13, 6335, 180, 0, 13, 6824, 1, 32, 13, 7072, 1, 33, 13, 7077, 320, 0, 13, 7076, 1, 34, 14, 12565, 1, 36, 14, 12661, 1, 37, 14, 12669, 1, 38, 14, 13651, 1, 39, 14, 14184, 1, 40, 15, 28295, 1, 46, 15, 28371, 1, 47, 15, 25320, 1, 42, 15, 25336, 1, 43, 15, 25128, 1, 41, 15, 27300, 1, 44, 15, 28293, 1, 45, 16, 50259, 1, 48, 16, 50643, 1, 49, 16, 50675, 1, 50, 16, 56740, 1, 53, 16, 56584, 1, 51, 16, 56588, 1, 52, 17, 113483, 1, 61, 17, 113482, 1, 60, 17, 101285, 1, 55, 17, 101349, 1, 56, 17, 109205, 1, 57, 17, 109207, 1, 58, 17, 100516, 1, 54, 17, 113171, 1, 59, 18, 202568, 1, 62, 18, 202696, 1, 63, 18, 218408, 1, 64, 18, 218412, 1, 65, 18, 226340, 1, 66, 18, 226356, 1, 67, 18, 226358, 1, 68, 19, 402068, 1, 69, 19, 405138, 1, 70, 19, 405394, 1, 71, 19, 436818, 1, 72, 19, 436826, 1, 73, 19, 452714, 1, 75, 19, 452718, 1, 76, 19, 452682, 1, 74, 20, 804138, 1, 77, 20, 810279, 1, 78, 20, 810790, 1, 79, 20, 873638, 1, 80, 20, 873654, 1, 81, 20, 905366, 1, 82, 20, 905430, 1, 83, 20, 905438, 1, 84, 21, 1608278, 1, 85, 21, 1620557, 1, 86, 21, 1621582, 1, 87, 21, 1621583, 1, 88, 21, 1747310, 1, 89, 21, 1810734, 1, 90, 21, 1810735, 1, 91, 21, 1810863, 1, 92, 21, 1810879, 1, 93, 22, 3621725, 1, 99, 22, 3621757, 1, 100, 22, 3241112, 1, 94, 22, 3494556, 1, 95, 22, 3494557, 1, 96, 22, 3494622, 1, 97, 22, 3494623, 1, 98, 23, 6482227, 1, 102, 23, 6433117, 1, 101, 23, 6989117, 1, 103, 23, 6989119, 1, 105, 23, 6989118, 1, 104, 23, 7243449, 1, 106, 23, 7243512, 1, 107, 24, 13978233, 1, 111, 24, 12964453, 1, 109, 24, 12866232, 1, 108, 24, 14486897, 1, 113, 24, 13978232, 1, 110, 24, 14486896, 1, 112, 24, 14487026, 1, 114, 24, 14487027, 1, 115, 25, 25732598, 1, 225, 25, 25732597, 1, 189, 25, 25732596, 1, 188, 25, 25732595, 1, 203, 25, 25732594, 1, 202, 25, 25732593, 1, 197, 25, 25732592, 1, 207, 25, 25732591, 1, 169, 25, 25732590, 1, 223, 25, 25732589, 1, 159, 25, 25732522, 1, 235, 25, 25732579, 1, 152, 25, 25732575, 1, 192, 25, 25732489, 1, 179, 25, 25732573, 1, 201, 25, 25732472, 1, 172, 25, 25732576, 1, 149, 25, 25732488, 1, 178, 25, 25732566, 1, 120, 25, 25732571, 1, 219, 25, 25732577, 1, 150, 25, 25732487, 1, 127, 25, 25732506, 1, 211, 25, 25732548, 1, 125, 25, 25732588, 1, 158, 25, 25732486, 1, 247, 25, 25732467, 1, 238, 25, 25732508, 1, 163, 25, 25732552, 1, 228, 25, 25732603, 1, 183, 25, 25732513, 1, 217, 25, 25732587, 1, 168, 25, 25732520, 1, 122, 25, 25732484, 1, 128, 25, 25732562, 1, 249, 25, 25732505, 1, 187, 25, 25732504, 1, 186, 25, 25732483, 1, 136, 25, 25928905, 1, 181, 25, 25732560, 1, 255, 25, 25732500, 1, 230, 25, 25732482, 1, 135, 25, 25732555, 1, 233, 25, 25732568, 1, 222, 25, 25732583, 1, 145, 25, 25732481, 1, 134, 25, 25732586, 1, 167, 25, 25732521, 1, 248, 25, 25732518, 1, 209, 25, 25732480, 1, 243, 25, 25732512, 1, 216, 25, 25732509, 1, 164, 25, 25732547, 1, 140, 25, 25732479, 1, 157, 25, 25732544, 1, 239, 25, 25732574, 1, 191, 25, 25732564, 1, 251, 25, 25732478, 1, 156, 25, 25732546, 1, 139, 25, 25732498, 1, 242, 25, 25732557, 1, 133, 25, 25732477, 1, 162, 25, 25732515, 1, 213, 25, 25732584, 1, 165, 25, 25732514, 1, 212, 25, 25732476, 1, 227, 25, 25732494, 1, 198, 25, 25732531, 1, 236, 25, 25732530, 1, 234, 25, 25732529, 1, 117, 25, 25732528, 1, 215, 25, 25732527, 1, 124, 25, 25732526, 1, 123, 25, 25732525, 1, 254, 25, 25732524, 1, 253, 25, 25732523, 1, 148, 25, 25732570, 1, 218, 25, 25732580, 1, 146, 25, 25732581, 1, 147, 25, 25732569, 1, 224, 25, 25732533, 1, 143, 25, 25732540, 1, 184, 25, 25732541, 1, 185, 25, 25732585, 1, 166, 25, 25732556, 1, 132, 25, 25732485, 1, 129, 25, 25732563, 1, 250, 25, 25732578, 1, 151, 25, 25732501, 1, 119, 25, 25732502, 1, 193, 25, 25732536, 1, 176, 25, 25732496, 1, 245, 25, 25732553, 1, 229, 25, 25732516, 1, 206, 25, 25732582, 1, 144, 25, 25732517, 1, 208, 25, 25732558, 1, 137, 25, 25732543, 1, 241, 25, 25732466, 1, 237, 25, 25732507, 1, 190, 25, 25732542, 1, 240, 25, 25732551, 1, 131, 25, 25732554, 1, 232, 25, 25732565, 1, 252, 25, 25732475, 1, 171, 25, 25732493, 1, 205, 25, 25732492, 1, 204, 25, 25732491, 1, 118, 25, 25732490, 1, 214, 25, 25928904, 1, 180, 25, 25732549, 1, 126, 25, 25732602, 1, 182, 25, 25732539, 1, 175, 25, 25732545, 1, 141, 25, 25732559, 1, 138, 25, 25732537, 1, 177, 25, 25732534, 1, 153, 25, 25732503, 1, 194, 25, 25732606, 1, 160, 25, 25732567, 1, 121, 25, 25732538, 1, 174, 25, 25732497, 1, 246, 25, 25732550, 1, 130, 25, 25732572, 1, 200, 25, 25732474, 1, 170, 25, 25732511, 1, 221, 25, 25732601, 1, 196, 25, 25732532, 1, 142, 25, 25732519, 1, 210, 25, 25732495, 1, 199, 25, 25732605, 1, 155, 25, 25732535, 1, 154, 25, 25732499, 1, 244, 25, 25732510, 1, 220, 25, 25732600, 1, 195, 25, 25732607, 1, 161, 25, 25732604, 1, 231, 25, 25732473, 1, 173, 25, 25732599, 1, 226, 26, 51465122, 1, 116, 26, 51465123, 0, 1], Z = [3, 3, 3, 3, 2, 2, 2, 1, 1, 1];
        function $(rt) {
          var tt = rt[1], V = rt[0][tt >>> 3] >>> 7 - (7 & tt) & 1;
          return rt[1]++, V;
        }
        function j(rt, tt) {
          if (P == null) {
            P = {};
            for (var V = 0; V < U.length; V += 4) P[U[V + 1]] = U.slice(V, V + 4);
          }
          for (var X = $(rt), ot = P[X]; ot == null; ) X = X << 1 | $(rt), ot = P[X];
          var it = ot[3];
          it != 0 && (it = $(rt) == 0 ? it : -it), tt[0] = ot[2], tt[1] = it;
        }
        function G(rt, tt) {
          for (var V = 0; V < tt; V++) 1 & ~rt || rt++, rt >>>= 1;
          return rt;
        }
        function Q(rt, tt) {
          return rt >> tt;
        }
        function H(rt, tt, V, X, ot, it) {
          tt[V] = Q(Q(11 * rt[ot] - 4 * rt[ot + it] + rt[ot + it + it] + 4, 3) + rt[X], 1), tt[V + it] = Q(Q(5 * rt[ot] + 4 * rt[ot + it] - rt[ot + it + it] + 4, 3) - rt[X], 1);
        }
        function W(rt, tt, V, X, ot, it) {
          var st = rt[ot - it] - rt[ot + it], at = rt[ot], ct = rt[X];
          tt[V] = Q(Q(st + 4, 3) + at + ct, 1), tt[V + it] = Q(Q(4 - st, 3) + at - ct, 1);
        }
        function q(rt, tt, V, X, ot, it) {
          tt[V] = Q(Q(5 * rt[ot] + 4 * rt[ot - it] - rt[ot - it - it] + 4, 3) + rt[X], 1), tt[V + it] = Q(Q(11 * rt[ot] - 4 * rt[ot - it] + rt[ot - it - it] + 4, 3) - rt[X], 1);
        }
        function et(rt) {
          return rt = D[rt = rt < 0 ? 0 : rt > 4095 ? 4095 : rt] >>> 2;
        }
        return function(rt, tt, V, X, ot, it) {
          X = new Uint16Array(X.buffer);
          var st, at, ct, K, lt, vt, dt, ht, pt = Date.now(), Ct = w._binBE, St = tt + V;
          tt += 4;
          for (var At = it[0] == 1; tt < St; ) {
            var Ft = Ct.readShort(rt, tt), xt = Ct.readUshort(rt, tt + 2);
            if (tt += 4, Ft == 12) Zt = xt;
            else if (Ft == 20) st = xt;
            else if (Ft == 21) at = xt;
            else if (Ft == 48) ct = xt;
            else if (Ft == 53) K = xt;
            else if (Ft != 35) {
              if (Ft == 62) lt = xt;
              else if (Ft != 101) {
                if (Ft == 109) vt = xt;
                else if (Ft != 84) {
                  if (Ft != 106) {
                    if (Ft != 107) {
                      if (Ft != 108) {
                        if (Ft != 102) {
                          if (Ft == 104) Jt = xt;
                          else if (Ft != 105) {
                            var Pt = Ft < 0 ? -Ft : Ft, Ot = 65280 & Pt, Bt = 0;
                            if (24576 & Pt && (8192 & Pt ? (Bt = 65535 & xt, Bt += (255 & Pt) << 16) : Bt = 65535 & xt), 24576 & ~Pt) {
                              if (Pt == 16388) tt += 4 * Bt;
                              else if (Ot != 8192 && Ot != 8448 && Ot != 9216) throw Pt.toString(16);
                            } else {
                              if (dt == null) {
                                dt = [];
                                for (var kt = 0; kt < 4; kt++) dt[kt] = new Int16Array((st >>> 1) * (at >>> 1));
                                for (ht = new Int16Array((st >>> 1) * (at >>> 1)), F = new Int16Array(1024), kt = 0; kt < 1024; kt++) {
                                  var Tt = kt - 512, Dt = Math.abs(Tt), Zt = Math.floor(768 * Dt * Dt * Dt / 16581375) + Dt;
                                  F[kt] = Math.sign(Tt) * Zt;
                                }
                                for (D = new Uint16Array(4096), kt = 0; kt < 4096; kt++) {
                                  var $t = kt, Mt = 65535 * (Math.pow(113, $t / 4095) - 1) / 112;
                                  D[kt] = Math.min(Mt, 65535);
                                }
                              }
                              var nt = dt[lt], It = G(st, 1 + Z[ct]), mt = G(at, 1 + Z[ct]);
                              if (ct == 0) for (var gt = 0; gt < mt; gt++) for (var _t = 0; _t < It; _t++) {
                                var wt = tt + 2 * (gt * It + _t);
                                nt[gt * (st >>> 1) + _t] = rt[wt] << 8 | rt[wt + 1];
                              }
                              else {
                                var Rt = [rt, 8 * tt], J = [], ut = 0, bt = It * mt, yt = [0, 0], Lt = 0;
                                for (xt = 0; ut < bt; ) for (j(Rt, yt), Lt = yt[0], xt = yt[1]; Lt > 0; ) J[ut++] = xt, Lt--;
                                var jt = (ct - 1) % 3, Kt = jt != 1 ? It : 0, te = jt != 0 ? mt : 0;
                                for (gt = 0; gt < mt; gt++) {
                                  var Vt = (gt + te) * (st >>> 1) + Kt, ee = gt * It;
                                  for (_t = 0; _t < It; _t++) nt[Vt + _t] = F[J[ee + _t] + 512] * K;
                                }
                                if (jt == 2) {
                                  var Jt = st >>> 1, le = 2 * It, ae = 2 * mt;
                                  for (gt = 0; gt < mt; gt++) for (_t = 0; _t < le; _t++) {
                                    kt = 2 * gt * Jt + _t;
                                    var se = mt * Jt + (ne = gt * Jt + _t);
                                    gt == 0 ? H(nt, ht, kt, se, ne, Jt) : gt == mt - 1 ? q(nt, ht, kt, se, ne, Jt) : W(nt, ht, kt, se, ne, Jt);
                                  }
                                  var fe = nt;
                                  for (nt = ht, ht = fe, gt = 0; gt < ae; gt++) for (_t = 0; _t < It; _t++) {
                                    var ne;
                                    kt = gt * Jt + 2 * _t, se = It + (ne = gt * Jt + _t), _t == 0 ? H(nt, ht, kt, se, ne, 1) : _t == It - 1 ? q(nt, ht, kt, se, ne, 1) : W(nt, ht, kt, se, ne, 1);
                                  }
                                  fe = nt, nt = ht, ht = fe;
                                  for (var Nt = [], Xt = 2 - ~~((ct - 1) / 3), Ut = 0; Ut < 3; Ut++) Nt[Ut] = vt >> 14 - 2 * Ut & 3;
                                  var Wt = Nt[Xt];
                                  if (Wt != 0) for (gt = 0; gt < ae; gt++) for (_t = 0; _t < le; _t++)
                                    nt[kt = gt * Jt + _t] = nt[kt] << Wt;
                                }
                              }
                              if (ct == 9 && lt == 3) {
                                var Et = dt[0], Yt = dt[1], ce = dt[2], ft = dt[3];
                                for (gt = 0; gt < at; gt += 2) for (_t = 0; _t < st; _t += 2) {
                                  var qt = gt * st + _t, Gt = Et[wt = (gt >>> 1) * (st >>> 1) + (_t >>> 1)], zt = Yt[wt] - 2048, Qt = ce[wt] - 2048, Ht = ft[wt] - 2048, ue = (zt << 1) + Gt, ie = (Qt << 1) + Gt, oe = Gt + Ht, he = Gt - Ht;
                                  At ? (X[qt] = et(oe), X[qt + 1] = et(ie), X[qt + st] = et(ue), X[qt + st + 1] = et(he)) : (X[qt] = et(ue), X[qt + 1] = et(oe), X[qt + st] = et(he), X[qt + st + 1] = et(ie));
                                }
                              }
                              tt += 4 * Bt;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          console.log(Date.now() - pt);
        };
      }(), w.decode._decodeLogLuv32 = function(P, F, D, U, Z, $) {
        for (var j = P.width, G = 4 * j, Q = 0, H = new Uint8Array(G); Q < U; ) {
          for (var W = 0; W < G; ) {
            var q = F[D + Q];
            if (Q++, q < 128) {
              for (var et = 0; et < q; et++) H[W + et] = F[D + Q + et];
              W += q, Q += q;
            } else {
              for (q -= 126, et = 0; et < q; et++) H[W + et] = F[D + Q];
              W += q, Q++;
            }
          }
          for (var rt = 0; rt < j; rt++) Z[$ + 0] = H[rt], Z[$ + 1] = H[rt + j], Z[$ + 2] = H[rt + 2 * j], Z[$ + 4] = H[rt + 3 * j], $ += 6;
        }
      }, w.decode._ljpeg_diff = function(P, F, D) {
        var U, Z, $ = w.decode._getbithuff;
        return U = $(P, F, D[0], D), (Z = $(P, F, U, 0)) & 1 << U - 1 || (Z -= (1 << U) - 1), Z;
      }, w.decode._decodeARW = function(P, F, D, U, Z, $) {
        var j = P.t256[0], G = P.t257[0], Q = P.t258[0], H = P.isLE ? w._binLE : w._binBE;
        if (j * G == U || j * G * 1.5 == U) if (j * G * 1.5 != U) {
          var W, q, et, rt, tt, V, X, ot, it = new Uint16Array(16), st = new Uint8Array(j + 1);
          for (pt = 0; pt < G; pt++) {
            for (var at = 0; at < j; at++) st[at] = F[D++];
            for (ot = 0, ht = 0; ht < j - 30; ot += 16) {
              for (q = 2047 & (W = H.readUint(st, ot)), et = 2047 & W >>> 11, rt = 15 & W >>> 22, tt = 15 & W >>> 26, V = 0; V < 4 && 128 << V <= q - et; V++) ;
              for (X = 30, ct = 0; ct < 16; ct++) ct == rt ? it[ct] = q : ct == tt ? it[ct] = et : (it[ct] = ((H.readUshort(st, ot + (X >> 3)) >>> (7 & X) & 127) << V) + et, it[ct] > 2047 && (it[ct] = 2047), X += 7);
              for (ct = 0; ct < 16; ct++, ht += 2)
                Bt = it[ct] << 1, w.decode._putsF(Z, (pt * j + ht) * Q, Bt << 16 - Q);
              ht -= 1 & ht ? 1 : 31;
            }
          }
        } else for (var ct = 0; ct < U; ct += 3) {
          var K = F[D + ct + 0], lt = F[D + ct + 1], vt = F[D + ct + 2];
          Z[$ + ct] = lt << 4 | K >>> 4, Z[$ + ct + 1] = K << 4 | vt >>> 4, Z[$ + ct + 2] = vt << 4 | lt >>> 4;
        }
        else {
          G += 8;
          var dt, ht, pt, Ct = [D, 0, 0, 0], St = new Uint16Array(32770), At = [3857, 3856, 3599, 3342, 3085, 2828, 2571, 2314, 2057, 1800, 1543, 1286, 1029, 772, 771, 768, 514, 513], Ft = 0, xt = w.decode._ljpeg_diff;
          for (St[0] = 15, dt = ct = 0; ct < 18; ct++) for (var Pt = 32768 >>> (At[ct] >>> 8), Ot = 0; Ot < Pt; Ot++) St[++dt] = At[ct];
          for (ht = j; ht--; ) for (pt = 0; pt < G + 1; pt += 2) if (pt == G && (pt = 1), Ft += xt(F, Ct, St), pt < G) {
            var Bt = 4095 & Ft;
            w.decode._putsF(Z, (pt * j + ht) * Q, Bt << 16 - Q);
          }
        }
      }, w.decode._decodeNikon = function(P, F, D, U, Z, $, j) {
        var G = [[0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 5, 4, 3, 6, 2, 7, 1, 0, 8, 9, 11, 10, 12], [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 57, 90, 56, 39, 22, 5, 4, 3, 2, 1, 0, 11, 12, 12], [0, 0, 1, 4, 2, 3, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 6, 3, 7, 2, 8, 1, 9, 0, 10, 11, 12], [0, 0, 1, 4, 3, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 5, 6, 4, 7, 8, 3, 9, 2, 1, 0, 10, 11, 12, 13, 14], [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 8, 92, 75, 58, 41, 7, 6, 5, 4, 3, 2, 1, 0, 13, 14], [0, 0, 1, 4, 2, 2, 3, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 8, 5, 9, 4, 10, 3, 11, 12, 2, 0, 1, 13, 14]], Q = P.t256[0], H = P.t257[0], W = P.t258[0], q = 0, et = 0, rt = w.decode._make_decoder, tt = w.decode._getbithuff, V = F[0].exifIFD.makerNote, X = V.t150 ? V.t150 : V.t140, ot = 0, it = X[ot++], st = X[ot++];
        it != 73 && st != 88 || (ot += 2110), it == 70 && (q = 2), W == 14 && (q += 3);
        for (var at = [[0, 0], [0, 0]], ct = P.isLE ? w._binLE : w._binBE, K = 0; K < 2; K++) for (var lt = 0; lt < 2; lt++) at[K][lt] = ct.readShort(X, ot), ot += 2;
        var vt, dt, ht, pt, Ct, St = 1 << W & 32767, At = 0, Ft = ct.readShort(X, ot);
        ot += 2, Ft > 1 && (At = Math.floor(St / (Ft - 1))), it == 68 && st == 32 && At > 0 && (et = ct.readShort(X, 562));
        var xt = [0, 0], Pt = rt(G[q]), Ot = [U, 0, 0, 0];
        for (vt = 0; vt < H; vt++) for (et && vt == et && (Pt = rt(G[q + 1])), dt = 0; dt < Q; dt++) {
          K = tt(D, Ot, Pt[0], Pt), (Ct = 1 + (tt(D, Ot, (ht = 15 & K) - (pt = K >>> 4), 0) << 1) << pt >>> 1) & 1 << ht - 1 || (Ct -= (1 << ht) - (pt == 0 ? 1 : 0)), dt < 2 ? xt[dt] = at[1 & vt][dt] += Ct : xt[1 & dt] += Ct;
          var Bt = Math.min(Math.max(xt[1 & dt], 0), (1 << W) - 1), kt = (vt * Q + dt) * W;
          w.decode._putsF($, kt, Bt << 16 - W);
        }
      }, w.decode._putsF = function(P, F, D) {
        D <<= 8 - (7 & F);
        var U = F >>> 3;
        P[U] |= D >>> 16, P[U + 1] |= D >>> 8, P[U + 2] |= D;
      }, w.decode._getbithuff = function(P, F, D, U) {
        var Z;
        w.decode._get_byte;
        var $ = F[0], j = F[1], G = F[2], Q = F[3];
        if (D == 0 || G < 0) return 0;
        for (; !Q && G < D && (Z = P[$++]) != -1 && !(Q = 0); ) j = (j << 8) + Z, G += 8;
        if (Z = j << 32 - G >>> 32 - D, U ? (G -= U[Z + 1] >>> 8, Z = 255 & U[Z + 1]) : G -= D, G < 0) throw "e";
        return F[0] = $, F[1] = j, F[2] = G, F[3] = Q, Z;
      }, w.decode._make_decoder = function(P) {
        var F, D, U, Z, $, j = [];
        for (F = 16; F != 0 && !P[F]; F--) ;
        var G = 17;
        for (j[0] = F, U = D = 1; D <= F; D++) for (Z = 0; Z < P[D]; Z++, ++G) for ($ = 0; $ < 1 << F - D; $++) U <= 1 << F && (j[U++] = D << 8 | P[G]);
        return j;
      }, w.decode._decodeNewJPEG = function(P, F, D, U, Z, $) {
        U = Math.min(U, F.length - D);
        var j = P.t347, G = j ? j.length : 0, Q = new Uint8Array(G + U);
        if (j) {
          for (var H = 0, W = 0; W < G - 1 && (j[W] != 255 || j[W + 1] != 217); W++) Q[H++] = j[W];
          var q = F[D], et = F[D + 1];
          for (q == 255 && et == 216 || (Q[H++] = q, Q[H++] = et), W = 2; W < U; W++) Q[H++] = F[D + W];
        } else for (W = 0; W < U; W++) Q[W] = F[D + W];
        if (P.t262[0] == 32803 || P.t259[0] == 7 && P.t262[0] == 34892) {
          var rt = P.t258[0], tt = w.LosslessJpegDecode(Q), V = tt.length;
          if (rt == 16) if (P.isLE) for (W = 0; W < V; W++) Z[$ + (W << 1)] = 255 & tt[W], Z[$ + (W << 1) + 1] = tt[W] >>> 8;
          else for (W = 0; W < V; W++) Z[$ + (W << 1)] = tt[W] >>> 8, Z[$ + (W << 1) + 1] = 255 & tt[W];
          else if (rt == 14 || rt == 12 || rt == 10) {
            var X = 16 - rt;
            for (W = 0; W < V; W++) w.decode._putsF(Z, W * rt, tt[W] << X);
          } else {
            if (rt != 8) throw new Error("unsupported bit depth " + rt);
            for (W = 0; W < V; W++) Z[$ + W] = tt[W];
          }
        } else {
          var ot = new w.JpegDecoder();
          ot.parse(Q);
          var it = ot.getData({ width: ot.width, height: ot.height, forceRGB: !0, isSourcePDF: !1 });
          for (W = 0; W < it.length; W++) Z[$ + W] = it[W];
        }
        P.t262[0] == 6 && (P.t262[0] = 2);
      }, w.decode._decodeOldJPEGInit = function(P, F, D, U) {
        var Z, $, j, G, Q, H = 216, W = 0, q = 0, et = !1, rt = P.t513, tt = rt ? rt[0] : 0, V = P.t514, X = V ? V[0] : 0, ot = P.t324 || P.t273 || rt, it = P.t530, st = 0, at = 0, ct = P.t277 ? P.t277[0] : 1, K = P.t515;
        if (ot && (q = ot[0], et = ot.length > 1), !et) {
          if (F[D] == 255 && F[D + 1] == H) return { jpegOffset: D };
          if (rt != null && (F[D + tt] == 255 && F[D + tt + 1] == H ? W = D + tt : g("JPEGInterchangeFormat does not point to SOI"), V == null ? g("JPEGInterchangeFormatLength field is missing") : (tt >= q || tt + X <= q) && g("JPEGInterchangeFormatLength field value is invalid"), W != null)) return { jpegOffset: W };
        }
        if (it != null && (st = it[0], at = it[1]), rt != null && V != null) if (X >= 2 && tt + X <= q) {
          for (Z = F[D + tt + X - 2] == 255 && F[D + tt + X - 1] == H ? new Uint8Array(X - 2) : new Uint8Array(X), j = 0; j < Z.length; j++) Z[j] = F[D + tt + j];
          g("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
        } else g("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");
        if (Z == null) {
          var lt = 0, vt = [];
          vt[lt++] = 255, vt[lt++] = H;
          var dt = P.t519;
          if (dt == null) throw new Error("JPEGQTables tag is missing");
          for (j = 0; j < dt.length; j++) for (vt[lt++] = 255, vt[lt++] = 219, vt[lt++] = 0, vt[lt++] = 67, vt[lt++] = j, G = 0; G < 64; G++) vt[lt++] = F[D + dt[j] + G];
          for (Q = 0; Q < 2; Q++) {
            var ht = P[Q == 0 ? "t520" : "t521"];
            if (ht == null) throw new Error((Q == 0 ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
            for (j = 0; j < ht.length; j++) {
              vt[lt++] = 255, vt[lt++] = 196;
              var pt = 19;
              for (G = 0; G < 16; G++) pt += F[D + ht[j] + G];
              for (vt[lt++] = pt >>> 8, vt[lt++] = 255 & pt, vt[lt++] = j | Q << 4, G = 0; G < 16; G++) vt[lt++] = F[D + ht[j] + G];
              for (G = 0; G < pt; G++) vt[lt++] = F[D + ht[j] + 16 + G];
            }
          }
          if (vt[lt++] = 255, vt[lt++] = 192, vt[lt++] = 0, vt[lt++] = 8 + 3 * ct, vt[lt++] = 8, vt[lt++] = P.height >>> 8 & 255, vt[lt++] = 255 & P.height, vt[lt++] = P.width >>> 8 & 255, vt[lt++] = 255 & P.width, vt[lt++] = ct, ct == 1) vt[lt++] = 1, vt[lt++] = 17, vt[lt++] = 0;
          else for (j = 0; j < 3; j++) vt[lt++] = j + 1, vt[lt++] = j != 0 ? 17 : (15 & st) << 4 | 15 & at, vt[lt++] = j;
          K != null && K[0] != 0 && (vt[lt++] = 255, vt[lt++] = 221, vt[lt++] = 0, vt[lt++] = 4, vt[lt++] = K[0] >>> 8 & 255, vt[lt++] = 255 & K[0]), Z = new Uint8Array(vt);
        }
        var Ct = -1;
        for (j = 0; j < Z.length - 1; ) {
          if (Z[j] == 255 && Z[j + 1] == 192) {
            Ct = j;
            break;
          }
          j++;
        }
        if (Ct == -1) {
          var St = new Uint8Array(Z.length + 10 + 3 * ct);
          St.set(Z);
          var At = Z.length;
          if (Ct = Z.length, (Z = St)[At++] = 255, Z[At++] = 192, Z[At++] = 0, Z[At++] = 8 + 3 * ct, Z[At++] = 8, Z[At++] = P.height >>> 8 & 255, Z[At++] = 255 & P.height, Z[At++] = P.width >>> 8 & 255, Z[At++] = 255 & P.width, Z[At++] = ct, ct == 1) Z[At++] = 1, Z[At++] = 17, Z[At++] = 0;
          else for (j = 0; j < 3; j++) Z[At++] = j + 1, Z[At++] = j != 0 ? 17 : (15 & st) << 4 | 15 & at, Z[At++] = j;
        }
        if (F[q] == 255 && F[q + 1] == 218) {
          var Ft = F[q + 2] << 8 | F[q + 3];
          for (($ = new Uint8Array(Ft + 2))[0] = F[q], $[1] = F[q + 1], $[2] = F[q + 2], $[3] = F[q + 3], j = 0; j < Ft - 2; j++) $[j + 4] = F[q + j + 4];
        } else {
          var xt = 0;
          if (($ = new Uint8Array(8 + 2 * ct))[xt++] = 255, $[xt++] = 218, $[xt++] = 0, $[xt++] = 6 + 2 * ct, $[xt++] = ct, ct == 1) $[xt++] = 1, $[xt++] = 0;
          else for (j = 0; j < 3; j++) $[xt++] = j + 1, $[xt++] = j << 4 | j;
          $[xt++] = 0, $[xt++] = 63, $[xt++] = 0;
        }
        return { jpegOffset: D, tables: Z, sosMarker: $, sofPosition: Ct };
      }, w.decode._decodeOldJPEG = function(P, F, D, U, Z, $) {
        var j, G, Q, H, W = w.decode._decodeOldJPEGInit(P, F, D, U);
        if (W.jpegOffset != null) for (j = D + U - W.jpegOffset, Q = new Uint8Array(j), rt = 0; rt < j; rt++) Q[rt] = F[W.jpegOffset + rt];
        else {
          for (G = W.tables.length, (Q = new Uint8Array(G + W.sosMarker.length + U + 2)).set(W.tables), H = G, Q[W.sofPosition + 5] = P.height >>> 8 & 255, Q[W.sofPosition + 6] = 255 & P.height, Q[W.sofPosition + 7] = P.width >>> 8 & 255, Q[W.sofPosition + 8] = 255 & P.width, F[D] == 255 && F[D + 1] == SOS || (Q.set(W.sosMarker, H), H += sosMarker.length), rt = 0; rt < U; rt++) Q[H++] = F[D + rt];
          Q[H++] = 255, Q[H++] = EOI;
        }
        var q = new w.JpegDecoder();
        q.parse(Q);
        for (var et = q.getData({ width: q.width, height: q.height, forceRGB: !0, isSourcePDF: !1 }), rt = 0; rt < et.length; rt++) Z[$ + rt] = et[rt];
        P.t262 && P.t262[0] == 6 && (P.t262[0] = 2);
      }, w.decode._decodePackBits = function(P, F, D, U, Z) {
        for (var $ = new Int8Array(P.buffer), j = new Int8Array(U.buffer), G = F + D; F < G; ) {
          var Q = $[F];
          if (F++, Q >= 0 && Q < 128) for (var H = 0; H < Q + 1; H++) j[Z] = $[F], Z++, F++;
          if (Q >= -127 && Q < 0) {
            for (H = 0; H < 1 - Q; H++) j[Z] = $[F], Z++;
            F++;
          }
        }
        return Z;
      }, w.decode._decodeThunder = function(P, F, D, U, Z) {
        for (var $ = [0, 1, 0, -1], j = [0, 1, 2, 3, 0, -3, -2, -1], G = F + D, Q = 2 * Z, H = 0; F < G; ) {
          var W = P[F], q = W >>> 6, et = 63 & W;
          if (F++, q == 3 && (H = 15 & et, U[Q >>> 1] |= H << 4 * (1 - Q & 1), Q++), q == 0) for (var rt = 0; rt < et; rt++) U[Q >>> 1] |= H << 4 * (1 - Q & 1), Q++;
          if (q == 2) for (rt = 0; rt < 2; rt++)
            (tt = et >>> 3 * (1 - rt) & 7) != 4 && (H += j[tt], U[Q >>> 1] |= H << 4 * (1 - Q & 1), Q++);
          if (q == 1) for (rt = 0; rt < 3; rt++) {
            var tt;
            (tt = et >>> 2 * (2 - rt) & 3) != 2 && (H += $[tt], U[Q >>> 1] |= H << 4 * (1 - Q & 1), Q++);
          }
        }
      }, w.decode._dmap = { 1: 0, "011": 1, "000011": 2, "0000011": 3, "010": -1, "000010": -2, "0000010": -3 }, w.decode._lens = function() {
        var P = function(Q, H, W, q) {
          for (var et = 0; et < H.length; et++) Q[H[et]] = W + et * q;
        }, F = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101,101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010,00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010,00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100", D = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000,0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001,000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111,000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111", U = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011", Z = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,0000001011011,0000001100100,0000001100101", $ = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";
        F = F.split(","), D = D.split(","), U = U.split(","), Z = Z.split(","), $ = $.split(",");
        var j = {}, G = {};
        return P(j, F, 0, 1), P(j, U, 64, 64), P(j, $, 1792, 64), P(G, D, 0, 1), P(G, Z, 64, 64), P(G, $, 1792, 64), [j, G];
      }(), w.decode._decodeG4 = function(P, F, D, U, Z, $, j) {
        for (var G = w.decode, Q = F << 3, H = 0, W = "", q = [], et = [], rt = 0; rt < $; rt++) et.push(0);
        et = G._makeDiff(et);
        for (var tt = 0, V = 0, X = 0, ot = 0, it = 0, st = 0, at = "", ct = 0, K = 8 * Math.ceil($ / 8); Q >>> 3 < F + D; ) {
          X = G._findDiff(et, tt + (tt == 0 ? 0 : 1), 1 - it), ot = G._findDiff(et, X, it);
          var lt = 0;
          if (j == 1 && (lt = P[Q >>> 3] >>> 7 - (7 & Q) & 1), j == 2 && (lt = P[Q >>> 3] >>> (7 & Q) & 1), Q++, W += lt, at == "H") {
            if (G._lens[it][W] != null) {
              var vt = G._lens[it][W];
              W = "", H += vt, vt < 64 && (G._addNtimes(q, H, it), tt += H, it = 1 - it, H = 0, --ct == 0 && (at = ""));
            }
          } else W == "0001" && (W = "", G._addNtimes(q, ot - tt, it), tt = ot), W == "001" && (W = "", at = "H", ct = 2), G._dmap[W] != null && (V = X + G._dmap[W], G._addNtimes(q, V - tt, it), tt = V, W = "", it = 1 - it);
          q.length == $ && at == "" && (G._writeBits(q, U, 8 * Z + st * K), it = 0, st++, tt = 0, et = G._makeDiff(q), q = []);
        }
      }, w.decode._findDiff = function(P, F, D) {
        for (var U = 0; U < P.length; U += 2) if (P[U] >= F && P[U + 1] == D) return P[U];
      }, w.decode._makeDiff = function(P) {
        var F = [];
        P[0] == 1 && F.push(0, 1);
        for (var D = 1; D < P.length; D++) P[D - 1] != P[D] && F.push(D, P[D]);
        return F.push(P.length, 0, P.length, 1), F;
      }, w.decode._decodeG2 = function(P, F, D, U, Z, $, j) {
        for (var G = w.decode, Q = F << 3, H = 0, W = "", q = [], et = 0, rt = 0, tt = 8 * Math.ceil($ / 8); Q >>> 3 < F + D; ) {
          var V = 0;
          j == 1 && (V = P[Q >>> 3] >>> 7 - (7 & Q) & 1), j == 2 && (V = P[Q >>> 3] >>> (7 & Q) & 1), Q++, W += V, (H = G._lens[et][W]) != null && (G._addNtimes(q, H, et), W = "", H < 64 && (et = 1 - et), q.length == $ && (G._writeBits(q, U, 8 * Z + rt * tt), q = [], rt++, et = 0, 7 & Q && (Q += 8 - (7 & Q)), H >= 64 && (Q += 8)));
        }
      }, w.decode._decodeG3 = function(P, F, D, U, Z, $, j, G) {
        for (var Q = w.decode, H = F << 3, W = 0, q = "", et = [], rt = [], tt = 0; tt < $; tt++) et.push(0);
        for (var V = 0, X = 0, ot = 0, it = 0, st = 0, at = -1, ct = "", K = 0, lt = !0, vt = 8 * Math.ceil($ / 8); H >>> 3 < F + D; ) {
          ot = Q._findDiff(rt, V + (V == 0 ? 0 : 1), 1 - st), it = Q._findDiff(rt, ot, st);
          var dt = 0;
          if (j == 1 && (dt = P[H >>> 3] >>> 7 - (7 & H) & 1), j == 2 && (dt = P[H >>> 3] >>> (7 & H) & 1), H++, q += dt, lt) {
            if (Q._lens[st][q] != null) {
              var ht = Q._lens[st][q];
              q = "", W += ht, ht < 64 && (Q._addNtimes(et, W, st), st = 1 - st, W = 0);
            }
          } else ct == "H" ? Q._lens[st][q] != null && (ht = Q._lens[st][q], q = "", W += ht, ht < 64 && (Q._addNtimes(et, W, st), V += W, st = 1 - st, W = 0, --K == 0 && (ct = ""))) : (q == "0001" && (q = "", Q._addNtimes(et, it - V, st), V = it), q == "001" && (q = "", ct = "H", K = 2), Q._dmap[q] != null && (X = ot + Q._dmap[q], Q._addNtimes(et, X - V, st), V = X, q = "", st = 1 - st));
          q.endsWith("000000000001") && (at >= 0 && Q._writeBits(et, U, 8 * Z + at * vt), G && (j == 1 && (lt = (P[H >>> 3] >>> 7 - (7 & H) & 1) == 1), j == 2 && (lt = (P[H >>> 3] >>> (7 & H) & 1) == 1), H++), q = "", st = 0, at++, V = 0, rt = Q._makeDiff(et), et = []);
        }
        et.length == $ && Q._writeBits(et, U, 8 * Z + at * vt);
      }, w.decode._addNtimes = function(P, F, D) {
        for (var U = 0; U < F; U++) P.push(D);
      }, w.decode._writeBits = function(P, F, D) {
        for (var U = 0; U < P.length; U++) F[D + U >>> 3] |= P[U] << 7 - (D + U & 7);
      }, w.decode._decodeLZW = w.decode._decodeLZW = function() {
        var P, F, D, U, Z = 0, $ = 0, j = 0, G = 0, Q = function() {
          var tt = P >>> 3, V = (F[tt] << 16 | F[tt + 1] << 8 | F[tt + 2]) >>> 24 - (7 & P) - $ & (1 << $) - 1;
          return P += $, V;
        }, H = new Uint32Array(16384), W = 0, q = function(tt) {
          $ = tt + 1, Z = G + 1;
        }, et = function(tt) {
          for (var V = tt << 2, X = H[V + 2], ot = U + X - 1; V != 65535; ) D[ot--] = H[V], V = H[V + 1];
          U += X;
        }, rt = function(tt, V) {
          var X = Z << 2, ot = tt << 2;
          H[X] = H[3 + (V << 2)], H[X + 1] = ot, H[X + 2] = H[ot + 2] + 1, H[X + 3] = H[ot + 3], ++Z + 1 == 1 << $ && $ != 12 && $++;
        };
        return function(tt, V, X, ot, it, st) {
          P = V << 3, F = tt, D = ot, U = it;
          var at = V + X << 3, ct = 0, K = 0;
          for (function(lt) {
            if (lt != W) {
              W = lt, G = 1 + (j = 1 << lt);
              for (var vt = 0; vt < G + 1; vt++) H[4 * vt] = H[4 * vt + 3] = vt, H[4 * vt + 1] = 65535, H[4 * vt + 2] = 1;
            }
          }(st), q(st); P < at && (ct = Q()) != G; ) {
            if (ct == j) {
              if (q(st), (ct = Q()) == G) break;
              et(ct);
            } else ct < Z ? (et(ct), rt(K, ct)) : (rt(K, K), et(Z - 1));
            K = ct;
          }
          return U;
        };
      }(), w.tags = {}, w._types = function() {
        var P = new Array(250);
        return P.fill(0), { basic: { main: P = P.concat([0, 0, 0, 0, 4, 3, 3, 3, 3, 3, 0, 0, 3, 0, 0, 0, 3, 0, 0, 2, 2, 2, 2, 4, 3, 0, 0, 3, 4, 4, 3, 3, 5, 5, 3, 2, 5, 5, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 5, 5, 3, 0, 3, 3, 4, 4, 4, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), rest: { 33432: 2, 33434: 5, 33437: 5, 34665: 4, 34850: 3, 34853: 4, 34855: 3, 34864: 3, 34866: 4, 36864: 7, 36867: 2, 36868: 2, 37121: 7, 37377: 10, 37378: 5, 37380: 10, 37381: 5, 37383: 3, 37384: 3, 37385: 3, 37386: 5, 37510: 7, 37520: 2, 37521: 2, 37522: 2, 40960: 7, 40961: 3, 40962: 4, 40963: 4, 40965: 4, 41486: 5, 41487: 5, 41488: 3, 41985: 3, 41986: 3, 41987: 3, 41988: 5, 41989: 3, 41990: 3, 41993: 3, 41994: 3, 41995: 7, 41996: 3, 42032: 2, 42033: 2, 42034: 5, 42036: 2, 42037: 2, 59932: 7 } }, gps: { main: [1, 2, 5, 2, 5, 1, 5, 5, 0, 9], rest: { 18: 2, 29: 2 } } };
      }(), w._readIFD = function(P, F, D, U, Z, $) {
        var j = P.readUshort(F, D);
        D += 2;
        var G = {};
        $.debug && g("   ".repeat(Z), U.length - 1, ">>>----------------");
        for (var Q = 0; Q < j; Q++) {
          var H = P.readUshort(F, D);
          D += 2;
          var W = P.readUshort(F, D);
          D += 2;
          var q = P.readUint(F, D);
          D += 4;
          var et = P.readUint(F, D);
          D += 4;
          var rt = [];
          if (W == 1 || W == 7) {
            var tt = q < 5 ? D - 4 : et;
            tt + q > F.buffer.byteLength && (q = F.buffer.byteLength - tt), rt = new Uint8Array(F.buffer, tt, q);
          }
          if (W == 2) {
            var V = q < 5 ? D - 4 : et, X = F[V], ot = Math.max(0, Math.min(q - 1, F.length - V));
            X < 128 || ot == 0 ? rt.push(P.readASCII(F, V, ot)) : rt = new Uint8Array(F.buffer, V, ot);
          }
          if (W == 3) for (var it = 0; it < q; it++) rt.push(P.readUshort(F, (q < 3 ? D - 4 : et) + 2 * it));
          if (W == 4 || W == 13) for (it = 0; it < q; it++) rt.push(P.readUint(F, (q < 2 ? D - 4 : et) + 4 * it));
          if (W == 5 || W == 10) {
            var st = W == 5 ? P.readUint : P.readInt;
            for (it = 0; it < q; it++) rt.push([st(F, et + 8 * it), st(F, et + 8 * it + 4)]);
          }
          if (W == 8) for (it = 0; it < q; it++) rt.push(P.readShort(F, (q < 3 ? D - 4 : et) + 2 * it));
          if (W == 9) for (it = 0; it < q; it++) rt.push(P.readInt(F, (q < 2 ? D - 4 : et) + 4 * it));
          if (W == 11) for (it = 0; it < q; it++) rt.push(P.readFloat(F, et + 4 * it));
          if (W == 12) for (it = 0; it < q; it++) rt.push(P.readDouble(F, et + 8 * it));
          if (q == 0 || rt.length != 0) {
            if ($.debug && g("   ".repeat(Z), H, W, w.tags[H], rt), G["t" + H] = rt, !(H == 330 && G.t272 && G.t272[0] == "DSLR-A100")) {
              if (H == 330 || H == 34665 || H == 34853 || H == 50740 && P.readUshort(F, P.readUint(rt, 0)) < 300 || H == 61440) {
                var at = H == 50740 ? [P.readUint(rt, 0)] : rt, ct = [];
                for (it = 0; it < at.length; it++) w._readIFD(P, F, at[it], ct, Z + 1, $);
                H == 330 && (G.subIFD = ct), H == 34665 && (G.exifIFD = ct[0]), H == 34853 && (G.gpsiIFD = ct[0]), H == 50740 && (G.dngPrvt = ct[0]), H == 61440 && (G.fujiIFD = ct[0]);
              }
            }
            if (H == 37500 && $.parseMN) {
              var K = rt;
              if (P.readASCII(K, 0, 5) == "Nikon") G.makerNote = w.decode(K.slice(10).buffer)[0];
              else if (P.readASCII(K, 0, 5) == "OLYMP" || P.readASCII(K, 0, 9) == "OM SYSTEM") {
                var lt = [8208, 8224, 8240, 8256, 8272], vt = [];
                w._readIFD(P, K, K[1] == 77 ? 16 : K[5] == 85 ? 12 : 8, vt, Z + 1, $);
                var dt = G.makerNote = vt.pop();
                for (it = 0; it < lt.length; it++) {
                  var ht = "t" + lt[it];
                  dt[ht] != null && (w._readIFD(P, K, dt[ht][0], vt, Z + 1, $), dt[ht] = vt.pop());
                }
                dt.t12288 && (w._readIFD(P, dt.t12288, 0, vt, Z + 1, $), dt.t12288 = vt.pop());
              } else P.readUshort(F, et) < 300 && P.readUshort(F, et + 4) <= 12 && (vt = [], w._readIFD(P, F, et, vt, Z + 1, $), G.makerNote = vt[0]);
            }
          } else if (g(H, "unknown TIFF tag type: ", W, "num:", q), Q == 0) return;
        }
        return U.push(G), $.debug && g("   ".repeat(Z), "<<<---------------"), D;
      }, w._writeIFD = function(P, F, D, U, Z) {
        var $ = Object.keys(Z), j = $.length;
        Z.exifIFD && j--, Z.gpsiIFD && j--, P.writeUshort(D, U, j);
        for (var G = (U += 2) + 12 * j + 4, Q = 0; Q < $.length; Q++) {
          var H = $[Q];
          if (H != "t34665" && H != "t34853") {
            H == "exifIFD" && (H = "t34665"), H == "gpsiIFD" && (H = "t34853");
            var W = parseInt(H.slice(1)), q = F.main[W];
            if (q == null && (q = F.rest[W]), q == null || q == 0) throw new Error("unknown type of tag: " + W);
            var et = Z[H];
            W == 34665 && (et = [G], G = w._writeIFD(P, F, D, G, Z.exifIFD)[1]), W == 34853 && (et = [G], G = w._writeIFD(P, w._types.gps, D, G, Z.gpsiIFD)[1]), q == 2 && (et = et[0] + "\0");
            var rt = et.length;
            P.writeUshort(D, U, W), U += 2, P.writeUshort(D, U, q), U += 2, P.writeUint(D, U, rt);
            var tt = [-1, 1, 1, 2, 4, 8, 0, 1, 0, 4, 8, 0, 8][q] * rt, V = U += 4;
            if (tt > 4 && (P.writeUint(D, U, G), V = G), q == 1 || q == 7) for (var X = 0; X < rt; X++) D[V + X] = et[X];
            else if (q == 2) P.writeASCII(D, V, et);
            else if (q == 3) for (X = 0; X < rt; X++) P.writeUshort(D, V + 2 * X, et[X]);
            else if (q == 4) for (X = 0; X < rt; X++) P.writeUint(D, V + 4 * X, et[X]);
            else if (q == 5 || q == 10) {
              var ot = q == 5 ? P.writeUint : P.writeInt;
              for (X = 0; X < rt; X++) {
                var it = et[X], st = it[0], at = it[1];
                if (st == null) throw "e";
                ot(D, V + 8 * X, st), ot(D, V + 8 * X + 4, at);
              }
            } else if (q == 9) for (X = 0; X < rt; X++) P.writeInt(D, V + 4 * X, et[X]);
            else {
              if (q != 12) throw q;
              for (X = 0; X < rt; X++) P.writeDouble(D, V + 8 * X, et[X]);
            }
            tt > 4 && (G += tt += 1 & tt), U += 4;
          }
        }
        return [U, G];
      }, w.toRGBA8 = function(P, F) {
        function D(Kt) {
          return Kt < 31308e-7 ? 12.92 * Kt : 1.055 * Math.pow(Kt, 1 / 2.4) - 0.055;
        }
        var U = P.width, Z = P.height, $ = U * Z, j = P.data, G = new Uint8Array(4 * $), Q = P.t262 ? P.t262[0] : 2, H = P.t258 ? Math.min(32, P.t258[0]) : 1;
        P.t262 == null && H == 1 && (Q = 0);
        var W = P.t277 ? P.t277[0] : P.t258 ? P.t258.length : [1, 1, 3, 1, 1, 4, 3][Q], q = P.t339 ? P.t339[0] : null;
        if (Q == 1 && H == 32 && q != 3) throw "e";
        var et = Math.ceil(W * H * U / 8);
        if (Q == 0) {
          F = 1 / 256;
          for (var rt = 0; rt < Z; rt++) {
            var tt = rt * et, V = rt * U;
            if (H == 1) for (var X = 0; X < U; X++) {
              var ot = V + X << 2, it = j[tt + (X >> 3)] >> 7 - (7 & X) & 1;
              G[ot] = G[ot + 1] = G[ot + 2] = 255 * (1 - it), G[ot + 3] = 255;
            }
            if (H == 4) for (X = 0; X < U; X++)
              ot = V + X << 2, it = j[tt + (X >> 1)] >> 4 - 4 * (1 & X) & 15, G[ot] = G[ot + 1] = G[ot + 2] = 17 * (15 - it), G[ot + 3] = 255;
            if (H == 8) for (X = 0; X < U; X++)
              ot = V + X << 2, it = j[tt + X], G[ot] = G[ot + 1] = G[ot + 2] = 255 - it, G[ot + 3] = 255;
            if (H == 16) for (X = 0; X < U; X++)
              ot = V + X << 2, it = j[(at = tt + 2 * X) + 1] << 8 | j[at], G[ot] = G[ot + 1] = G[ot + 2] = Math.min(255, 255 - ~~(it * F)), G[ot + 3] = 255;
          }
        } else if (Q == 1) {
          F == null && (F = 1 / 256);
          var st = 3 & j.length ? null : new Float32Array(j.buffer);
          for (rt = 0; rt < Z; rt++) {
            if (tt = rt * et, V = rt * U, H == 1) for (X = 0; X < U; X++)
              ot = V + X << 2, it = j[tt + (X >> 3)] >> 7 - (7 & X) & 1, G[ot] = G[ot + 1] = G[ot + 2] = 255 * it, G[ot + 3] = 255;
            if (H == 2) for (X = 0; X < U; X++)
              ot = V + X << 2, it = j[tt + (X >> 2)] >> 6 - 2 * (3 & X) & 3, G[ot] = G[ot + 1] = G[ot + 2] = 85 * it, G[ot + 3] = 255;
            if (H == 8) for (X = 0; X < U; X++)
              ot = V + X << 2, it = j[tt + X * W], G[ot] = G[ot + 1] = G[ot + 2] = it, G[ot + 3] = 255;
            if (H == 16) for (X = 0; X < U; X++)
              ot = V + X << 2, it = j[(at = tt + 2 * X) + 1] << 8 | j[at], G[ot] = G[ot + 1] = G[ot + 2] = Math.min(255, ~~(it * F)), G[ot + 3] = 255;
            if (H == 32) for (X = 0; X < U; X++) {
              var at;
              ot = V + X << 2, it = st[at = (tt >>> 2) + X], G[ot] = G[ot + 1] = G[ot + 2] = ~~(0.5 + 255 * it), G[ot + 3] = 255;
            }
          }
        } else if (Q == 2) if (H == 8) {
          if (W == 1) for (X = 0; X < $; X++) G[4 * X] = G[4 * X + 1] = G[4 * X + 2] = j[X], G[4 * X + 3] = 255;
          if (W == 3) for (X = 0; X < $; X++) {
            var ct = 3 * X;
            G[ot = X << 2] = j[ct], G[ot + 1] = j[ct + 1], G[ot + 2] = j[ct + 2], G[ot + 3] = 255;
          }
          if (W >= 4) for (X = 0; X < $; X++)
            ct = X * W, G[ot = X << 2] = j[ct], G[ot + 1] = j[ct + 1], G[ot + 2] = j[ct + 2], G[ot + 3] = j[ct + 3];
        } else if (H == 16) {
          if (W == 4) for (X = 0; X < $; X++)
            ct = 8 * X + 1, G[ot = X << 2] = j[ct], G[ot + 1] = j[ct + 2], G[ot + 2] = j[ct + 4], G[ot + 3] = j[ct + 6];
          if (W == 3) for (X = 0; X < $; X++)
            ct = 6 * X + 1, G[ot = X << 2] = j[ct], G[ot + 1] = j[ct + 2], G[ot + 2] = j[ct + 4], G[ot + 3] = 255;
        } else {
          if (H != 32) throw H;
          var K = new Float32Array(j.buffer), lt = 0;
          for (X = 0; X < K.length; X++) lt = Math.min(lt, K[X]);
          if (lt < 0) for (X = 0; X < j.length; X += 4) {
            var vt = j[X];
            j[X] = j[X + 3], j[X + 3] = vt, vt = j[X + 1], j[X + 1] = j[X + 2], j[X + 2] = vt;
          }
          var dt = [];
          for (X = 0; X < 65536; X++) dt.push(D(X / 65535));
          for (X = 0; X < K.length; X++) {
            var ht = Math.max(0, Math.min(1, K[X]));
            K[X] = dt[~~(0.5 + 65535 * ht)];
          }
          if (W == 3) for (X = 0; X < $; X++)
            ct = 3 * X, G[ot = X << 2] = ~~(0.5 + 255 * K[ct]), G[ot + 1] = ~~(0.5 + 255 * K[ct + 1]), G[ot + 2] = ~~(0.5 + 255 * K[ct + 2]), G[ot + 3] = 255;
          else {
            if (W != 4) throw W;
            for (X = 0; X < $; X++)
              ct = 4 * X, G[ot = X << 2] = ~~(0.5 + 255 * K[ct]), G[ot + 1] = ~~(0.5 + 255 * K[ct + 1]), G[ot + 2] = ~~(0.5 + 255 * K[ct + 2]), G[ot + 3] = ~~(0.5 + 255 * K[ct + 3]);
          }
        }
        else if (Q == 3) {
          var pt = P.t320, Ct = 1 << H, St = H == 8 && W > 1 && P.t338 && P.t338[0] != 0;
          for (rt = 0; rt < Z; rt++) for (var At = 0; At < U; At++) {
            ot = (X = rt * U + At) << 2;
            var Ft = 0, xt = rt * et;
            if (H == 1) Ft = j[xt + (At >>> 3)] >>> 7 - (7 & At) & 1;
            else if (H == 2) Ft = j[xt + (At >>> 2)] >>> 6 - 2 * (3 & At) & 3;
            else if (H == 4) Ft = j[xt + (At >>> 1)] >>> 4 - 4 * (1 & At) & 15;
            else {
              if (H != 8) throw H;
              Ft = j[xt + At * W];
            }
            G[ot] = pt[Ft] >> 8, G[ot + 1] = pt[Ct + Ft] >> 8, G[ot + 2] = pt[Ct + Ct + Ft] >> 8, G[ot + 3] = St ? j[xt + At * W + 1] : 255;
          }
        } else if (Q == 5) {
          var Pt = W > 4 ? 1 : 0;
          for (X = 0; X < $; X++) {
            ot = X << 2;
            var Ot = X * W;
            if (window.UDOC) {
              var Bt = j[Ot], kt = j[Ot + 1], Tt = j[Ot + 2], Dt = j[Ot + 3], Zt = UDOC.C.cmykToRgb([Bt * (1 / 255), kt * (1 / 255), Tt * (1 / 255), Dt * (1 / 255)]);
              G[ot] = ~~(0.5 + 255 * Zt[0]), G[ot + 1] = ~~(0.5 + 255 * Zt[1]), G[ot + 2] = ~~(0.5 + 255 * Zt[2]);
            } else
              Bt = 255 - j[Ot], kt = 255 - j[Ot + 1], Tt = 255 - j[Ot + 2], Dt = (255 - j[Ot + 3]) * (1 / 255), G[ot] = ~~(Bt * Dt + 0.5), G[ot + 1] = ~~(kt * Dt + 0.5), G[ot + 2] = ~~(Tt * Dt + 0.5);
            G[ot + 3] = 255 * (1 - Pt) + j[Ot + 4] * Pt;
          }
        } else if (Q == 6 && P.t278) {
          var $t = P.t278[0];
          for (rt = 0; rt < Z; rt += $t) {
            X = rt * U;
            for (var Mt = $t * U, nt = 0; nt < Mt; nt++) {
              ot = 4 * (X + nt), Tt = j[(Ot = 3 * X + 4 * (nt >>> 1)) + (1 & nt)];
              var It = j[Ot + 2] - 128, mt = j[Ot + 3] - 128, gt = Tt + ((mt >> 2) + (mt >> 3) + (mt >> 5)), _t = Tt - ((It >> 2) + (It >> 4) + (It >> 5)) - ((mt >> 1) + (mt >> 3) + (mt >> 4) + (mt >> 5)), wt = Tt + (It + (It >> 1) + (It >> 2) + (It >> 6));
              G[ot] = Math.max(0, Math.min(255, gt)), G[ot + 1] = Math.max(0, Math.min(255, _t)), G[ot + 2] = Math.max(0, Math.min(255, wt)), G[ot + 3] = 255;
            }
          }
        } else if (Q == 32845) for (rt = 0; rt < Z; rt++) for (At = 0; At < U; At++) {
          ot = 4 * (rt * U + At);
          var Rt = j[(Ot = 6 * (rt * U + At)) + 1] << 8 | j[Ot], J = (Rt = Math.pow(2, (Rt + 0.5) / 256 - 64), (j[Ot + 3] + 0.5) / 410), ut = (j[Ot + 5] + 0.5) / 410, bt = 9 * J / (6 * J - 16 * ut + 12), yt = 4 * ut / (6 * J - 16 * ut + 12), Lt = bt * Rt / yt, jt = (1 - bt - yt) * Rt / yt;
          gt = 2.69 * Lt - 1.276 * (Tt = Rt) - 0.414 * jt, _t = -1.022 * Lt + 1.978 * Tt + 0.044 * jt, wt = 0.061 * Lt - 0.224 * Tt + 1.163 * jt, G[ot] = 255 * D(Math.min(gt, 1)), G[ot + 1] = 255 * D(Math.min(_t, 1)), G[ot + 2] = 255 * D(Math.min(wt, 1)), G[ot + 3] = 255;
        }
        else g("Unknown Photometric interpretation: " + Q);
        return G;
      }, w.replaceIMG = function(P) {
        P == null && (P = document.getElementsByTagName("img"));
        for (var F = ["tif", "tiff", "dng", "cr2", "nef"], D = 0; D < P.length; D++) {
          var U = P[D], Z = U.getAttribute("src");
          if (Z != null) {
            var $ = Z.split(".").pop().toLowerCase();
            if (F.indexOf($) != -1) {
              var j = new XMLHttpRequest();
              w._xhrs.push(j), w._imgs.push(U), j.open("GET", Z), j.responseType = "arraybuffer", j.onload = w._imgLoaded, j.send();
            }
          }
        }
      }, w._xhrs = [], w._imgs = [], w._imgLoaded = function(P) {
        var F = w._xhrs.indexOf(P.target), D = w._imgs[F];
        w._xhrs.splice(F, 1), w._imgs.splice(F, 1), D.setAttribute("src", w.bufferToURI(P.target.response));
      }, w.bufferToURI = function(P) {
        var F = w.decode(P), D = F, U = 0, Z = D[0];
        F[0].subIFD && (D = D.concat(F[0].subIFD));
        for (var $ = 0; $ < D.length; $++) {
          var j = D[$];
          if (!(j.t258 == null || j.t258.length < 3)) {
            var G = j.t256 * j.t257;
            G > U && (U = G, Z = j);
          }
        }
        w.decodeImage(P, Z, F);
        var Q = w.toRGBA8(Z), H = Z.width, W = Z.height, q = document.createElement("canvas");
        q.width = H, q.height = W;
        var et = q.getContext("2d"), rt = new ImageData(new Uint8ClampedArray(Q.buffer), H, W);
        return et.putImageData(rt, 0, 0), q.toDataURL();
      }, w._binBE = { nextZero: function(P, F) {
        for (; P[F] != 0; ) F++;
        return F;
      }, readUshort: function(P, F) {
        return P[F] << 8 | P[F + 1];
      }, readShort: function(P, F) {
        var D = w._binBE.ui8;
        return D[0] = P[F + 1], D[1] = P[F + 0], w._binBE.i16[0];
      }, readInt: function(P, F) {
        var D = w._binBE.ui8;
        return D[0] = P[F + 3], D[1] = P[F + 2], D[2] = P[F + 1], D[3] = P[F + 0], w._binBE.i32[0];
      }, readUint: function(P, F) {
        var D = w._binBE.ui8;
        return D[0] = P[F + 3], D[1] = P[F + 2], D[2] = P[F + 1], D[3] = P[F + 0], w._binBE.ui32[0];
      }, readASCII: function(P, F, D) {
        for (var U = "", Z = 0; Z < D; Z++) U += String.fromCharCode(P[F + Z]);
        return U;
      }, readFloat: function(P, F) {
        for (var D = w._binBE.ui8, U = 0; U < 4; U++) D[U] = P[F + 3 - U];
        return w._binBE.fl32[0];
      }, readDouble: function(P, F) {
        for (var D = w._binBE.ui8, U = 0; U < 8; U++) D[U] = P[F + 7 - U];
        return w._binBE.fl64[0];
      }, writeUshort: function(P, F, D) {
        P[F] = D >> 8 & 255, P[F + 1] = 255 & D;
      }, writeInt: function(P, F, D) {
        var U = w._binBE.ui8;
        w._binBE.i32[0] = D, P[F + 3] = U[0], P[F + 2] = U[1], P[F + 1] = U[2], P[F + 0] = U[3];
      }, writeUint: function(P, F, D) {
        P[F] = D >> 24 & 255, P[F + 1] = D >> 16 & 255, P[F + 2] = D >> 8 & 255, P[F + 3] = 255 & D;
      }, writeASCII: function(P, F, D) {
        for (var U = 0; U < D.length; U++) P[F + U] = D.charCodeAt(U);
      }, writeDouble: function(P, F, D) {
        w._binBE.fl64[0] = D;
        for (var U = 0; U < 8; U++) P[F + U] = w._binBE.ui8[7 - U];
      } }, w._binBE.ui8 = new Uint8Array(8), w._binBE.i16 = new Int16Array(w._binBE.ui8.buffer), w._binBE.i32 = new Int32Array(w._binBE.ui8.buffer), w._binBE.ui32 = new Uint32Array(w._binBE.ui8.buffer), w._binBE.fl32 = new Float32Array(w._binBE.ui8.buffer), w._binBE.fl64 = new Float64Array(w._binBE.ui8.buffer), w._binLE = { nextZero: w._binBE.nextZero, readUshort: function(P, F) {
        return P[F + 1] << 8 | P[F];
      }, readShort: function(P, F) {
        var D = w._binBE.ui8;
        return D[0] = P[F + 0], D[1] = P[F + 1], w._binBE.i16[0];
      }, readInt: function(P, F) {
        var D = w._binBE.ui8;
        return D[0] = P[F + 0], D[1] = P[F + 1], D[2] = P[F + 2], D[3] = P[F + 3], w._binBE.i32[0];
      }, readUint: function(P, F) {
        var D = w._binBE.ui8;
        return D[0] = P[F + 0], D[1] = P[F + 1], D[2] = P[F + 2], D[3] = P[F + 3], w._binBE.ui32[0];
      }, readASCII: w._binBE.readASCII, readFloat: function(P, F) {
        for (var D = w._binBE.ui8, U = 0; U < 4; U++) D[U] = P[F + U];
        return w._binBE.fl32[0];
      }, readDouble: function(P, F) {
        for (var D = w._binBE.ui8, U = 0; U < 8; U++) D[U] = P[F + U];
        return w._binBE.fl64[0];
      }, writeUshort: function(P, F, D) {
        P[F] = 255 & D, P[F + 1] = D >> 8 & 255;
      }, writeInt: function(P, F, D) {
        var U = w._binBE.ui8;
        w._binBE.i32[0] = D, P[F + 0] = U[0], P[F + 1] = U[1], P[F + 2] = U[2], P[F + 3] = U[3];
      }, writeUint: function(P, F, D) {
        P[F] = D >>> 0 & 255, P[F + 1] = D >>> 8 & 255, P[F + 2] = D >>> 16 & 255, P[F + 3] = D >>> 24 & 255;
      }, writeASCII: w._binBE.writeASCII }, w._copyTile = function(P, F, D, U, Z, $, j, G) {
        for (var Q = Math.min(F, Z - j), H = Math.min(D, $ - G), W = 0; W < H; W++) for (var q = (G + W) * Z + j, et = W * F, rt = 0; rt < Q; rt++) U[q + rt] = P[et + rt];
      }, w.LosslessJpegDecode = /* @__PURE__ */ function() {
        var P, F;
        function D() {
          return P[F++];
        }
        function U() {
          return P[F++] << 8 | P[F++];
        }
        function Z(tt) {
          for (var V = D(), X = [0, 0, 0, 255], ot = [], it = 0; it < 16; it++) ot[it] = D();
          for (it = 0; it < 16; it++) for (var st = 0; st < ot[it]; st++)
            X[$(X, 0, it + 1, 1) + 3] = D();
          var at = new Uint8Array(256);
          for (tt[V] = [new Uint8Array(X), at], it = 0; it < 256; it++) {
            for (var ct = 8, K = it, lt = 0; X[lt + 3] == 255 && ct != 0; ) lt = X[lt + (K >> --ct & 1)];
            at[it] = lt;
          }
        }
        function $(tt, V, X, ot) {
          if (tt[V + 3] != 255) return 0;
          if (X == 0) return V;
          for (var it = 0; it < 2; it++) {
            tt[V + it] == 0 && (tt[V + it] = tt.length, tt.push(0, 0, ot, 255));
            var st = $(tt, tt[V + it], X - 1, ot + 1);
            if (st != 0) return st;
          }
          return 0;
        }
        function j(tt) {
          for (var V = tt.b, X = tt.f; V < 25 && tt.a < tt.d; ) {
            var ot = tt.data[tt.a++];
            ot != 255 || tt.c || tt.a++, X = X << 8 | ot, V += 8;
          }
          if (V < 0) throw "e";
          tt.b = V, tt.f = X;
        }
        function G(tt, V) {
          return V.b < tt && j(V), V.f >> (V.b -= tt) & 65535 >> 16 - tt;
        }
        function Q(tt, V) {
          var X = tt[0], ot = 0, it = 255;
          V.b < 16 && j(V);
          var st = V.f >> V.b - 8 & 255;
          for (it = X[(ot = tt[1][st]) + 3], V.b -= X[ot + 2]; it == 255; ) it = X[(ot = X[ot + (V.f >> --V.b & 1)]) + 3];
          return it;
        }
        function H(tt, V) {
          return tt < 32768 >> 16 - V && (tt += 1 - (1 << V)), tt;
        }
        function W(tt, V) {
          var X = Q(tt, V);
          return X == 0 ? 0 : X == 16 ? -32768 : H(G(X, V), X);
        }
        function q(tt, V, X, ot, it, st) {
          for (var at = 0, ct = 0; ct < st; ct++) {
            for (var K = ct * V, lt = 0; lt < V; lt += it) {
              at++;
              for (var vt = 0; vt < it; vt++) tt[K + lt + vt] = W(ot[vt], X);
            }
            if (X.e != 0 && at % X.e == 0 && ct != 0) {
              for (var dt = X.a, ht = X.data; ht[dt] != 255 || !(208 <= ht[dt + 1] && ht[dt + 1] <= 215); ) dt--;
              X.a = dt + 2, X.f = 0, X.b = 0;
            }
          }
        }
        function et(tt, V) {
          return H(G(tt, V), tt);
        }
        function rt(tt, V, X, ot, it, st, at, ct) {
          for (var K = X * at, lt = it; lt < st; lt++) tt[lt] += 1 << ct - 1;
          for (var vt = at; vt < K; vt += at) for (lt = it; lt < st; lt++) tt[vt + lt] += tt[vt + lt - at];
          for (var dt = 1; dt < ot; dt++) {
            var ht = dt * K;
            for (lt = it; lt < st; lt++) tt[ht + lt] += tt[ht + lt - K];
            for (vt = at; vt < K; vt += at) for (lt = it; lt < st; lt++) {
              var pt = ht + vt + lt, Ct = pt - K, St = tt[pt - at], At = 0;
              if (V == 0) At = 0;
              else if (V == 1) At = St;
              else if (V == 2) At = tt[Ct];
              else if (V == 3) At = tt[Ct - at];
              else if (V == 4) At = St + (tt[Ct] - tt[Ct - at]);
              else if (V == 5) At = St + (tt[Ct] - tt[Ct - at] >>> 1);
              else if (V == 6) At = tt[Ct] + (St - tt[Ct - at] >>> 1);
              else {
                if (V != 7) throw V;
                At = St + tt[Ct] >>> 1;
              }
              tt[pt] += At;
            }
          }
        }
        return function(tt) {
          if (P = tt, F = 0, U() != 65496) throw "e";
          for (var V = [], X = 0, ot = 0, it = 0, st = [], at = [], ct = [], K = 0, lt = 0, vt = 0; ; ) {
            var dt = U();
            if (dt != 65535) {
              var ht = U();
              if (dt == 65475) {
                ot = D(), lt = U(), vt = U(), K = D();
                for (var pt = 0; pt < K; pt++) {
                  var Ct = D(), St = D();
                  if (D() != 0) throw "e";
                  V[Ct] = [pt, St >> 4, 15 & St];
                }
              } else if (dt == 65476) for (var At = F + ht - 2; F < At; ) Z(at);
              else {
                if (dt == 65498) {
                  for (F++, pt = 0; pt < K; pt++) {
                    var Ft = V[D()];
                    ct[Ft[0]] = at[D() >>> 4], st[Ft[0]] = Ft.slice(1);
                  }
                  X = D(), F += 2;
                  break;
                }
                dt == 65501 ? it = U() : F += ht - 2;
              }
            } else F--;
          }
          var xt = new (ot > 8 ? Uint16Array : Uint8Array)(lt * vt * K), Pt = { b: 0, f: 0, c: X == 8, a: F, data: P, d: P.length, e: it };
          if (Pt.c) (function(Lt, jt, Kt, te, Vt) {
            for (var ee = P.length - F, Jt = 0; Jt < ee; Jt += 4) {
              var le = P[F + Jt];
              P[F + Jt] = P[F + Jt + 3], P[F + Jt + 3] = le, le = P[F + Jt + 1], P[F + Jt + 1] = P[F + Jt + 2], P[F + Jt + 2] = le;
            }
            for (var ae = 0; ae < Vt; ae++) for (var se = 32768, fe = 32768, ne = 0; ne < jt; ne += 2) {
              var Nt = Q(te, Kt), Xt = Q(te, Kt);
              Nt != 0 && (se += et(Nt, Kt)), Xt != 0 && (fe += et(Xt, Kt)), Lt[ae * jt + ne] = 65535 & se, Lt[ae * jt + ne + 1] = 65535 & fe;
            }
          })(xt, vt * K, Pt, ct[0], lt);
          else {
            var Ot = [], Bt = 0, kt = 0;
            for (pt = 0; pt < K; pt++) {
              var Tt = st[pt];
              (wt = Tt[0]) > Bt && (Bt = wt), (_t = Tt[1]) > kt && (kt = _t), Ot.push(wt * _t);
            }
            if (Bt != 1 || kt != 1) {
              if (K != 3 || Ot[1] != 1 || Ot[2] != 1 || Bt != 2 || kt != 1 && kt != 2) throw "e";
              var Dt = [], Zt = 0;
              for (pt = 0; pt < K; pt++) {
                for (var $t = 0; $t < Ot[pt]; $t++) Dt.push(ct[pt]);
                Zt += Ot[pt];
              }
              var Mt = vt / Bt, nt = lt / kt, It = Mt * nt;
              q(xt, Mt * Zt, Pt, Dt, Zt, nt), rt(xt, X, Mt, nt, Zt - 2, Zt, Zt, ot);
              var mt = new Uint16Array(It * Ot[0]);
              if (Bt == 2 && kt == 2) {
                for (pt = 0; pt < It; pt++) mt[4 * pt] = xt[6 * pt], mt[4 * pt + 1] = xt[6 * pt + 1], mt[4 * pt + 2] = xt[6 * pt + 2], mt[4 * pt + 3] = xt[6 * pt + 3];
                for (rt(mt, X, 4 * Mt, nt, 0, 1, 1, ot), pt = 0; pt < It; pt++) xt[6 * pt] = mt[4 * pt], xt[6 * pt + 1] = mt[4 * pt + 1], xt[6 * pt + 2] = mt[4 * pt + 2], xt[6 * pt + 3] = mt[4 * pt + 3];
              }
              if (Bt == 2 && kt == 1) {
                for (pt = 0; pt < It; pt++) mt[2 * pt] = xt[4 * pt], mt[2 * pt + 1] = xt[4 * pt + 1];
                for (rt(mt, X, 2 * Mt, nt, 0, 1, 1, ot), pt = 0; pt < It; pt++) xt[4 * pt] = mt[2 * pt], xt[4 * pt + 1] = mt[2 * pt + 1];
              }
              for (var gt = xt.slice(0), _t = 0; _t < lt; _t++) if (kt == 2) for (var wt = 0; wt < vt; wt++) {
                var Rt = ((_t >>> 1) * Mt + (wt >>> 1)) * Zt, J = 2 * (1 & _t) + (1 & wt);
                xt[ut = (_t * vt + wt) * K] = gt[Rt + J], xt[ut + 1] = gt[Rt + 4], xt[ut + 2] = gt[Rt + 5];
              }
              else for (wt = 0; wt < vt; wt++) {
                var ut;
                Rt = (_t * Mt + (wt >>> 1)) * Zt, J = 1 & wt, xt[ut = (_t * vt + wt) * K] = gt[Rt + J], xt[ut + 1] = gt[Rt + 2], xt[ut + 2] = gt[Rt + 3];
              }
            } else if (q(xt, vt * K, Pt, ct, K, lt), it == 0) rt(xt, X, vt, lt, 0, K, K, ot);
            else {
              var bt = Math.floor(it / vt);
              for (_t = 0; _t < lt; _t += bt) {
                var yt = xt.slice(_t * vt * K, (_t + bt) * vt * K);
                rt(yt, X, vt, bt, 0, K, K, ot), xt.set(yt, _t * vt * K);
              }
            }
          }
          return xt;
        };
      }(), function() {
        var P = 2, F = 4, D = 5, U = 6, Z = 7, $ = 12, j = 13, G = 14, Q = 15, H = 17;
        function W(st) {
          var at = { c: new Int8Array(2 << st.u) };
          return function(ct, K, lt) {
            var vt = [K, 3 * K + 18, 5 * K + 67, 7 * K + 276, lt];
            ct.o = K, ct.w = (vt[4] + 2 * K) / (2 * K + 1) + 1 | 0, ct.v = Math.ceil(Math.log2(ct.w)), ct.t = 9, function(dt, ht) {
              for (var pt = -ht[4], Ct = 0; pt <= ht[4]; Ct++, pt++) dt[Ct] = pt <= -276 ? -4 : pt <= -67 ? -3 : pt <= -18 ? -2 : pt < -0 ? -1 : pt <= ht[0] ? 0 : pt < ht[1] ? 1 : pt < ht[2] ? 2 : pt < ht[3] ? 3 : 4;
            }(ct.c, vt);
          }(at, 0, st.g), at;
        }
        function q(st) {
          for (var at = [[], [], []], ct = Math.max(2, st.w + 32 >>> 6), K = 0; K < 3; K++) for (var lt = 0; lt < 41; lt++) at[K][lt] = [ct, 1];
          return at;
        }
        function et(st, at) {
          var ct = 0, K = 8 - st.a;
          if (st.j, st.a, at) {
            if (at >= K) do
              ct <<= K, at -= K, ct |= st[st.j] & (1 << K) - 1, st.j++, K = 8;
            while (at >= 8);
            at && (ct <<= at, K -= at, ct |= st[st.j] >>> K & (1 << at) - 1), st.a = 8 - K;
          }
          return ct;
        }
        function rt(st, at, ct, K, lt, vt, dt, ht) {
          ht == null && (ht = 0);
          var pt, Ct, St, At, Ft, xt, Pt = vt + 1, Ot = Pt % 2, Bt = 0, kt = K[lt], Tt = K[lt - 1], Dt = K[lt - 2][Pt], Zt = Tt[Pt - 1], $t = Tt[Pt], Mt = Tt[Pt + 1], nt = kt[Pt - 1], It = kt[Pt + 1], mt = Math.abs;
          if (Ot && (St = mt(Mt - $t), At = mt(Dt - $t), Ft = mt(Zt - $t)), Ot) {
            if (xt = (xt = St > Ft && At < St ? Dt + Zt : St < Ft && At < Ft ? Dt + Mt : Mt + Zt) + 2 * $t >>> 2, ht) return void (kt[Pt] = xt);
            pt = at.t * at.c[st.g + $t - Dt] + at.c[st.g + Zt - $t];
          } else xt = $t > Zt && $t > Mt || $t < Zt && $t < Mt ? It + nt + 2 * $t >>> 2 : nt + It >>> 1, pt = at.t * at.c[st.g + $t - Zt] + at.c[st.g + Zt - nt];
          Ct = mt(pt);
          var gt = function(wt) {
            for (var Rt = -1, J = 0; !J; Rt++) J = wt[wt.j] >>> 7 - wt.a & 1, wt.a++, wt.a &= 7, wt.a || wt.j++;
            return Rt;
          }(ct);
          if (gt < st.n - at.v - 1) {
            var _t = function(wt, Rt) {
              var J = 0;
              if (Rt < wt) for (; J <= 14 && Rt << ++J < wt; ) ;
              return J;
            }(dt[Ct][0], dt[Ct][1]);
            Bt = et(ct, _t) + (gt << _t);
          } else Bt = et(ct, at.v) + 1;
          Bt = 1 & Bt ? -1 - (Bt >>> 1) : Bt >>> 1, dt[Ct][0] += mt(Bt), dt[Ct][1] == st.f && (dt[Ct][0] >>>= 1, dt[Ct][1] >>>= 1), dt[Ct][1]++, xt = pt < 0 ? xt - Bt : xt + Bt, st.i && (xt < 0 ? xt += at.w : xt > st.g && (xt -= at.w)), kt[Pt] = xt >= 0 ? Math.min(xt, st.g) : 0;
        }
        function tt(st, at, ct) {
          for (var K = st[0].length, lt = at; lt <= ct; lt++) st[lt][0] = st[lt - 1][1], st[lt][K - 1] = st[lt - 1][K - 2];
        }
        function V(st) {
          tt(st, Z, $), tt(st, P, F), tt(st, Q, H);
        }
        function X(st, at, ct, K, lt, vt, dt, ht, pt, Ct, St, At, Ft) {
          for (var xt = 0, Pt = 1, Ot = lt < j && lt > F; Pt < st.m; ) xt < st.m && (rt(st, at, ct, K, lt, xt, dt[pt], st.h && (Ot && Ct || !Ot && (St || (xt & At) == Ft))), rt(st, at, ct, K, vt, xt, dt[pt], st.h && (!Ot && Ct || Ot && (St || (xt & At) == Ft))), xt += 2), xt > 8 && (rt(st, at, ct, K, lt, Pt, ht[pt]), rt(st, at, ct, K, vt, Pt, ht[pt]), Pt += 2);
          V(K);
        }
        function ot(st, at, ct, K, lt, vt) {
          X(st, at, ct, K, P, Z, lt, vt, 0, 0, 1, 0, 8), X(st, at, ct, K, 8, Q, lt, vt, 1, 0, 1, 0, 8), X(st, at, ct, K, 3, 9, lt, vt, 2, 1, 0, 3, 0), X(st, at, ct, K, 10, 16, lt, vt, 0, 0, 0, 3, 2), X(st, at, ct, K, F, 11, lt, vt, 1, 0, 0, 3, 2), X(st, at, ct, K, $, H, lt, vt, 2, 1, 0, 3, 0);
        }
        function it(st, at, ct, K, lt, vt) {
          var dt = vt.length, ht = st.l;
          lt + 1 == st.s && (ht = st.e - lt * st.l);
          for (var pt = 6 * st.e * K + lt * st.l, Ct = 0; Ct < 6; Ct++) {
            for (var St = 0; St < ht; St++) {
              var At, Ft = vt[Ct % dt][St % dt];
              At = Ft == 0 ? P + (Ct >>> 1) : Ft == 2 ? Q + (Ct >>> 1) : Z + Ct;
              var xt = st.h ? (2 * St / 3 & 2147483646 | St % 3 & 1) + (St % 3 >>> 1) : St >>> 1;
              at[pt + St] = ct[At][xt + 1];
            }
            pt += st.e;
          }
        }
        w._decompressRAF = function(st, at) {
          var ct = function(Pt) {
            var Ot = w._binBE.readUshort, Bt = { b: Ot(Pt, 0), i: Pt[2], C: Pt[3], u: Pt[4], q: Ot(Pt, 5), k: Ot(Pt, 7), e: Ot(Pt, 9), l: Ot(Pt, 11), s: Pt[13], d: Ot(Pt, 14) };
            if (Bt.b != 18771 || Bt.i > 1 || Bt.q < 6 || Bt.q % 6 || Bt.e < 768 || Bt.e % 24 || Bt.l != 768 || Bt.k < Bt.l || Bt.k % Bt.l || Bt.k - Bt.e >= Bt.l || Bt.s > 16 || Bt.s != Bt.k / Bt.l || Bt.s != Math.ceil(Bt.e / Bt.l) || Bt.d != Bt.q / 6 || Bt.u != 12 && Bt.u != 14 && Bt.u != 16 || Bt.C != 16 && Bt.C != 0) throw "Invalid data";
            if (Bt.i == 0) throw "Not implemented. We need this file!";
            return Bt.h = Bt.C == 16, Bt.m = 0 | (Bt.h ? 2 * Bt.l / 3 : Bt.l >>> 1), Bt.A = Bt.m + 2, Bt.f = 64, Bt.g = (1 << Bt.u) - 1, Bt.n = 4 * Bt.u, Bt;
          }(st), K = function(Pt, Ot) {
            var Bt = new Array(Ot.s), kt = 4 * Ot.s, Tt = 16 + kt;
            12 & kt && (Tt += 16 - (12 & kt));
            for (var Dt = 0, Zt = 16; Dt < Ot.s; Zt += 4) {
              var $t = w._binBE.readUint(Pt, Zt);
              Bt[Dt] = Pt.slice(Tt, Tt + $t), Bt[Dt].j = 0, Bt[Dt].a = 0, Tt += $t, Dt++;
            }
            if (Tt != Pt.length) throw "Invalid data";
            return Bt;
          }(st, ct), lt = W(ct), vt = new Int16Array(ct.e * ct.q);
          at == null && (at = ct.h ? [[1, 1, 0, 1, 1, 2], [1, 1, 2, 1, 1, 0], [2, 0, 1, 0, 2, 1], [1, 1, 2, 1, 1, 0], [1, 1, 0, 1, 1, 2], [0, 2, 1, 2, 0, 1]] : [[0, 1], [3, 2]]);
          for (var dt = [[0, 3], [1, F], [D, 11], [U, $], [j, 16], [G, H]], ht = [], pt = 0; pt < 18; pt++) ht[pt] = new Uint16Array(ct.A);
          for (var Ct = 0; Ct < ct.s; Ct++) {
            var St = q(lt), At = q(lt);
            for (pt = 0; pt < 18; pt++) for (var Ft = 0; Ft < ct.A; Ft++) ht[pt][Ft] = 0;
            for (var xt = 0; xt < ct.d; xt++) {
              for (ot(ct, lt, K[Ct], ht, St, At), pt = 0; pt < 6; pt++) for (Ft = 0; Ft < ct.A; Ft++) ht[dt[pt][0]][Ft] = ht[dt[pt][1]][Ft];
              for (it(ct, vt, ht, xt, Ct, at), pt = P; pt < 18; pt++) if ([D, U, j, G].indexOf(pt) == -1) for (Ft = 0; Ft < ct.A; Ft++) ht[pt][Ft] = 0;
              V(ht);
            }
          }
          return vt;
        };
      }();
    }(m, typeof commonjsRequire == "function" ? requirePako() : self.pako);
  })();
})(UTIF);
var UTIFExports = UTIF.exports, utif = getDefaultExportFromCjs(UTIFExports), util$1, objectUtil;
function getDimensionValue(d) {
  return typeof d == "number" ? d : d instanceof Uint8Array ? d[0] : typeof d[0] == "string" ? parseInt(d[0]) : d[0];
}
function tiff() {
  return { mime: "image/tiff", encode: (d) => {
    const m = utif.encodeImage(d.data, d.width, d.height);
    return Buffer.from(m);
  }, decode: (d) => {
    const m = utif.decode(d), g = m[0];
    if (!g) throw new Error("No page found in TIFF");
    if (!g.t256) throw new Error("No image width found in TIFF");
    if (!g.t257) throw new Error("No image height found in TIFF");
    m.forEach((I) => {
      utif.decodeImage(d, I);
    });
    const w = utif.toRGBA8(g);
    return { data: Buffer.from(w), width: getDimensionValue(g.t256), height: getDimensionValue(g.t257) };
  } };
}
(function(d) {
  d.assertEqual = (m) => m, d.assertIs = function(m) {
  }, d.assertNever = function(m) {
    throw new Error();
  }, d.arrayToEnum = (m) => {
    const g = {};
    for (const w of m) g[w] = w;
    return g;
  }, d.getValidEnumValues = (m) => {
    const g = d.objectKeys(m).filter((I) => typeof m[m[I]] != "number"), w = {};
    for (const I of g) w[I] = m[I];
    return d.objectValues(w);
  }, d.objectValues = (m) => d.objectKeys(m).map(function(g) {
    return m[g];
  }), d.objectKeys = typeof Object.keys == "function" ? (m) => Object.keys(m) : (m) => {
    const g = [];
    for (const w in m) Object.prototype.hasOwnProperty.call(m, w) && g.push(w);
    return g;
  }, d.find = (m, g) => {
    for (const w of m) if (g(w)) return w;
  }, d.isInteger = typeof Number.isInteger == "function" ? (m) => Number.isInteger(m) : (m) => typeof m == "number" && isFinite(m) && Math.floor(m) === m, d.joinValues = function(m, g = " | ") {
    return m.map((w) => typeof w == "string" ? `'${w}'` : w).join(g);
  }, d.jsonStringifyReplacer = (m, g) => typeof g == "bigint" ? g.toString() : g;
})(util$1 || (util$1 = {})), function(d) {
  d.mergeShapes = (m, g) => ({ ...m, ...g });
}(objectUtil || (objectUtil = {}));
const ZodParsedType = util$1.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]), getParsedType = (d) => {
  switch (typeof d) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(d) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      return Array.isArray(d) ? ZodParsedType.array : d === null ? ZodParsedType.null : d.then && typeof d.then == "function" && d.catch && typeof d.catch == "function" ? ZodParsedType.promise : typeof Map < "u" && d instanceof Map ? ZodParsedType.map : typeof Set < "u" && d instanceof Set ? ZodParsedType.set : typeof Date < "u" && d instanceof Date ? ZodParsedType.date : ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, ZodIssueCode = util$1.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]), quotelessJson = (d) => JSON.stringify(d, null, 2).replace(/"([^"]+)":/g, "$1:");
class ZodError extends Error {
  constructor(m) {
    super(), this.issues = [], this.addIssue = (w) => {
      this.issues = [...this.issues, w];
    }, this.addIssues = (w = []) => {
      this.issues = [...this.issues, ...w];
    };
    const g = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, g) : this.__proto__ = g, this.name = "ZodError", this.issues = m;
  }
  get errors() {
    return this.issues;
  }
  format(m) {
    const g = m || function(P) {
      return P.message;
    }, w = { _errors: [] }, I = (P) => {
      for (const F of P.issues) if (F.code === "invalid_union") F.unionErrors.map(I);
      else if (F.code === "invalid_return_type") I(F.returnTypeError);
      else if (F.code === "invalid_arguments") I(F.argumentsError);
      else if (F.path.length === 0) w._errors.push(g(F));
      else {
        let D = w, U = 0;
        for (; U < F.path.length; ) {
          const Z = F.path[U];
          U === F.path.length - 1 ? (D[Z] = D[Z] || { _errors: [] }, D[Z]._errors.push(g(F))) : D[Z] = D[Z] || { _errors: [] }, D = D[Z], U++;
        }
      }
    };
    return I(this), w;
  }
  static assert(m) {
    if (!(m instanceof ZodError)) throw new Error(`Not a ZodError: ${m}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$1.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(m = (g) => g.message) {
    const g = {}, w = [];
    for (const I of this.issues) I.path.length > 0 ? (g[I.path[0]] = g[I.path[0]] || [], g[I.path[0]].push(m(I))) : w.push(m(I));
    return { formErrors: w, fieldErrors: g };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (d) => new ZodError(d);
const errorMap = (d, m) => {
  let g;
  switch (d.code) {
    case ZodIssueCode.invalid_type:
      g = d.received === ZodParsedType.undefined ? "Required" : `Expected ${d.expected}, received ${d.received}`;
      break;
    case ZodIssueCode.invalid_literal:
      g = `Invalid literal value, expected ${JSON.stringify(d.expected, util$1.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      g = `Unrecognized key(s) in object: ${util$1.joinValues(d.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      g = "Invalid input";
      break;
    case ZodIssueCode.invalid_union_discriminator:
      g = `Invalid discriminator value. Expected ${util$1.joinValues(d.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      g = `Invalid enum value. Expected ${util$1.joinValues(d.options)}, received '${d.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      g = "Invalid function arguments";
      break;
    case ZodIssueCode.invalid_return_type:
      g = "Invalid function return type";
      break;
    case ZodIssueCode.invalid_date:
      g = "Invalid date";
      break;
    case ZodIssueCode.invalid_string:
      typeof d.validation == "object" ? "includes" in d.validation ? (g = `Invalid input: must include "${d.validation.includes}"`, typeof d.validation.position == "number" && (g = `${g} at one or more positions greater than or equal to ${d.validation.position}`)) : "startsWith" in d.validation ? g = `Invalid input: must start with "${d.validation.startsWith}"` : "endsWith" in d.validation ? g = `Invalid input: must end with "${d.validation.endsWith}"` : util$1.assertNever(d.validation) : g = d.validation !== "regex" ? `Invalid ${d.validation}` : "Invalid";
      break;
    case ZodIssueCode.too_small:
      g = d.type === "array" ? `Array must contain ${d.exact ? "exactly" : d.inclusive ? "at least" : "more than"} ${d.minimum} element(s)` : d.type === "string" ? `String must contain ${d.exact ? "exactly" : d.inclusive ? "at least" : "over"} ${d.minimum} character(s)` : d.type === "number" ? `Number must be ${d.exact ? "exactly equal to " : d.inclusive ? "greater than or equal to " : "greater than "}${d.minimum}` : d.type === "date" ? `Date must be ${d.exact ? "exactly equal to " : d.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(d.minimum))}` : "Invalid input";
      break;
    case ZodIssueCode.too_big:
      g = d.type === "array" ? `Array must contain ${d.exact ? "exactly" : d.inclusive ? "at most" : "less than"} ${d.maximum} element(s)` : d.type === "string" ? `String must contain ${d.exact ? "exactly" : d.inclusive ? "at most" : "under"} ${d.maximum} character(s)` : d.type === "number" ? `Number must be ${d.exact ? "exactly" : d.inclusive ? "less than or equal to" : "less than"} ${d.maximum}` : d.type === "bigint" ? `BigInt must be ${d.exact ? "exactly" : d.inclusive ? "less than or equal to" : "less than"} ${d.maximum}` : d.type === "date" ? `Date must be ${d.exact ? "exactly" : d.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(d.maximum))}` : "Invalid input";
      break;
    case ZodIssueCode.custom:
      g = "Invalid input";
      break;
    case ZodIssueCode.invalid_intersection_types:
      g = "Intersection results could not be merged";
      break;
    case ZodIssueCode.not_multiple_of:
      g = `Number must be a multiple of ${d.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      g = "Number must be finite";
      break;
    default:
      g = m.defaultError, util$1.assertNever(d);
  }
  return { message: g };
};
let overrideErrorMap = errorMap;
function setErrorMap(d) {
  overrideErrorMap = d;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (d) => {
  const { data: m, path: g, errorMaps: w, issueData: I } = d, P = [...g, ...I.path || []], F = { ...I, path: P };
  if (I.message !== void 0) return { ...I, path: P, message: I.message };
  let D = "";
  const U = w.filter((Z) => !!Z).slice().reverse();
  for (const Z of U) D = Z(F, { data: m, defaultError: D }).message;
  return { ...I, path: P, message: D };
}, EMPTY_PATH = [];
function addIssueToContext(d, m) {
  const g = getErrorMap(), w = makeIssue({ issueData: m, data: d.data, path: d.path, errorMaps: [d.common.contextualErrorMap, d.schemaErrorMap, g, g === errorMap ? void 0 : errorMap].filter((I) => !!I) });
  d.common.issues.push(w);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(m, g) {
    const w = [];
    for (const I of g) {
      if (I.status === "aborted") return INVALID;
      I.status === "dirty" && m.dirty(), w.push(I.value);
    }
    return { status: m.value, value: w };
  }
  static async mergeObjectAsync(m, g) {
    const w = [];
    for (const I of g) {
      const P = await I.key, F = await I.value;
      w.push({ key: P, value: F });
    }
    return ParseStatus.mergeObjectSync(m, w);
  }
  static mergeObjectSync(m, g) {
    const w = {};
    for (const I of g) {
      const { key: P, value: F } = I;
      if (P.status === "aborted" || F.status === "aborted") return INVALID;
      P.status === "dirty" && m.dirty(), F.status === "dirty" && m.dirty(), P.value === "__proto__" || F.value === void 0 && !I.alwaysSet || (w[P.value] = F.value);
    }
    return { status: m.value, value: w };
  }
}
const INVALID = Object.freeze({ status: "aborted" }), DIRTY = (d) => ({ status: "dirty", value: d }), OK = (d) => ({ status: "valid", value: d }), isAborted = (d) => d.status === "aborted", isDirty = (d) => d.status === "dirty", isValid = (d) => d.status === "valid", isAsync = (d) => typeof Promise < "u" && d instanceof Promise;
function __classPrivateFieldGet(d, m, g, w) {
  if (typeof m == "function" ? d !== m || !0 : !m.has(d)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return m.get(d);
}
function __classPrivateFieldSet(d, m, g, w, I) {
  if (typeof m == "function" ? d !== m || !0 : !m.has(d)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return m.set(d, g), g;
}
var errorUtil, _ZodEnum_cache, _ZodNativeEnum_cache;
typeof SuppressedError == "function" && SuppressedError, function(d) {
  d.errToObj = (m) => typeof m == "string" ? { message: m } : m || {}, d.toString = (m) => typeof m == "string" ? m : m == null ? void 0 : m.message;
}(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
  constructor(m, g, w, I) {
    this._cachedPath = [], this.parent = m, this.data = g, this._path = w, this._key = I;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const handleResult = (d, m) => {
  if (isValid(m)) return { success: !0, data: m.value };
  if (!d.common.issues.length) throw new Error("Validation failed but no issues detected.");
  return { success: !1, get error() {
    if (this._error) return this._error;
    const g = new ZodError(d.common.issues);
    return this._error = g, this._error;
  } };
};
function processCreateParams(d) {
  if (!d) return {};
  const { errorMap: m, invalid_type_error: g, required_error: w, description: I } = d;
  if (m && (g || w)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return m ? { errorMap: m, description: I } : { errorMap: (P, F) => {
    var D, U;
    const { message: Z } = d;
    return P.code === "invalid_enum_value" ? { message: Z ?? F.defaultError } : F.data === void 0 ? { message: (D = Z ?? w) !== null && D !== void 0 ? D : F.defaultError } : P.code !== "invalid_type" ? { message: F.defaultError } : { message: (U = Z ?? g) !== null && U !== void 0 ? U : F.defaultError };
  }, description: I };
}
class ZodType {
  constructor(m) {
    this.spa = this.safeParseAsync, this._def = m, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(m) {
    return getParsedType(m.data);
  }
  _getOrReturnCtx(m, g) {
    return g || { common: m.parent.common, data: m.data, parsedType: getParsedType(m.data), schemaErrorMap: this._def.errorMap, path: m.path, parent: m.parent };
  }
  _processInputParams(m) {
    return { status: new ParseStatus(), ctx: { common: m.parent.common, data: m.data, parsedType: getParsedType(m.data), schemaErrorMap: this._def.errorMap, path: m.path, parent: m.parent } };
  }
  _parseSync(m) {
    const g = this._parse(m);
    if (isAsync(g)) throw new Error("Synchronous parse encountered promise.");
    return g;
  }
  _parseAsync(m) {
    const g = this._parse(m);
    return Promise.resolve(g);
  }
  parse(m, g) {
    const w = this.safeParse(m, g);
    if (w.success) return w.data;
    throw w.error;
  }
  safeParse(m, g) {
    var w;
    const I = { common: { issues: [], async: (w = g == null ? void 0 : g.async) !== null && w !== void 0 && w, contextualErrorMap: g == null ? void 0 : g.errorMap }, path: (g == null ? void 0 : g.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: m, parsedType: getParsedType(m) }, P = this._parseSync({ data: m, path: I.path, parent: I });
    return handleResult(I, P);
  }
  async parseAsync(m, g) {
    const w = await this.safeParseAsync(m, g);
    if (w.success) return w.data;
    throw w.error;
  }
  async safeParseAsync(m, g) {
    const w = { common: { issues: [], contextualErrorMap: g == null ? void 0 : g.errorMap, async: !0 }, path: (g == null ? void 0 : g.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: m, parsedType: getParsedType(m) }, I = this._parse({ data: m, path: w.path, parent: w }), P = await (isAsync(I) ? I : Promise.resolve(I));
    return handleResult(w, P);
  }
  refine(m, g) {
    const w = (I) => typeof g == "string" || g === void 0 ? { message: g } : typeof g == "function" ? g(I) : g;
    return this._refinement((I, P) => {
      const F = m(I), D = () => P.addIssue({ code: ZodIssueCode.custom, ...w(I) });
      return typeof Promise < "u" && F instanceof Promise ? F.then((U) => !!U || (D(), !1)) : !!F || (D(), !1);
    });
  }
  refinement(m, g) {
    return this._refinement((w, I) => !!m(w) || (I.addIssue(typeof g == "function" ? g(w, I) : g), !1));
  }
  _refinement(m) {
    return new ZodEffects({ schema: this, typeName: ZodFirstPartyTypeKind.ZodEffects, effect: { type: "refinement", refinement: m } });
  }
  superRefine(m) {
    return this._refinement(m);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(m) {
    return ZodUnion.create([this, m], this._def);
  }
  and(m) {
    return ZodIntersection.create(this, m, this._def);
  }
  transform(m) {
    return new ZodEffects({ ...processCreateParams(this._def), schema: this, typeName: ZodFirstPartyTypeKind.ZodEffects, effect: { type: "transform", transform: m } });
  }
  default(m) {
    const g = typeof m == "function" ? m : () => m;
    return new ZodDefault({ ...processCreateParams(this._def), innerType: this, defaultValue: g, typeName: ZodFirstPartyTypeKind.ZodDefault });
  }
  brand() {
    return new ZodBranded({ typeName: ZodFirstPartyTypeKind.ZodBranded, type: this, ...processCreateParams(this._def) });
  }
  catch(m) {
    const g = typeof m == "function" ? m : () => m;
    return new ZodCatch({ ...processCreateParams(this._def), innerType: this, catchValue: g, typeName: ZodFirstPartyTypeKind.ZodCatch });
  }
  describe(m) {
    return new this.constructor({ ...this._def, description: m });
  }
  pipe(m) {
    return ZodPipeline.create(this, m);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i, cuid2Regex = /^[0-9a-z]+$/, ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/, uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, nanoidRegex = /^[a-z0-9_-]{21}$/i, durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, _emojiRegex = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, dateRegexSource = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(d) {
  let m = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return d.precision ? m = `${m}\\.\\d{${d.precision}}` : d.precision == null && (m = `${m}(\\.\\d+)?`), m;
}
function timeRegex(d) {
  return new RegExp(`^${timeRegexSource(d)}$`);
}
function datetimeRegex(d) {
  let m = `${dateRegexSource}T${timeRegexSource(d)}`;
  const g = [];
  return g.push(d.local ? "Z?" : "Z"), d.offset && g.push("([+-]\\d{2}:?\\d{2})"), m = `${m}(${g.join("|")})`, new RegExp(`^${m}$`);
}
function isValidIP(d, m) {
  return !(m !== "v4" && m || !ipv4Regex.test(d)) || !(m !== "v6" && m || !ipv6Regex.test(d));
}
class ZodString extends ZodType {
  _parse(m) {
    if (this._def.coerce && (m.data = String(m.data)), this._getType(m) !== ZodParsedType.string) {
      const I = this._getOrReturnCtx(m);
      return addIssueToContext(I, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.string, received: I.parsedType }), INVALID;
    }
    const g = new ParseStatus();
    let w;
    for (const I of this._def.checks) if (I.kind === "min") m.data.length < I.value && (w = this._getOrReturnCtx(m, w), addIssueToContext(w, { code: ZodIssueCode.too_small, minimum: I.value, type: "string", inclusive: !0, exact: !1, message: I.message }), g.dirty());
    else if (I.kind === "max") m.data.length > I.value && (w = this._getOrReturnCtx(m, w), addIssueToContext(w, { code: ZodIssueCode.too_big, maximum: I.value, type: "string", inclusive: !0, exact: !1, message: I.message }), g.dirty());
    else if (I.kind === "length") {
      const P = m.data.length > I.value, F = m.data.length < I.value;
      (P || F) && (w = this._getOrReturnCtx(m, w), P ? addIssueToContext(w, { code: ZodIssueCode.too_big, maximum: I.value, type: "string", inclusive: !0, exact: !0, message: I.message }) : F && addIssueToContext(w, { code: ZodIssueCode.too_small, minimum: I.value, type: "string", inclusive: !0, exact: !0, message: I.message }), g.dirty());
    } else if (I.kind === "email") emailRegex.test(m.data) || (w = this._getOrReturnCtx(m, w), addIssueToContext(w, { validation: "email", code: ZodIssueCode.invalid_string, message: I.message }), g.dirty());
    else if (I.kind === "emoji") emojiRegex || (emojiRegex = new RegExp(_emojiRegex, "u")), emojiRegex.test(m.data) || (w = this._getOrReturnCtx(m, w), addIssueToContext(w, { validation: "emoji", code: ZodIssueCode.invalid_string, message: I.message }), g.dirty());
    else if (I.kind === "uuid") uuidRegex.test(m.data) || (w = this._getOrReturnCtx(m, w), addIssueToContext(w, { validation: "uuid", code: ZodIssueCode.invalid_string, message: I.message }), g.dirty());
    else if (I.kind === "nanoid") nanoidRegex.test(m.data) || (w = this._getOrReturnCtx(m, w), addIssueToContext(w, { validation: "nanoid", code: ZodIssueCode.invalid_string, message: I.message }), g.dirty());
    else if (I.kind === "cuid") cuidRegex.test(m.data) || (w = this._getOrReturnCtx(m, w), addIssueToContext(w, { validation: "cuid", code: ZodIssueCode.invalid_string, message: I.message }), g.dirty());
    else if (I.kind === "cuid2") cuid2Regex.test(m.data) || (w = this._getOrReturnCtx(m, w), addIssueToContext(w, { validation: "cuid2", code: ZodIssueCode.invalid_string, message: I.message }), g.dirty());
    else if (I.kind === "ulid") ulidRegex.test(m.data) || (w = this._getOrReturnCtx(m, w), addIssueToContext(w, { validation: "ulid", code: ZodIssueCode.invalid_string, message: I.message }), g.dirty());
    else if (I.kind === "url") try {
      new URL(m.data);
    } catch {
      w = this._getOrReturnCtx(m, w), addIssueToContext(w, { validation: "url", code: ZodIssueCode.invalid_string, message: I.message }), g.dirty();
    }
    else I.kind === "regex" ? (I.regex.lastIndex = 0, I.regex.test(m.data) || (w = this._getOrReturnCtx(m, w), addIssueToContext(w, { validation: "regex", code: ZodIssueCode.invalid_string, message: I.message }), g.dirty())) : I.kind === "trim" ? m.data = m.data.trim() : I.kind === "includes" ? m.data.includes(I.value, I.position) || (w = this._getOrReturnCtx(m, w), addIssueToContext(w, { code: ZodIssueCode.invalid_string, validation: { includes: I.value, position: I.position }, message: I.message }), g.dirty()) : I.kind === "toLowerCase" ? m.data = m.data.toLowerCase() : I.kind === "toUpperCase" ? m.data = m.data.toUpperCase() : I.kind === "startsWith" ? m.data.startsWith(I.value) || (w = this._getOrReturnCtx(m, w), addIssueToContext(w, { code: ZodIssueCode.invalid_string, validation: { startsWith: I.value }, message: I.message }), g.dirty()) : I.kind === "endsWith" ? m.data.endsWith(I.value) || (w = this._getOrReturnCtx(m, w), addIssueToContext(w, { code: ZodIssueCode.invalid_string, validation: { endsWith: I.value }, message: I.message }), g.dirty()) : I.kind === "datetime" ? datetimeRegex(I).test(m.data) || (w = this._getOrReturnCtx(m, w), addIssueToContext(w, { code: ZodIssueCode.invalid_string, validation: "datetime", message: I.message }), g.dirty()) : I.kind === "date" ? dateRegex.test(m.data) || (w = this._getOrReturnCtx(m, w), addIssueToContext(w, { code: ZodIssueCode.invalid_string, validation: "date", message: I.message }), g.dirty()) : I.kind === "time" ? timeRegex(I).test(m.data) || (w = this._getOrReturnCtx(m, w), addIssueToContext(w, { code: ZodIssueCode.invalid_string, validation: "time", message: I.message }), g.dirty()) : I.kind === "duration" ? durationRegex.test(m.data) || (w = this._getOrReturnCtx(m, w), addIssueToContext(w, { validation: "duration", code: ZodIssueCode.invalid_string, message: I.message }), g.dirty()) : I.kind === "ip" ? isValidIP(m.data, I.version) || (w = this._getOrReturnCtx(m, w), addIssueToContext(w, { validation: "ip", code: ZodIssueCode.invalid_string, message: I.message }), g.dirty()) : I.kind === "base64" ? base64Regex.test(m.data) || (w = this._getOrReturnCtx(m, w), addIssueToContext(w, { validation: "base64", code: ZodIssueCode.invalid_string, message: I.message }), g.dirty()) : util$1.assertNever(I);
    return { status: g.value, value: m.data };
  }
  _regex(m, g, w) {
    return this.refinement((I) => m.test(I), { validation: g, code: ZodIssueCode.invalid_string, ...errorUtil.errToObj(w) });
  }
  _addCheck(m) {
    return new ZodString({ ...this._def, checks: [...this._def.checks, m] });
  }
  email(m) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(m) });
  }
  url(m) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(m) });
  }
  emoji(m) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(m) });
  }
  uuid(m) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(m) });
  }
  nanoid(m) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(m) });
  }
  cuid(m) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(m) });
  }
  cuid2(m) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(m) });
  }
  ulid(m) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(m) });
  }
  base64(m) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(m) });
  }
  ip(m) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(m) });
  }
  datetime(m) {
    var g, w;
    return typeof m == "string" ? this._addCheck({ kind: "datetime", precision: null, offset: !1, local: !1, message: m }) : this._addCheck({ kind: "datetime", precision: (m == null ? void 0 : m.precision) === void 0 ? null : m == null ? void 0 : m.precision, offset: (g = m == null ? void 0 : m.offset) !== null && g !== void 0 && g, local: (w = m == null ? void 0 : m.local) !== null && w !== void 0 && w, ...errorUtil.errToObj(m == null ? void 0 : m.message) });
  }
  date(m) {
    return this._addCheck({ kind: "date", message: m });
  }
  time(m) {
    return typeof m == "string" ? this._addCheck({ kind: "time", precision: null, message: m }) : this._addCheck({ kind: "time", precision: (m == null ? void 0 : m.precision) === void 0 ? null : m == null ? void 0 : m.precision, ...errorUtil.errToObj(m == null ? void 0 : m.message) });
  }
  duration(m) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(m) });
  }
  regex(m, g) {
    return this._addCheck({ kind: "regex", regex: m, ...errorUtil.errToObj(g) });
  }
  includes(m, g) {
    return this._addCheck({ kind: "includes", value: m, position: g == null ? void 0 : g.position, ...errorUtil.errToObj(g == null ? void 0 : g.message) });
  }
  startsWith(m, g) {
    return this._addCheck({ kind: "startsWith", value: m, ...errorUtil.errToObj(g) });
  }
  endsWith(m, g) {
    return this._addCheck({ kind: "endsWith", value: m, ...errorUtil.errToObj(g) });
  }
  min(m, g) {
    return this._addCheck({ kind: "min", value: m, ...errorUtil.errToObj(g) });
  }
  max(m, g) {
    return this._addCheck({ kind: "max", value: m, ...errorUtil.errToObj(g) });
  }
  length(m, g) {
    return this._addCheck({ kind: "length", value: m, ...errorUtil.errToObj(g) });
  }
  nonempty(m) {
    return this.min(1, errorUtil.errToObj(m));
  }
  trim() {
    return new ZodString({ ...this._def, checks: [...this._def.checks, { kind: "trim" }] });
  }
  toLowerCase() {
    return new ZodString({ ...this._def, checks: [...this._def.checks, { kind: "toLowerCase" }] });
  }
  toUpperCase() {
    return new ZodString({ ...this._def, checks: [...this._def.checks, { kind: "toUpperCase" }] });
  }
  get isDatetime() {
    return !!this._def.checks.find((m) => m.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((m) => m.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((m) => m.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((m) => m.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((m) => m.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((m) => m.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((m) => m.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((m) => m.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((m) => m.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((m) => m.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((m) => m.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((m) => m.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((m) => m.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((m) => m.kind === "base64");
  }
  get minLength() {
    let m = null;
    for (const g of this._def.checks) g.kind === "min" && (m === null || g.value > m) && (m = g.value);
    return m;
  }
  get maxLength() {
    let m = null;
    for (const g of this._def.checks) g.kind === "max" && (m === null || g.value < m) && (m = g.value);
    return m;
  }
}
function floatSafeRemainder(d, m) {
  const g = (d.toString().split(".")[1] || "").length, w = (m.toString().split(".")[1] || "").length, I = g > w ? g : w;
  return parseInt(d.toFixed(I).replace(".", "")) % parseInt(m.toFixed(I).replace(".", "")) / Math.pow(10, I);
}
ZodString.create = (d) => {
  var m;
  return new ZodString({ checks: [], typeName: ZodFirstPartyTypeKind.ZodString, coerce: (m = d == null ? void 0 : d.coerce) !== null && m !== void 0 && m, ...processCreateParams(d) });
};
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(m) {
    if (this._def.coerce && (m.data = Number(m.data)), this._getType(m) !== ZodParsedType.number) {
      const I = this._getOrReturnCtx(m);
      return addIssueToContext(I, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.number, received: I.parsedType }), INVALID;
    }
    let g;
    const w = new ParseStatus();
    for (const I of this._def.checks) I.kind === "int" ? util$1.isInteger(m.data) || (g = this._getOrReturnCtx(m, g), addIssueToContext(g, { code: ZodIssueCode.invalid_type, expected: "integer", received: "float", message: I.message }), w.dirty()) : I.kind === "min" ? (I.inclusive ? m.data < I.value : m.data <= I.value) && (g = this._getOrReturnCtx(m, g), addIssueToContext(g, { code: ZodIssueCode.too_small, minimum: I.value, type: "number", inclusive: I.inclusive, exact: !1, message: I.message }), w.dirty()) : I.kind === "max" ? (I.inclusive ? m.data > I.value : m.data >= I.value) && (g = this._getOrReturnCtx(m, g), addIssueToContext(g, { code: ZodIssueCode.too_big, maximum: I.value, type: "number", inclusive: I.inclusive, exact: !1, message: I.message }), w.dirty()) : I.kind === "multipleOf" ? floatSafeRemainder(m.data, I.value) !== 0 && (g = this._getOrReturnCtx(m, g), addIssueToContext(g, { code: ZodIssueCode.not_multiple_of, multipleOf: I.value, message: I.message }), w.dirty()) : I.kind === "finite" ? Number.isFinite(m.data) || (g = this._getOrReturnCtx(m, g), addIssueToContext(g, { code: ZodIssueCode.not_finite, message: I.message }), w.dirty()) : util$1.assertNever(I);
    return { status: w.value, value: m.data };
  }
  gte(m, g) {
    return this.setLimit("min", m, !0, errorUtil.toString(g));
  }
  gt(m, g) {
    return this.setLimit("min", m, !1, errorUtil.toString(g));
  }
  lte(m, g) {
    return this.setLimit("max", m, !0, errorUtil.toString(g));
  }
  lt(m, g) {
    return this.setLimit("max", m, !1, errorUtil.toString(g));
  }
  setLimit(m, g, w, I) {
    return new ZodNumber({ ...this._def, checks: [...this._def.checks, { kind: m, value: g, inclusive: w, message: errorUtil.toString(I) }] });
  }
  _addCheck(m) {
    return new ZodNumber({ ...this._def, checks: [...this._def.checks, m] });
  }
  int(m) {
    return this._addCheck({ kind: "int", message: errorUtil.toString(m) });
  }
  positive(m) {
    return this._addCheck({ kind: "min", value: 0, inclusive: !1, message: errorUtil.toString(m) });
  }
  negative(m) {
    return this._addCheck({ kind: "max", value: 0, inclusive: !1, message: errorUtil.toString(m) });
  }
  nonpositive(m) {
    return this._addCheck({ kind: "max", value: 0, inclusive: !0, message: errorUtil.toString(m) });
  }
  nonnegative(m) {
    return this._addCheck({ kind: "min", value: 0, inclusive: !0, message: errorUtil.toString(m) });
  }
  multipleOf(m, g) {
    return this._addCheck({ kind: "multipleOf", value: m, message: errorUtil.toString(g) });
  }
  finite(m) {
    return this._addCheck({ kind: "finite", message: errorUtil.toString(m) });
  }
  safe(m) {
    return this._addCheck({ kind: "min", inclusive: !0, value: Number.MIN_SAFE_INTEGER, message: errorUtil.toString(m) })._addCheck({ kind: "max", inclusive: !0, value: Number.MAX_SAFE_INTEGER, message: errorUtil.toString(m) });
  }
  get minValue() {
    let m = null;
    for (const g of this._def.checks) g.kind === "min" && (m === null || g.value > m) && (m = g.value);
    return m;
  }
  get maxValue() {
    let m = null;
    for (const g of this._def.checks) g.kind === "max" && (m === null || g.value < m) && (m = g.value);
    return m;
  }
  get isInt() {
    return !!this._def.checks.find((m) => m.kind === "int" || m.kind === "multipleOf" && util$1.isInteger(m.value));
  }
  get isFinite() {
    let m = null, g = null;
    for (const w of this._def.checks) {
      if (w.kind === "finite" || w.kind === "int" || w.kind === "multipleOf") return !0;
      w.kind === "min" ? (g === null || w.value > g) && (g = w.value) : w.kind === "max" && (m === null || w.value < m) && (m = w.value);
    }
    return Number.isFinite(g) && Number.isFinite(m);
  }
}
ZodNumber.create = (d) => new ZodNumber({ checks: [], typeName: ZodFirstPartyTypeKind.ZodNumber, coerce: (d == null ? void 0 : d.coerce) || !1, ...processCreateParams(d) });
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(m) {
    if (this._def.coerce && (m.data = BigInt(m.data)), this._getType(m) !== ZodParsedType.bigint) {
      const I = this._getOrReturnCtx(m);
      return addIssueToContext(I, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.bigint, received: I.parsedType }), INVALID;
    }
    let g;
    const w = new ParseStatus();
    for (const I of this._def.checks) I.kind === "min" ? (I.inclusive ? m.data < I.value : m.data <= I.value) && (g = this._getOrReturnCtx(m, g), addIssueToContext(g, { code: ZodIssueCode.too_small, type: "bigint", minimum: I.value, inclusive: I.inclusive, message: I.message }), w.dirty()) : I.kind === "max" ? (I.inclusive ? m.data > I.value : m.data >= I.value) && (g = this._getOrReturnCtx(m, g), addIssueToContext(g, { code: ZodIssueCode.too_big, type: "bigint", maximum: I.value, inclusive: I.inclusive, message: I.message }), w.dirty()) : I.kind === "multipleOf" ? m.data % I.value !== BigInt(0) && (g = this._getOrReturnCtx(m, g), addIssueToContext(g, { code: ZodIssueCode.not_multiple_of, multipleOf: I.value, message: I.message }), w.dirty()) : util$1.assertNever(I);
    return { status: w.value, value: m.data };
  }
  gte(m, g) {
    return this.setLimit("min", m, !0, errorUtil.toString(g));
  }
  gt(m, g) {
    return this.setLimit("min", m, !1, errorUtil.toString(g));
  }
  lte(m, g) {
    return this.setLimit("max", m, !0, errorUtil.toString(g));
  }
  lt(m, g) {
    return this.setLimit("max", m, !1, errorUtil.toString(g));
  }
  setLimit(m, g, w, I) {
    return new ZodBigInt({ ...this._def, checks: [...this._def.checks, { kind: m, value: g, inclusive: w, message: errorUtil.toString(I) }] });
  }
  _addCheck(m) {
    return new ZodBigInt({ ...this._def, checks: [...this._def.checks, m] });
  }
  positive(m) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: !1, message: errorUtil.toString(m) });
  }
  negative(m) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: !1, message: errorUtil.toString(m) });
  }
  nonpositive(m) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: !0, message: errorUtil.toString(m) });
  }
  nonnegative(m) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: !0, message: errorUtil.toString(m) });
  }
  multipleOf(m, g) {
    return this._addCheck({ kind: "multipleOf", value: m, message: errorUtil.toString(g) });
  }
  get minValue() {
    let m = null;
    for (const g of this._def.checks) g.kind === "min" && (m === null || g.value > m) && (m = g.value);
    return m;
  }
  get maxValue() {
    let m = null;
    for (const g of this._def.checks) g.kind === "max" && (m === null || g.value < m) && (m = g.value);
    return m;
  }
}
ZodBigInt.create = (d) => {
  var m;
  return new ZodBigInt({ checks: [], typeName: ZodFirstPartyTypeKind.ZodBigInt, coerce: (m = d == null ? void 0 : d.coerce) !== null && m !== void 0 && m, ...processCreateParams(d) });
};
class ZodBoolean extends ZodType {
  _parse(m) {
    if (this._def.coerce && (m.data = !!m.data), this._getType(m) !== ZodParsedType.boolean) {
      const g = this._getOrReturnCtx(m);
      return addIssueToContext(g, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.boolean, received: g.parsedType }), INVALID;
    }
    return OK(m.data);
  }
}
ZodBoolean.create = (d) => new ZodBoolean({ typeName: ZodFirstPartyTypeKind.ZodBoolean, coerce: (d == null ? void 0 : d.coerce) || !1, ...processCreateParams(d) });
class ZodDate extends ZodType {
  _parse(m) {
    if (this._def.coerce && (m.data = new Date(m.data)), this._getType(m) !== ZodParsedType.date) {
      const I = this._getOrReturnCtx(m);
      return addIssueToContext(I, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.date, received: I.parsedType }), INVALID;
    }
    if (isNaN(m.data.getTime()))
      return addIssueToContext(this._getOrReturnCtx(m), { code: ZodIssueCode.invalid_date }), INVALID;
    const g = new ParseStatus();
    let w;
    for (const I of this._def.checks) I.kind === "min" ? m.data.getTime() < I.value && (w = this._getOrReturnCtx(m, w), addIssueToContext(w, { code: ZodIssueCode.too_small, message: I.message, inclusive: !0, exact: !1, minimum: I.value, type: "date" }), g.dirty()) : I.kind === "max" ? m.data.getTime() > I.value && (w = this._getOrReturnCtx(m, w), addIssueToContext(w, { code: ZodIssueCode.too_big, message: I.message, inclusive: !0, exact: !1, maximum: I.value, type: "date" }), g.dirty()) : util$1.assertNever(I);
    return { status: g.value, value: new Date(m.data.getTime()) };
  }
  _addCheck(m) {
    return new ZodDate({ ...this._def, checks: [...this._def.checks, m] });
  }
  min(m, g) {
    return this._addCheck({ kind: "min", value: m.getTime(), message: errorUtil.toString(g) });
  }
  max(m, g) {
    return this._addCheck({ kind: "max", value: m.getTime(), message: errorUtil.toString(g) });
  }
  get minDate() {
    let m = null;
    for (const g of this._def.checks) g.kind === "min" && (m === null || g.value > m) && (m = g.value);
    return m != null ? new Date(m) : null;
  }
  get maxDate() {
    let m = null;
    for (const g of this._def.checks) g.kind === "max" && (m === null || g.value < m) && (m = g.value);
    return m != null ? new Date(m) : null;
  }
}
ZodDate.create = (d) => new ZodDate({ checks: [], coerce: (d == null ? void 0 : d.coerce) || !1, typeName: ZodFirstPartyTypeKind.ZodDate, ...processCreateParams(d) });
class ZodSymbol extends ZodType {
  _parse(m) {
    if (this._getType(m) !== ZodParsedType.symbol) {
      const g = this._getOrReturnCtx(m);
      return addIssueToContext(g, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.symbol, received: g.parsedType }), INVALID;
    }
    return OK(m.data);
  }
}
ZodSymbol.create = (d) => new ZodSymbol({ typeName: ZodFirstPartyTypeKind.ZodSymbol, ...processCreateParams(d) });
class ZodUndefined extends ZodType {
  _parse(m) {
    if (this._getType(m) !== ZodParsedType.undefined) {
      const g = this._getOrReturnCtx(m);
      return addIssueToContext(g, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.undefined, received: g.parsedType }), INVALID;
    }
    return OK(m.data);
  }
}
ZodUndefined.create = (d) => new ZodUndefined({ typeName: ZodFirstPartyTypeKind.ZodUndefined, ...processCreateParams(d) });
class ZodNull extends ZodType {
  _parse(m) {
    if (this._getType(m) !== ZodParsedType.null) {
      const g = this._getOrReturnCtx(m);
      return addIssueToContext(g, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.null, received: g.parsedType }), INVALID;
    }
    return OK(m.data);
  }
}
ZodNull.create = (d) => new ZodNull({ typeName: ZodFirstPartyTypeKind.ZodNull, ...processCreateParams(d) });
class ZodAny extends ZodType {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(m) {
    return OK(m.data);
  }
}
ZodAny.create = (d) => new ZodAny({ typeName: ZodFirstPartyTypeKind.ZodAny, ...processCreateParams(d) });
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(m) {
    return OK(m.data);
  }
}
ZodUnknown.create = (d) => new ZodUnknown({ typeName: ZodFirstPartyTypeKind.ZodUnknown, ...processCreateParams(d) });
class ZodNever extends ZodType {
  _parse(m) {
    const g = this._getOrReturnCtx(m);
    return addIssueToContext(g, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.never, received: g.parsedType }), INVALID;
  }
}
ZodNever.create = (d) => new ZodNever({ typeName: ZodFirstPartyTypeKind.ZodNever, ...processCreateParams(d) });
class ZodVoid extends ZodType {
  _parse(m) {
    if (this._getType(m) !== ZodParsedType.undefined) {
      const g = this._getOrReturnCtx(m);
      return addIssueToContext(g, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.void, received: g.parsedType }), INVALID;
    }
    return OK(m.data);
  }
}
ZodVoid.create = (d) => new ZodVoid({ typeName: ZodFirstPartyTypeKind.ZodVoid, ...processCreateParams(d) });
class ZodArray extends ZodType {
  _parse(m) {
    const { ctx: g, status: w } = this._processInputParams(m), I = this._def;
    if (g.parsedType !== ZodParsedType.array) return addIssueToContext(g, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.array, received: g.parsedType }), INVALID;
    if (I.exactLength !== null) {
      const F = g.data.length > I.exactLength.value, D = g.data.length < I.exactLength.value;
      (F || D) && (addIssueToContext(g, { code: F ? ZodIssueCode.too_big : ZodIssueCode.too_small, minimum: D ? I.exactLength.value : void 0, maximum: F ? I.exactLength.value : void 0, type: "array", inclusive: !0, exact: !0, message: I.exactLength.message }), w.dirty());
    }
    if (I.minLength !== null && g.data.length < I.minLength.value && (addIssueToContext(g, { code: ZodIssueCode.too_small, minimum: I.minLength.value, type: "array", inclusive: !0, exact: !1, message: I.minLength.message }), w.dirty()), I.maxLength !== null && g.data.length > I.maxLength.value && (addIssueToContext(g, { code: ZodIssueCode.too_big, maximum: I.maxLength.value, type: "array", inclusive: !0, exact: !1, message: I.maxLength.message }), w.dirty()), g.common.async) return Promise.all([...g.data].map((F, D) => I.type._parseAsync(new ParseInputLazyPath(g, F, g.path, D)))).then((F) => ParseStatus.mergeArray(w, F));
    const P = [...g.data].map((F, D) => I.type._parseSync(new ParseInputLazyPath(g, F, g.path, D)));
    return ParseStatus.mergeArray(w, P);
  }
  get element() {
    return this._def.type;
  }
  min(m, g) {
    return new ZodArray({ ...this._def, minLength: { value: m, message: errorUtil.toString(g) } });
  }
  max(m, g) {
    return new ZodArray({ ...this._def, maxLength: { value: m, message: errorUtil.toString(g) } });
  }
  length(m, g) {
    return new ZodArray({ ...this._def, exactLength: { value: m, message: errorUtil.toString(g) } });
  }
  nonempty(m) {
    return this.min(1, m);
  }
}
function deepPartialify(d) {
  if (d instanceof ZodObject) {
    const m = {};
    for (const g in d.shape) {
      const w = d.shape[g];
      m[g] = ZodOptional.create(deepPartialify(w));
    }
    return new ZodObject({ ...d._def, shape: () => m });
  }
  return d instanceof ZodArray ? new ZodArray({ ...d._def, type: deepPartialify(d.element) }) : d instanceof ZodOptional ? ZodOptional.create(deepPartialify(d.unwrap())) : d instanceof ZodNullable ? ZodNullable.create(deepPartialify(d.unwrap())) : d instanceof ZodTuple ? ZodTuple.create(d.items.map((m) => deepPartialify(m))) : d;
}
ZodArray.create = (d, m) => new ZodArray({ type: d, minLength: null, maxLength: null, exactLength: null, typeName: ZodFirstPartyTypeKind.ZodArray, ...processCreateParams(m) });
class ZodObject extends ZodType {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    const m = this._def.shape(), g = util$1.objectKeys(m);
    return this._cached = { shape: m, keys: g };
  }
  _parse(m) {
    if (this._getType(m) !== ZodParsedType.object) {
      const U = this._getOrReturnCtx(m);
      return addIssueToContext(U, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.object, received: U.parsedType }), INVALID;
    }
    const { status: g, ctx: w } = this._processInputParams(m), { shape: I, keys: P } = this._getCached(), F = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) for (const U in w.data) P.includes(U) || F.push(U);
    const D = [];
    for (const U of P) {
      const Z = I[U], $ = w.data[U];
      D.push({ key: { status: "valid", value: U }, value: Z._parse(new ParseInputLazyPath(w, $, w.path, U)), alwaysSet: U in w.data });
    }
    if (this._def.catchall instanceof ZodNever) {
      const U = this._def.unknownKeys;
      if (U === "passthrough") for (const Z of F) D.push({ key: { status: "valid", value: Z }, value: { status: "valid", value: w.data[Z] } });
      else if (U === "strict") F.length > 0 && (addIssueToContext(w, { code: ZodIssueCode.unrecognized_keys, keys: F }), g.dirty());
      else if (U !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const U = this._def.catchall;
      for (const Z of F) {
        const $ = w.data[Z];
        D.push({ key: { status: "valid", value: Z }, value: U._parse(new ParseInputLazyPath(w, $, w.path, Z)), alwaysSet: Z in w.data });
      }
    }
    return w.common.async ? Promise.resolve().then(async () => {
      const U = [];
      for (const Z of D) {
        const $ = await Z.key, j = await Z.value;
        U.push({ key: $, value: j, alwaysSet: Z.alwaysSet });
      }
      return U;
    }).then((U) => ParseStatus.mergeObjectSync(g, U)) : ParseStatus.mergeObjectSync(g, D);
  }
  get shape() {
    return this._def.shape();
  }
  strict(m) {
    return errorUtil.errToObj, new ZodObject({ ...this._def, unknownKeys: "strict", ...m !== void 0 ? { errorMap: (g, w) => {
      var I, P, F, D;
      const U = (F = (P = (I = this._def).errorMap) === null || P === void 0 ? void 0 : P.call(I, g, w).message) !== null && F !== void 0 ? F : w.defaultError;
      return g.code === "unrecognized_keys" ? { message: (D = errorUtil.errToObj(m).message) !== null && D !== void 0 ? D : U } : { message: U };
    } } : {} });
  }
  strip() {
    return new ZodObject({ ...this._def, unknownKeys: "strip" });
  }
  passthrough() {
    return new ZodObject({ ...this._def, unknownKeys: "passthrough" });
  }
  extend(m) {
    return new ZodObject({ ...this._def, shape: () => ({ ...this._def.shape(), ...m }) });
  }
  merge(m) {
    return new ZodObject({ unknownKeys: m._def.unknownKeys, catchall: m._def.catchall, shape: () => ({ ...this._def.shape(), ...m._def.shape() }), typeName: ZodFirstPartyTypeKind.ZodObject });
  }
  setKey(m, g) {
    return this.augment({ [m]: g });
  }
  catchall(m) {
    return new ZodObject({ ...this._def, catchall: m });
  }
  pick(m) {
    const g = {};
    return util$1.objectKeys(m).forEach((w) => {
      m[w] && this.shape[w] && (g[w] = this.shape[w]);
    }), new ZodObject({ ...this._def, shape: () => g });
  }
  omit(m) {
    const g = {};
    return util$1.objectKeys(this.shape).forEach((w) => {
      m[w] || (g[w] = this.shape[w]);
    }), new ZodObject({ ...this._def, shape: () => g });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(m) {
    const g = {};
    return util$1.objectKeys(this.shape).forEach((w) => {
      const I = this.shape[w];
      m && !m[w] ? g[w] = I : g[w] = I.optional();
    }), new ZodObject({ ...this._def, shape: () => g });
  }
  required(m) {
    const g = {};
    return util$1.objectKeys(this.shape).forEach((w) => {
      if (m && !m[w]) g[w] = this.shape[w];
      else {
        let I = this.shape[w];
        for (; I instanceof ZodOptional; ) I = I._def.innerType;
        g[w] = I;
      }
    }), new ZodObject({ ...this._def, shape: () => g });
  }
  keyof() {
    return createZodEnum(util$1.objectKeys(this.shape));
  }
}
ZodObject.create = (d, m) => new ZodObject({ shape: () => d, unknownKeys: "strip", catchall: ZodNever.create(), typeName: ZodFirstPartyTypeKind.ZodObject, ...processCreateParams(m) }), ZodObject.strictCreate = (d, m) => new ZodObject({ shape: () => d, unknownKeys: "strict", catchall: ZodNever.create(), typeName: ZodFirstPartyTypeKind.ZodObject, ...processCreateParams(m) }), ZodObject.lazycreate = (d, m) => new ZodObject({ shape: d, unknownKeys: "strip", catchall: ZodNever.create(), typeName: ZodFirstPartyTypeKind.ZodObject, ...processCreateParams(m) });
class ZodUnion extends ZodType {
  _parse(m) {
    const { ctx: g } = this._processInputParams(m), w = this._def.options;
    if (g.common.async) return Promise.all(w.map(async (I) => {
      const P = { ...g, common: { ...g.common, issues: [] }, parent: null };
      return { result: await I._parseAsync({ data: g.data, path: g.path, parent: P }), ctx: P };
    })).then(function(I) {
      for (const F of I) if (F.result.status === "valid") return F.result;
      for (const F of I) if (F.result.status === "dirty") return g.common.issues.push(...F.ctx.common.issues), F.result;
      const P = I.map((F) => new ZodError(F.ctx.common.issues));
      return addIssueToContext(g, { code: ZodIssueCode.invalid_union, unionErrors: P }), INVALID;
    });
    {
      let I;
      const P = [];
      for (const D of w) {
        const U = { ...g, common: { ...g.common, issues: [] }, parent: null }, Z = D._parseSync({ data: g.data, path: g.path, parent: U });
        if (Z.status === "valid") return Z;
        Z.status !== "dirty" || I || (I = { result: Z, ctx: U }), U.common.issues.length && P.push(U.common.issues);
      }
      if (I) return g.common.issues.push(...I.ctx.common.issues), I.result;
      const F = P.map((D) => new ZodError(D));
      return addIssueToContext(g, { code: ZodIssueCode.invalid_union, unionErrors: F }), INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (d, m) => new ZodUnion({ options: d, typeName: ZodFirstPartyTypeKind.ZodUnion, ...processCreateParams(m) });
const getDiscriminator = (d) => d instanceof ZodLazy ? getDiscriminator(d.schema) : d instanceof ZodEffects ? getDiscriminator(d.innerType()) : d instanceof ZodLiteral ? [d.value] : d instanceof ZodEnum ? d.options : d instanceof ZodNativeEnum ? util$1.objectValues(d.enum) : d instanceof ZodDefault ? getDiscriminator(d._def.innerType) : d instanceof ZodUndefined ? [void 0] : d instanceof ZodNull ? [null] : d instanceof ZodOptional ? [void 0, ...getDiscriminator(d.unwrap())] : d instanceof ZodNullable ? [null, ...getDiscriminator(d.unwrap())] : d instanceof ZodBranded || d instanceof ZodReadonly ? getDiscriminator(d.unwrap()) : d instanceof ZodCatch ? getDiscriminator(d._def.innerType) : [];
class ZodDiscriminatedUnion extends ZodType {
  _parse(m) {
    const { ctx: g } = this._processInputParams(m);
    if (g.parsedType !== ZodParsedType.object) return addIssueToContext(g, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.object, received: g.parsedType }), INVALID;
    const w = this.discriminator, I = g.data[w], P = this.optionsMap.get(I);
    return P ? g.common.async ? P._parseAsync({ data: g.data, path: g.path, parent: g }) : P._parseSync({ data: g.data, path: g.path, parent: g }) : (addIssueToContext(g, { code: ZodIssueCode.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [w] }), INVALID);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(m, g, w) {
    const I = /* @__PURE__ */ new Map();
    for (const P of g) {
      const F = getDiscriminator(P.shape[m]);
      if (!F.length) throw new Error(`A discriminator value for key \`${m}\` could not be extracted from all schema options`);
      for (const D of F) {
        if (I.has(D)) throw new Error(`Discriminator property ${String(m)} has duplicate value ${String(D)}`);
        I.set(D, P);
      }
    }
    return new ZodDiscriminatedUnion({ typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion, discriminator: m, options: g, optionsMap: I, ...processCreateParams(w) });
  }
}
function mergeValues(d, m) {
  const g = getParsedType(d), w = getParsedType(m);
  if (d === m) return { valid: !0, data: d };
  if (g === ZodParsedType.object && w === ZodParsedType.object) {
    const I = util$1.objectKeys(m), P = util$1.objectKeys(d).filter((D) => I.indexOf(D) !== -1), F = { ...d, ...m };
    for (const D of P) {
      const U = mergeValues(d[D], m[D]);
      if (!U.valid) return { valid: !1 };
      F[D] = U.data;
    }
    return { valid: !0, data: F };
  }
  if (g === ZodParsedType.array && w === ZodParsedType.array) {
    if (d.length !== m.length) return { valid: !1 };
    const I = [];
    for (let P = 0; P < d.length; P++) {
      const F = mergeValues(d[P], m[P]);
      if (!F.valid) return { valid: !1 };
      I.push(F.data);
    }
    return { valid: !0, data: I };
  }
  return g === ZodParsedType.date && w === ZodParsedType.date && +d == +m ? { valid: !0, data: d } : { valid: !1 };
}
class ZodIntersection extends ZodType {
  _parse(m) {
    const { status: g, ctx: w } = this._processInputParams(m), I = (P, F) => {
      if (isAborted(P) || isAborted(F)) return INVALID;
      const D = mergeValues(P.value, F.value);
      return D.valid ? ((isDirty(P) || isDirty(F)) && g.dirty(), { status: g.value, value: D.data }) : (addIssueToContext(w, { code: ZodIssueCode.invalid_intersection_types }), INVALID);
    };
    return w.common.async ? Promise.all([this._def.left._parseAsync({ data: w.data, path: w.path, parent: w }), this._def.right._parseAsync({ data: w.data, path: w.path, parent: w })]).then(([P, F]) => I(P, F)) : I(this._def.left._parseSync({ data: w.data, path: w.path, parent: w }), this._def.right._parseSync({ data: w.data, path: w.path, parent: w }));
  }
}
ZodIntersection.create = (d, m, g) => new ZodIntersection({ left: d, right: m, typeName: ZodFirstPartyTypeKind.ZodIntersection, ...processCreateParams(g) });
class ZodTuple extends ZodType {
  _parse(m) {
    const { status: g, ctx: w } = this._processInputParams(m);
    if (w.parsedType !== ZodParsedType.array) return addIssueToContext(w, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.array, received: w.parsedType }), INVALID;
    if (w.data.length < this._def.items.length) return addIssueToContext(w, { code: ZodIssueCode.too_small, minimum: this._def.items.length, inclusive: !0, exact: !1, type: "array" }), INVALID;
    !this._def.rest && w.data.length > this._def.items.length && (addIssueToContext(w, { code: ZodIssueCode.too_big, maximum: this._def.items.length, inclusive: !0, exact: !1, type: "array" }), g.dirty());
    const I = [...w.data].map((P, F) => {
      const D = this._def.items[F] || this._def.rest;
      return D ? D._parse(new ParseInputLazyPath(w, P, w.path, F)) : null;
    }).filter((P) => !!P);
    return w.common.async ? Promise.all(I).then((P) => ParseStatus.mergeArray(g, P)) : ParseStatus.mergeArray(g, I);
  }
  get items() {
    return this._def.items;
  }
  rest(m) {
    return new ZodTuple({ ...this._def, rest: m });
  }
}
ZodTuple.create = (d, m) => {
  if (!Array.isArray(d)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ZodTuple({ items: d, typeName: ZodFirstPartyTypeKind.ZodTuple, rest: null, ...processCreateParams(m) });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(m) {
    const { status: g, ctx: w } = this._processInputParams(m);
    if (w.parsedType !== ZodParsedType.object) return addIssueToContext(w, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.object, received: w.parsedType }), INVALID;
    const I = [], P = this._def.keyType, F = this._def.valueType;
    for (const D in w.data) I.push({ key: P._parse(new ParseInputLazyPath(w, D, w.path, D)), value: F._parse(new ParseInputLazyPath(w, w.data[D], w.path, D)), alwaysSet: D in w.data });
    return w.common.async ? ParseStatus.mergeObjectAsync(g, I) : ParseStatus.mergeObjectSync(g, I);
  }
  get element() {
    return this._def.valueType;
  }
  static create(m, g, w) {
    return new ZodRecord(g instanceof ZodType ? { keyType: m, valueType: g, typeName: ZodFirstPartyTypeKind.ZodRecord, ...processCreateParams(w) } : { keyType: ZodString.create(), valueType: m, typeName: ZodFirstPartyTypeKind.ZodRecord, ...processCreateParams(g) });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(m) {
    const { status: g, ctx: w } = this._processInputParams(m);
    if (w.parsedType !== ZodParsedType.map) return addIssueToContext(w, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.map, received: w.parsedType }), INVALID;
    const I = this._def.keyType, P = this._def.valueType, F = [...w.data.entries()].map(([D, U], Z) => ({ key: I._parse(new ParseInputLazyPath(w, D, w.path, [Z, "key"])), value: P._parse(new ParseInputLazyPath(w, U, w.path, [Z, "value"])) }));
    if (w.common.async) {
      const D = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const U of F) {
          const Z = await U.key, $ = await U.value;
          if (Z.status === "aborted" || $.status === "aborted") return INVALID;
          Z.status !== "dirty" && $.status !== "dirty" || g.dirty(), D.set(Z.value, $.value);
        }
        return { status: g.value, value: D };
      });
    }
    {
      const D = /* @__PURE__ */ new Map();
      for (const U of F) {
        const Z = U.key, $ = U.value;
        if (Z.status === "aborted" || $.status === "aborted") return INVALID;
        Z.status !== "dirty" && $.status !== "dirty" || g.dirty(), D.set(Z.value, $.value);
      }
      return { status: g.value, value: D };
    }
  }
}
ZodMap.create = (d, m, g) => new ZodMap({ valueType: m, keyType: d, typeName: ZodFirstPartyTypeKind.ZodMap, ...processCreateParams(g) });
class ZodSet extends ZodType {
  _parse(m) {
    const { status: g, ctx: w } = this._processInputParams(m);
    if (w.parsedType !== ZodParsedType.set) return addIssueToContext(w, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.set, received: w.parsedType }), INVALID;
    const I = this._def;
    I.minSize !== null && w.data.size < I.minSize.value && (addIssueToContext(w, { code: ZodIssueCode.too_small, minimum: I.minSize.value, type: "set", inclusive: !0, exact: !1, message: I.minSize.message }), g.dirty()), I.maxSize !== null && w.data.size > I.maxSize.value && (addIssueToContext(w, { code: ZodIssueCode.too_big, maximum: I.maxSize.value, type: "set", inclusive: !0, exact: !1, message: I.maxSize.message }), g.dirty());
    const P = this._def.valueType;
    function F(U) {
      const Z = /* @__PURE__ */ new Set();
      for (const $ of U) {
        if ($.status === "aborted") return INVALID;
        $.status === "dirty" && g.dirty(), Z.add($.value);
      }
      return { status: g.value, value: Z };
    }
    const D = [...w.data.values()].map((U, Z) => P._parse(new ParseInputLazyPath(w, U, w.path, Z)));
    return w.common.async ? Promise.all(D).then((U) => F(U)) : F(D);
  }
  min(m, g) {
    return new ZodSet({ ...this._def, minSize: { value: m, message: errorUtil.toString(g) } });
  }
  max(m, g) {
    return new ZodSet({ ...this._def, maxSize: { value: m, message: errorUtil.toString(g) } });
  }
  size(m, g) {
    return this.min(m, g).max(m, g);
  }
  nonempty(m) {
    return this.min(1, m);
  }
}
ZodSet.create = (d, m) => new ZodSet({ valueType: d, minSize: null, maxSize: null, typeName: ZodFirstPartyTypeKind.ZodSet, ...processCreateParams(m) });
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(m) {
    const { ctx: g } = this._processInputParams(m);
    if (g.parsedType !== ZodParsedType.function) return addIssueToContext(g, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.function, received: g.parsedType }), INVALID;
    function w(D, U) {
      return makeIssue({ data: D, path: g.path, errorMaps: [g.common.contextualErrorMap, g.schemaErrorMap, getErrorMap(), errorMap].filter((Z) => !!Z), issueData: { code: ZodIssueCode.invalid_arguments, argumentsError: U } });
    }
    function I(D, U) {
      return makeIssue({ data: D, path: g.path, errorMaps: [g.common.contextualErrorMap, g.schemaErrorMap, getErrorMap(), errorMap].filter((Z) => !!Z), issueData: { code: ZodIssueCode.invalid_return_type, returnTypeError: U } });
    }
    const P = { errorMap: g.common.contextualErrorMap }, F = g.data;
    if (this._def.returns instanceof ZodPromise) {
      const D = this;
      return OK(async function(...U) {
        const Z = new ZodError([]), $ = await D._def.args.parseAsync(U, P).catch((Q) => {
          throw Z.addIssue(w(U, Q)), Z;
        }), j = await Reflect.apply(F, this, $);
        return await D._def.returns._def.type.parseAsync(j, P).catch((Q) => {
          throw Z.addIssue(I(j, Q)), Z;
        });
      });
    }
    {
      const D = this;
      return OK(function(...U) {
        const Z = D._def.args.safeParse(U, P);
        if (!Z.success) throw new ZodError([w(U, Z.error)]);
        const $ = Reflect.apply(F, this, Z.data), j = D._def.returns.safeParse($, P);
        if (!j.success) throw new ZodError([I($, j.error)]);
        return j.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...m) {
    return new ZodFunction({ ...this._def, args: ZodTuple.create(m).rest(ZodUnknown.create()) });
  }
  returns(m) {
    return new ZodFunction({ ...this._def, returns: m });
  }
  implement(m) {
    return this.parse(m);
  }
  strictImplement(m) {
    return this.parse(m);
  }
  static create(m, g, w) {
    return new ZodFunction({ args: m || ZodTuple.create([]).rest(ZodUnknown.create()), returns: g || ZodUnknown.create(), typeName: ZodFirstPartyTypeKind.ZodFunction, ...processCreateParams(w) });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(m) {
    const { ctx: g } = this._processInputParams(m);
    return this._def.getter()._parse({ data: g.data, path: g.path, parent: g });
  }
}
ZodLazy.create = (d, m) => new ZodLazy({ getter: d, typeName: ZodFirstPartyTypeKind.ZodLazy, ...processCreateParams(m) });
class ZodLiteral extends ZodType {
  _parse(m) {
    if (m.data !== this._def.value) {
      const g = this._getOrReturnCtx(m);
      return addIssueToContext(g, { received: g.data, code: ZodIssueCode.invalid_literal, expected: this._def.value }), INVALID;
    }
    return { status: "valid", value: m.data };
  }
  get value() {
    return this._def.value;
  }
}
function createZodEnum(d, m) {
  return new ZodEnum({ values: d, typeName: ZodFirstPartyTypeKind.ZodEnum, ...processCreateParams(m) });
}
ZodLiteral.create = (d, m) => new ZodLiteral({ value: d, typeName: ZodFirstPartyTypeKind.ZodLiteral, ...processCreateParams(m) });
class ZodEnum extends ZodType {
  constructor() {
    super(...arguments), _ZodEnum_cache.set(this, void 0);
  }
  _parse(m) {
    if (typeof m.data != "string") {
      const g = this._getOrReturnCtx(m), w = this._def.values;
      return addIssueToContext(g, { expected: util$1.joinValues(w), received: g.parsedType, code: ZodIssueCode.invalid_type }), INVALID;
    }
    if (__classPrivateFieldGet(this, _ZodEnum_cache) || __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values)), !__classPrivateFieldGet(this, _ZodEnum_cache).has(m.data)) {
      const g = this._getOrReturnCtx(m), w = this._def.values;
      return addIssueToContext(g, { received: g.data, code: ZodIssueCode.invalid_enum_value, options: w }), INVALID;
    }
    return OK(m.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const m = {};
    for (const g of this._def.values) m[g] = g;
    return m;
  }
  get Values() {
    const m = {};
    for (const g of this._def.values) m[g] = g;
    return m;
  }
  get Enum() {
    const m = {};
    for (const g of this._def.values) m[g] = g;
    return m;
  }
  extract(m, g = this._def) {
    return ZodEnum.create(m, { ...this._def, ...g });
  }
  exclude(m, g = this._def) {
    return ZodEnum.create(this.options.filter((w) => !m.includes(w)), { ...this._def, ...g });
  }
}
_ZodEnum_cache = /* @__PURE__ */ new WeakMap(), ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments), _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(m) {
    const g = util$1.getValidEnumValues(this._def.values), w = this._getOrReturnCtx(m);
    if (w.parsedType !== ZodParsedType.string && w.parsedType !== ZodParsedType.number) {
      const I = util$1.objectValues(g);
      return addIssueToContext(w, { expected: util$1.joinValues(I), received: w.parsedType, code: ZodIssueCode.invalid_type }), INVALID;
    }
    if (__classPrivateFieldGet(this, _ZodNativeEnum_cache) || __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util$1.getValidEnumValues(this._def.values))), !__classPrivateFieldGet(this, _ZodNativeEnum_cache).has(m.data)) {
      const I = util$1.objectValues(g);
      return addIssueToContext(w, { received: w.data, code: ZodIssueCode.invalid_enum_value, options: I }), INVALID;
    }
    return OK(m.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap(), ZodNativeEnum.create = (d, m) => new ZodNativeEnum({ values: d, typeName: ZodFirstPartyTypeKind.ZodNativeEnum, ...processCreateParams(m) });
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(m) {
    const { ctx: g } = this._processInputParams(m);
    if (g.parsedType !== ZodParsedType.promise && g.common.async === !1) return addIssueToContext(g, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.promise, received: g.parsedType }), INVALID;
    const w = g.parsedType === ZodParsedType.promise ? g.data : Promise.resolve(g.data);
    return OK(w.then((I) => this._def.type.parseAsync(I, { path: g.path, errorMap: g.common.contextualErrorMap })));
  }
}
ZodPromise.create = (d, m) => new ZodPromise({ type: d, typeName: ZodFirstPartyTypeKind.ZodPromise, ...processCreateParams(m) });
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(m) {
    const { status: g, ctx: w } = this._processInputParams(m), I = this._def.effect || null, P = { addIssue: (F) => {
      addIssueToContext(w, F), F.fatal ? g.abort() : g.dirty();
    }, get path() {
      return w.path;
    } };
    if (P.addIssue = P.addIssue.bind(P), I.type === "preprocess") {
      const F = I.transform(w.data, P);
      if (w.common.async) return Promise.resolve(F).then(async (D) => {
        if (g.value === "aborted") return INVALID;
        const U = await this._def.schema._parseAsync({ data: D, path: w.path, parent: w });
        return U.status === "aborted" ? INVALID : U.status === "dirty" || g.value === "dirty" ? DIRTY(U.value) : U;
      });
      {
        if (g.value === "aborted") return INVALID;
        const D = this._def.schema._parseSync({ data: F, path: w.path, parent: w });
        return D.status === "aborted" ? INVALID : D.status === "dirty" || g.value === "dirty" ? DIRTY(D.value) : D;
      }
    }
    if (I.type === "refinement") {
      const F = (D) => {
        const U = I.refinement(D, P);
        if (w.common.async) return Promise.resolve(U);
        if (U instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return D;
      };
      if (w.common.async === !1) {
        const D = this._def.schema._parseSync({ data: w.data, path: w.path, parent: w });
        return D.status === "aborted" ? INVALID : (D.status === "dirty" && g.dirty(), F(D.value), { status: g.value, value: D.value });
      }
      return this._def.schema._parseAsync({ data: w.data, path: w.path, parent: w }).then((D) => D.status === "aborted" ? INVALID : (D.status === "dirty" && g.dirty(), F(D.value).then(() => ({ status: g.value, value: D.value }))));
    }
    if (I.type === "transform") {
      if (w.common.async === !1) {
        const F = this._def.schema._parseSync({ data: w.data, path: w.path, parent: w });
        if (!isValid(F)) return F;
        const D = I.transform(F.value, P);
        if (D instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: g.value, value: D };
      }
      return this._def.schema._parseAsync({ data: w.data, path: w.path, parent: w }).then((F) => isValid(F) ? Promise.resolve(I.transform(F.value, P)).then((D) => ({ status: g.value, value: D })) : F);
    }
    util$1.assertNever(I);
  }
}
ZodEffects.create = (d, m, g) => new ZodEffects({ schema: d, typeName: ZodFirstPartyTypeKind.ZodEffects, effect: m, ...processCreateParams(g) }), ZodEffects.createWithPreprocess = (d, m, g) => new ZodEffects({ schema: m, effect: { type: "preprocess", transform: d }, typeName: ZodFirstPartyTypeKind.ZodEffects, ...processCreateParams(g) });
class ZodOptional extends ZodType {
  _parse(m) {
    return this._getType(m) === ZodParsedType.undefined ? OK(void 0) : this._def.innerType._parse(m);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (d, m) => new ZodOptional({ innerType: d, typeName: ZodFirstPartyTypeKind.ZodOptional, ...processCreateParams(m) });
class ZodNullable extends ZodType {
  _parse(m) {
    return this._getType(m) === ZodParsedType.null ? OK(null) : this._def.innerType._parse(m);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (d, m) => new ZodNullable({ innerType: d, typeName: ZodFirstPartyTypeKind.ZodNullable, ...processCreateParams(m) });
class ZodDefault extends ZodType {
  _parse(m) {
    const { ctx: g } = this._processInputParams(m);
    let w = g.data;
    return g.parsedType === ZodParsedType.undefined && (w = this._def.defaultValue()), this._def.innerType._parse({ data: w, path: g.path, parent: g });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (d, m) => new ZodDefault({ innerType: d, typeName: ZodFirstPartyTypeKind.ZodDefault, defaultValue: typeof m.default == "function" ? m.default : () => m.default, ...processCreateParams(m) });
class ZodCatch extends ZodType {
  _parse(m) {
    const { ctx: g } = this._processInputParams(m), w = { ...g, common: { ...g.common, issues: [] } }, I = this._def.innerType._parse({ data: w.data, path: w.path, parent: { ...w } });
    return isAsync(I) ? I.then((P) => ({ status: "valid", value: P.status === "valid" ? P.value : this._def.catchValue({ get error() {
      return new ZodError(w.common.issues);
    }, input: w.data }) })) : { status: "valid", value: I.status === "valid" ? I.value : this._def.catchValue({ get error() {
      return new ZodError(w.common.issues);
    }, input: w.data }) };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (d, m) => new ZodCatch({ innerType: d, typeName: ZodFirstPartyTypeKind.ZodCatch, catchValue: typeof m.catch == "function" ? m.catch : () => m.catch, ...processCreateParams(m) });
class ZodNaN extends ZodType {
  _parse(m) {
    if (this._getType(m) !== ZodParsedType.nan) {
      const g = this._getOrReturnCtx(m);
      return addIssueToContext(g, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.nan, received: g.parsedType }), INVALID;
    }
    return { status: "valid", value: m.data };
  }
}
ZodNaN.create = (d) => new ZodNaN({ typeName: ZodFirstPartyTypeKind.ZodNaN, ...processCreateParams(d) });
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(m) {
    const { ctx: g } = this._processInputParams(m), w = g.data;
    return this._def.type._parse({ data: w, path: g.path, parent: g });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(m) {
    const { status: g, ctx: w } = this._processInputParams(m);
    if (w.common.async)
      return (async () => {
        const I = await this._def.in._parseAsync({ data: w.data, path: w.path, parent: w });
        return I.status === "aborted" ? INVALID : I.status === "dirty" ? (g.dirty(), DIRTY(I.value)) : this._def.out._parseAsync({ data: I.value, path: w.path, parent: w });
      })();
    {
      const I = this._def.in._parseSync({ data: w.data, path: w.path, parent: w });
      return I.status === "aborted" ? INVALID : I.status === "dirty" ? (g.dirty(), { status: "dirty", value: I.value }) : this._def.out._parseSync({ data: I.value, path: w.path, parent: w });
    }
  }
  static create(m, g) {
    return new ZodPipeline({ in: m, out: g, typeName: ZodFirstPartyTypeKind.ZodPipeline });
  }
}
class ZodReadonly extends ZodType {
  _parse(m) {
    const g = this._def.innerType._parse(m), w = (I) => (isValid(I) && (I.value = Object.freeze(I.value)), I);
    return isAsync(g) ? g.then((I) => w(I)) : w(g);
  }
  unwrap() {
    return this._def.innerType;
  }
}
function custom(d, m = {}, g) {
  return d ? ZodAny.create().superRefine((w, I) => {
    var P, F;
    if (!d(w)) {
      const D = typeof m == "function" ? m(w) : typeof m == "string" ? { message: m } : m, U = (F = (P = D.fatal) !== null && P !== void 0 ? P : g) === null || F === void 0 || F, Z = typeof D == "string" ? { message: D } : D;
      I.addIssue({ code: "custom", ...Z, fatal: U });
    }
  }) : ZodAny.create();
}
ZodReadonly.create = (d, m) => new ZodReadonly({ innerType: d, typeName: ZodFirstPartyTypeKind.ZodReadonly, ...processCreateParams(m) });
const late = { object: ZodObject.lazycreate };
var ZodFirstPartyTypeKind;
(function(d) {
  d.ZodString = "ZodString", d.ZodNumber = "ZodNumber", d.ZodNaN = "ZodNaN", d.ZodBigInt = "ZodBigInt", d.ZodBoolean = "ZodBoolean", d.ZodDate = "ZodDate", d.ZodSymbol = "ZodSymbol", d.ZodUndefined = "ZodUndefined", d.ZodNull = "ZodNull", d.ZodAny = "ZodAny", d.ZodUnknown = "ZodUnknown", d.ZodNever = "ZodNever", d.ZodVoid = "ZodVoid", d.ZodArray = "ZodArray", d.ZodObject = "ZodObject", d.ZodUnion = "ZodUnion", d.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", d.ZodIntersection = "ZodIntersection", d.ZodTuple = "ZodTuple", d.ZodRecord = "ZodRecord", d.ZodMap = "ZodMap", d.ZodSet = "ZodSet", d.ZodFunction = "ZodFunction", d.ZodLazy = "ZodLazy", d.ZodLiteral = "ZodLiteral", d.ZodEnum = "ZodEnum", d.ZodEffects = "ZodEffects", d.ZodNativeEnum = "ZodNativeEnum", d.ZodOptional = "ZodOptional", d.ZodNullable = "ZodNullable", d.ZodDefault = "ZodDefault", d.ZodCatch = "ZodCatch", d.ZodPromise = "ZodPromise", d.ZodBranded = "ZodBranded", d.ZodPipeline = "ZodPipeline", d.ZodReadonly = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (d, m = { message: `Input not instance of ${d.name}` }) => custom((g) => g instanceof d, m), stringType = ZodString.create, numberType = ZodNumber.create, nanType = ZodNaN.create, bigIntType = ZodBigInt.create, booleanType = ZodBoolean.create, dateType = ZodDate.create, symbolType = ZodSymbol.create, undefinedType = ZodUndefined.create, nullType = ZodNull.create, anyType = ZodAny.create, unknownType = ZodUnknown.create, neverType = ZodNever.create, voidType = ZodVoid.create, arrayType = ZodArray.create, objectType = ZodObject.create, strictObjectType = ZodObject.strictCreate, unionType = ZodUnion.create, discriminatedUnionType = ZodDiscriminatedUnion.create, intersectionType = ZodIntersection.create, tupleType = ZodTuple.create, recordType = ZodRecord.create, mapType = ZodMap.create, setType = ZodSet.create, functionType = ZodFunction.create, lazyType = ZodLazy.create, literalType = ZodLiteral.create, enumType = ZodEnum.create, nativeEnumType = ZodNativeEnum.create, promiseType = ZodPromise.create, effectsType = ZodEffects.create, optionalType = ZodOptional.create, nullableType = ZodNullable.create, preprocessType = ZodEffects.createWithPreprocess, pipelineType = ZodPipeline.create, ostring = () => stringType().optional(), onumber = () => numberType().optional(), oboolean = () => booleanType().optional(), coerce = { string: (d) => ZodString.create({ ...d, coerce: !0 }), number: (d) => ZodNumber.create({ ...d, coerce: !0 }), boolean: (d) => ZodBoolean.create({ ...d, coerce: !0 }), bigint: (d) => ZodBigInt.create({ ...d, coerce: !0 }), date: (d) => ZodDate.create({ ...d, coerce: !0 }) }, NEVER = INVALID;
var z = Object.freeze({ __proto__: null, defaultErrorMap: errorMap, setErrorMap, getErrorMap, makeIssue, EMPTY_PATH, addIssueToContext, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync, get util() {
  return util$1;
}, get objectUtil() {
  return objectUtil;
}, ZodParsedType, getParsedType, ZodType, datetimeRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodTransformer: ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, custom, Schema: ZodType, ZodSchema: ZodType, late, get ZodFirstPartyTypeKind() {
  return ZodFirstPartyTypeKind;
}, coerce, any: anyType, array: arrayType, bigint: bigIntType, boolean: booleanType, date: dateType, discriminatedUnion: discriminatedUnionType, effect: effectsType, enum: enumType, function: functionType, instanceof: instanceOfType, intersection: intersectionType, lazy: lazyType, literal: literalType, map: mapType, nan: nanType, nativeEnum: nativeEnumType, never: neverType, null: nullType, nullable: nullableType, number: numberType, object: objectType, oboolean, onumber, optional: optionalType, ostring, pipeline: pipelineType, preprocess: preprocessType, promise: promiseType, record: recordType, set: setType, strictObject: strictObjectType, string: stringType, symbol: symbolType, transformer: effectsType, tuple: tupleType, undefined: undefinedType, union: unionType, unknown: unknownType, void: voidType, NEVER, ZodIssueCode, quotelessJson, ZodError }), Edge, Edge2;
Edge2 = Edge || (Edge = {}), Edge2[Edge2.EXTEND = 1] = "EXTEND", Edge2[Edge2.WRAP = 2] = "WRAP", Edge2[Edge2.CROP = 3] = "CROP";
const JimpClassSchema = z.object({ bitmap: z.object({ data: z.union([z.instanceof(Buffer), z.instanceof(Uint8Array)]), width: z.number(), height: z.number() }) }), BlitOptionsSchemaComplex = z.object({ src: JimpClassSchema, x: z.number().optional(), y: z.number().optional(), srcX: z.number().optional(), srcY: z.number().optional(), srcW: z.number().optional(), srcH: z.number().optional() }), BlitOptionsSchema = z.union([JimpClassSchema, BlitOptionsSchemaComplex]), methods$h = { blit(d, m) {
  const g = BlitOptionsSchema.parse(m);
  let { src: w, x: I = 0, y: P = 0, srcX: F = 0, srcY: D = 0, srcW: U = w.bitmap.width, srcH: Z = w.bitmap.height } = "bitmap" in g ? { src: g } : g;
  if (!("bitmap" in w)) throw new Error("The source must be a Jimp image");
  if (typeof I != "number" || typeof P != "number") throw new Error("x and y must be numbers");
  I = Math.round(I), P = Math.round(P), F = Math.round(F), D = Math.round(D), U = Math.round(U), Z = Math.round(Z);
  const $ = d.bitmap.width, j = d.bitmap.height;
  return scan(w, F, D, U, Z, function(G, Q, H) {
    const W = I + G - F, q = P + Q - D;
    if (W >= 0 && q >= 0 && $ - W > 0 && j - q > 0) {
      const et = d.getPixelIndex(W, q), rt = { r: w.bitmap.data[H] || 0, g: w.bitmap.data[H + 1] || 0, b: w.bitmap.data[H + 2] || 0, a: w.bitmap.data[H + 3] || 0 }, tt = { r: d.bitmap.data[et] || 0, g: d.bitmap.data[et + 1] || 0, b: d.bitmap.data[et + 2] || 0, a: d.bitmap.data[et + 3] || 0 };
      d.bitmap.data[et] = (rt.a * (rt.r - tt.r) - tt.r + 255 >> 8) + tt.r, d.bitmap.data[et + 1] = (rt.a * (rt.g - tt.g) - tt.g + 255 >> 8) + tt.g, d.bitmap.data[et + 2] = (rt.a * (rt.b - tt.b) - tt.b + 255 >> 8) + tt.b, d.bitmap.data[et + 3] = limit255(tt.a + rt.a);
    }
  }), d;
} }, mulTable = [1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107, 3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221, 209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103, 99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119, 231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151, 147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13, 51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75, 147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229, 113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183, 181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37, 73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61, 121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178, 176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153, 19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133, 66, 131, 65, 129, 1], shgTable = [0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18, 16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20, 20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21, 20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20, 22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22, 22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18, 22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22, 21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24, 24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24, 24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22, 25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23, 25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25, 20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25, 22, 25, 25, 25, 24, 25, 24, 25, 18], methods$g = { blur(d, m) {
  if (typeof m != "number") throw new Error("r must be a number");
  if (m < 1) throw new Error("r must be greater than 0");
  let g, w, I, P, F, D, U, Z, $, j, G, Q, H;
  const W = d.bitmap.width - 1, q = d.bitmap.height - 1, et = m + 1, rt = mulTable[m], tt = shgTable[m], V = [], X = [], ot = [], it = [], st = [], at = [];
  let ct = 2;
  for (; ct-- > 0; ) {
    for (Q = 0, H = 0, D = 0; D < d.bitmap.height; D++) {
      for (g = d.bitmap.data[H] * et, w = d.bitmap.data[H + 1] * et, I = d.bitmap.data[H + 2] * et, P = d.bitmap.data[H + 3] * et, U = 1; U <= m; U++) Z = H + ((U > W ? W : U) << 2), g += d.bitmap.data[Z++], w += d.bitmap.data[Z++], I += d.bitmap.data[Z++], P += d.bitmap.data[Z];
      for (F = 0; F < d.bitmap.width; F++) V[Q] = g, X[Q] = w, ot[Q] = I, it[Q] = P, D === 0 && (st[F] = ((Z = F + et) < W ? Z : W) << 2, at[F] = (Z = F - m) > 0 ? Z << 2 : 0), $ = H + st[F], j = H + at[F], g += d.bitmap.data[$++] - d.bitmap.data[j++], w += d.bitmap.data[$++] - d.bitmap.data[j++], I += d.bitmap.data[$++] - d.bitmap.data[j++], P += d.bitmap.data[$] - d.bitmap.data[j++], Q++;
      H += d.bitmap.width << 2;
    }
    for (F = 0; F < d.bitmap.width; F++) {
      for (G = F, g = V[G] * et, w = X[G] * et, I = ot[G] * et, P = it[G] * et, U = 1; U <= m; U++) G += U > q ? 0 : d.bitmap.width, g += V[G], w += X[G], I += ot[G], P += it[G];
      for (Q = F << 2, D = 0; D < d.bitmap.height; D++) d.bitmap.data[Q] = limit255(g * rt >>> tt), d.bitmap.data[Q + 1] = limit255(w * rt >>> tt), d.bitmap.data[Q + 2] = limit255(I * rt >>> tt), d.bitmap.data[Q + 3] = limit255(P * rt >>> tt), F === 0 && (st[D] = ((Z = D + et) < q ? Z : q) * d.bitmap.width, at[D] = (Z = D - m) > 0 ? Z * d.bitmap.width : 0), $ = F + st[D], j = F + at[D], g += V[$] - V[j], w += X[$] - X[j], I += ot[$] - ot[j], P += it[$] - it[j], Q += d.bitmap.width << 2;
    }
  }
  return d;
}, gaussian(d, m) {
  if (typeof m != "number") throw new Error("r must be a number");
  if (m < 1) throw new Error("r must be greater than 0");
  const g = Math.ceil(2.57 * m), w = 2 * g + 1, I = m * m * 2, P = I * Math.PI, F = [];
  for (let D = 0; D < w; D++) {
    const U = [];
    for (let Z = 0; Z < w; Z++) {
      const $ = (Z - g) ** 2 + (D - g) ** 2;
      U[Z] = Math.exp(-$ / I) / P;
    }
    F.push(U);
  }
  for (let D = 0; D < d.bitmap.height; D++) for (let U = 0; U < d.bitmap.width; U++) {
    let Z = 0, $ = 0, j = 0, G = 0, Q = 0;
    for (let H = 0; H < w; H++) {
      for (let q = 0; q < w; q++) {
        const et = Math.min(d.bitmap.width - 1, Math.max(0, q + U - g)), rt = Math.min(d.bitmap.height - 1, Math.max(0, H + D - g)), tt = F[H][q], V = rt * d.bitmap.width + et << 2;
        Z += d.bitmap.data[V] * tt, $ += d.bitmap.data[V + 1] * tt, j += d.bitmap.data[V + 2] * tt, G += d.bitmap.data[V + 3] * tt, Q += tt;
      }
      const W = D * d.bitmap.width + U << 2;
      d.bitmap.data[W] = Math.round(Z / Q), d.bitmap.data[W + 1] = Math.round($ / Q), d.bitmap.data[W + 2] = Math.round(j / Q), d.bitmap.data[W + 3] = Math.round(G / Q);
    }
  }
  return d;
} }, CircleOptionsSchema = z.object({ x: z.number().optional(), y: z.number().optional(), radius: z.number().min(0).optional() }), methods$f = { circle(d, m = {}) {
  const g = CircleOptionsSchema.parse(m), w = g.radius || (d.bitmap.width > d.bitmap.height ? d.bitmap.height : d.bitmap.width) / 2, I = typeof g.x == "number" ? g.x : d.bitmap.width / 2, P = typeof g.y == "number" ? g.y : d.bitmap.height / 2;
  return d.scan((F, D, U) => {
    const Z = Math.sqrt(Math.pow(F - I, 2) + Math.pow(D - P, 2));
    w - Z <= 0 ? d.bitmap.data[U + 3] = 0 : w - Z < 1 && (d.bitmap.data[U + 3] = 255 * (w - Z));
  }), d;
} }, ConvolutionMatrixSchema = z.array(z.number()).min(1).array(), ConvolutionComplexOptionsSchema = z.object({ kernel: ConvolutionMatrixSchema, edgeHandling: z.nativeEnum(Edge).optional() }), ConvolutionOptionsSchema = z.union([ConvolutionMatrixSchema, ConvolutionComplexOptionsSchema]), ConvoluteComplexOptionsSchema = z.object({ kernel: ConvolutionMatrixSchema, x: z.number().optional(), y: z.number().optional(), w: z.number().optional(), h: z.number().optional() }), ConvoluteOptionsSchema = z.union([ConvolutionMatrixSchema, ConvoluteComplexOptionsSchema]), PixelateSize = z.number().min(1).max(1 / 0), PixelateComplexOptionsSchema = z.object({ size: PixelateSize, x: z.number().optional(), y: z.number().optional(), w: z.number().optional(), h: z.number().optional() }), PixelateOptionsSchema = z.union([PixelateSize, PixelateComplexOptionsSchema]);
function applyKernel(d, m, g, w) {
  const I = [0, 0, 0, 0], P = (m.length - 1) / 2;
  for (let F = 0; F < m.length; F += 1) for (let D = 0; D < m[F].length; D += 1) {
    const U = d.getPixelIndex(g + F - P, w + D - P);
    I[0] += d.bitmap.data[U] * m[F][D], I[1] += d.bitmap.data[U + 1] * m[F][D], I[2] += d.bitmap.data[U + 2] * m[F][D], I[3] += d.bitmap.data[U + 3] * m[F][D];
  }
  return I;
}
function mix(d, m, g = 50) {
  return { r: (m.r - d.r) * (g / 100) + d.r, g: (m.g - d.g) * (g / 100) + d.g, b: (m.b - d.b) * (g / 100) + d.b };
}
const HueActionSchema = z.object({ apply: z.literal("hue"), params: z.tuple([z.number().min(-360).max(360)]) }), SpinActionSchema = z.object({ apply: z.literal("spin"), params: z.tuple([z.number().min(-360).max(360)]) }), LightenActionSchema = z.object({ apply: z.literal("lighten"), params: z.tuple([z.number().min(0).max(100)]).optional() }), RGBColorSchema = z.object({ r: z.number().min(0).max(255), g: z.number().min(0).max(255), b: z.number().min(0).max(255) }), MixActionSchema = z.object({ apply: z.literal("mix"), params: z.union([z.tuple([RGBColorSchema]), z.tuple([RGBColorSchema, z.number().min(0).max(100)])]) }), TintActionSchema = z.object({ apply: z.literal("tint"), params: z.tuple([z.number().min(0).max(100)]).optional() }), ShadeActionSchema = z.object({ apply: z.literal("shade"), params: z.tuple([z.number().min(0).max(100)]).optional() }), XorActionSchema = z.object({ apply: z.literal("xor"), params: z.tuple([RGBColorSchema]) }), RedActionSchema = z.object({ apply: z.literal("red"), params: z.tuple([z.number().min(-255).max(255)]) }), GreenActionSchema = z.object({ apply: z.literal("green"), params: z.tuple([z.number().min(-255).max(255)]) }), BlueActionSchema = z.object({ apply: z.literal("blue"), params: z.tuple([z.number().min(-255).max(255)]) }), BrightenActionSchema = z.object({ apply: z.literal("brighten"), params: z.tuple([z.number().min(0).max(100)]).optional() }), DarkenActionSchema = z.object({ apply: z.literal("darken"), params: z.tuple([z.number().min(0).max(100)]).optional() }), DesaturateActionSchema = z.object({ apply: z.literal("desaturate"), params: z.tuple([z.number().min(0).max(100)]).optional() }), SaturateActionSchema = z.object({ apply: z.literal("saturate"), params: z.tuple([z.number().min(0).max(100)]).optional() }), GrayscaleActionSchema = z.object({ apply: z.literal("greyscale"), params: z.tuple([]).optional() }), ColorActionNameSchema = z.union([HueActionSchema, SpinActionSchema, LightenActionSchema, MixActionSchema, TintActionSchema, ShadeActionSchema, XorActionSchema, RedActionSchema, GreenActionSchema, BlueActionSchema, BrightenActionSchema, DarkenActionSchema, DesaturateActionSchema, SaturateActionSchema, GrayscaleActionSchema]);
function histogram(d) {
  const m = { r: new Array(256).fill(0), g: new Array(256).fill(0), b: new Array(256).fill(0) };
  return d.scan((g, w, I) => {
    m.r[d.bitmap.data[I + 0]]++, m.g[d.bitmap.data[I + 1]]++, m.b[d.bitmap.data[I + 2]]++;
  }), m;
}
const normalizeValue = function(d, m, g) {
  return 255 * (d - m) / (g - m);
}, getBounds = function(d) {
  return [d.findIndex((m) => m > 0), 255 - d.slice().reverse().findIndex((m) => m > 0)];
}, methods$e = { normalize(d) {
  const m = histogram(d), g = { r: getBounds(m.r), g: getBounds(m.g), b: getBounds(m.b) };
  return d.scan((w, I, P) => {
    const F = d.bitmap.data[P + 0], D = d.bitmap.data[P + 1], U = d.bitmap.data[P + 2];
    d.bitmap.data[P + 0] = normalizeValue(F, g.r[0], g.r[1]), d.bitmap.data[P + 1] = normalizeValue(D, g.g[0], g.g[1]), d.bitmap.data[P + 2] = normalizeValue(U, g.b[0], g.b[1]);
  }), d;
}, invert: (d) => (d.scan((m, g, w) => {
  d.bitmap.data[w] = 255 - d.bitmap.data[w], d.bitmap.data[w + 1] = 255 - d.bitmap.data[w + 1], d.bitmap.data[w + 2] = 255 - d.bitmap.data[w + 2];
}), d), brightness(d, m) {
  if (typeof m != "number") throw new Error("val must be numbers");
  return d.scan((g, w, I) => {
    d.bitmap.data[I] = limit255(d.bitmap.data[I] * m), d.bitmap.data[I + 1] = limit255(d.bitmap.data[I + 1] * m), d.bitmap.data[I + 2] = limit255(d.bitmap.data[I + 2] * m);
  }), d;
}, contrast(d, m) {
  if (typeof m != "number") throw new Error("val must be numbers");
  if (m < -1 || m > 1) throw new Error("val must be a number between -1 and +1");
  const g = (m + 1) / (1 - m);
  function w(I) {
    return (I = Math.floor(g * (I - 127) + 127)) < 0 ? 0 : I > 255 ? 255 : I;
  }
  return d.scan((I, P, F) => {
    d.bitmap.data[F] = w(d.bitmap.data[F]), d.bitmap.data[F + 1] = w(d.bitmap.data[F + 1]), d.bitmap.data[F + 2] = w(d.bitmap.data[F + 2]);
  }), d;
}, posterize(d, m) {
  if (typeof m != "number") throw new Error("n must be numbers");
  return m < 2 && (m = 2), d.scan((g, w, I) => {
    const P = d.bitmap.data[I], F = d.bitmap.data[I + 1], D = d.bitmap.data[I + 2];
    d.bitmap.data[I] = Math.floor(P / 255 * (m - 1)) / (m - 1) * 255, d.bitmap.data[I + 1] = Math.floor(F / 255 * (m - 1)) / (m - 1) * 255, d.bitmap.data[I + 2] = Math.floor(D / 255 * (m - 1)) / (m - 1) * 255;
  }), d;
}, greyscale: (d) => (d.scan((m, g, w) => {
  const I = 0.2126 * d.bitmap.data[w] + 0.7152 * d.bitmap.data[w + 1] + 0.0722 * d.bitmap.data[w + 2];
  d.bitmap.data[w] = I, d.bitmap.data[w + 1] = I, d.bitmap.data[w + 2] = I;
}), d), opacity(d, m) {
  if (typeof m != "number") throw new Error("f must be a number");
  if (m < 0 || m > 1) throw new Error("f must be a number from 0 to 1");
  return d.scan((g, w, I) => {
    const P = d.bitmap.data[I + 3] * m;
    d.bitmap.data[I + 3] = P;
  }), d;
}, sepia: (d) => (d.scan((m, g, w) => {
  let I = d.bitmap.data[w], P = d.bitmap.data[w + 1], F = d.bitmap.data[w + 2];
  I = 0.393 * I + 0.769 * P + 0.189 * F, P = 0.349 * I + 0.686 * P + 0.168 * F, F = 0.272 * I + 0.534 * P + 0.131 * F, d.bitmap.data[w] = I < 255 ? I : 255, d.bitmap.data[w + 1] = P < 255 ? P : 255, d.bitmap.data[w + 2] = F < 255 ? F : 255;
}), d), fade(d, m) {
  if (typeof m != "number") throw new Error("f must be a number");
  if (m < 0 || m > 1) throw new Error("f must be a number from 0 to 1");
  return this.opacity(d, 1 - m);
}, convolution(d, m) {
  const g = ConvolutionOptionsSchema.parse(m), { kernel: w, edgeHandling: I = Edge.EXTEND } = "kernel" in g ? g : { kernel: g, edgeHandling: void 0 };
  if (!w[0]) throw new Error("kernel must be a matrix");
  const P = Buffer.from(d.bitmap.data), F = w.length, D = w[0].length, U = Math.floor(F / 2), Z = Math.floor(D / 2), $ = -U, j = -Z;
  let G, Q, H, W, q, et, rt, tt, V, X;
  return d.scan((ot, it, st) => {
    W = 0, H = 0, Q = 0;
    for (let at = $; at <= U; at++) for (let ct = j; ct <= Z; ct++) tt = ot + ct, V = it + at, G = w[at + U][ct + Z], X = d.getPixelIndex(tt, V, I), X === -1 ? (rt = 0, et = 0, q = 0) : (q = d.bitmap.data[X + 0], et = d.bitmap.data[X + 1], rt = d.bitmap.data[X + 2]), Q += G * q, H += G * et, W += G * rt;
    Q < 0 && (Q = 0), H < 0 && (H = 0), W < 0 && (W = 0), Q > 255 && (Q = 255), H > 255 && (H = 255), W > 255 && (W = 255), P[st + 0] = Q, P[st + 1] = H, P[st + 2] = W;
  }), d.bitmap.data = P, d;
}, opaque: (d) => (d.scan((m, g, w) => {
  d.bitmap.data[w + 3] = 255;
}), d), pixelate(d, m) {
  const g = PixelateOptionsSchema.parse(m), { size: w, x: I = 0, y: P = 0, w: F = d.bitmap.width - I, h: D = d.bitmap.height - P } = typeof g == "number" ? { size: g } : g, U = [[1 / 16, 2 / 16, 1 / 16], [2 / 16, 0.25, 2 / 16], [1 / 16, 2 / 16, 1 / 16]], Z = clone(d);
  return scan(Z, I, P, F, D, ($, j, G) => {
    $ = w * Math.floor($ / w), j = w * Math.floor(j / w);
    const Q = applyKernel(Z, U, $, j);
    d.bitmap.data[G] = Q[0], d.bitmap.data[G + 1] = Q[1], d.bitmap.data[G + 2] = Q[2], d.bitmap.data[G + 3] = Q[3];
  }), d;
}, convolute(d, m) {
  const g = ConvoluteOptionsSchema.parse(m), { kernel: w, x: I = 0, y: P = 0, w: F = d.bitmap.width - I, h: D = d.bitmap.height - P } = "kernel" in g ? g : { kernel: g }, U = clone(d);
  return scan(U, I, P, F, D, (Z, $, j) => {
    const G = applyKernel(U, w, Z, $);
    d.bitmap.data[j] = limit255(G[0]), d.bitmap.data[j + 1] = limit255(G[1]), d.bitmap.data[j + 2] = limit255(G[2]), d.bitmap.data[j + 3] = limit255(G[3]);
  }), d;
}, color(d, m) {
  if (!m || !Array.isArray(m)) throw new Error("actions must be an array");
  return m.forEach((g) => ColorActionNameSchema.parse(g)), m = m.map((g) => (g.apply !== "xor" && g.apply !== "mix" || (g.params[0] = tinycolor(g.params[0]).toRgb()), g)), d.scan((g, w, I) => {
    let P = { r: d.bitmap.data[I], g: d.bitmap.data[I + 1], b: d.bitmap.data[I + 2] };
    const F = (D, U) => limit255(P[D] + U);
    m.forEach((D) => {
      var U, Z;
      if (D.apply === "mix") P = mix(P, D.params[0], D.params[1]);
      else if (D.apply === "tint") P = mix(P, { r: 255, g: 255, b: 255 }, (U = D.params) == null ? void 0 : U[0]);
      else if (D.apply === "shade") P = mix(P, { r: 0, g: 0, b: 0 }, (Z = D.params) == null ? void 0 : Z[0]);
      else if (D.apply === "xor") P = { r: P.r ^ D.params[0].r, g: P.g ^ D.params[0].g, b: P.b ^ D.params[0].b };
      else if (D.apply === "red") P.r = F("r", D.params[0]);
      else if (D.apply === "green") P.g = F("g", D.params[0]);
      else if (D.apply === "blue") P.b = F("b", D.params[0]);
      else {
        D.apply === "hue" && (D.apply = "spin");
        const $ = tinycolor(P), j = $[D.apply].bind($);
        if (!j) throw new Error("action " + D.apply + " not supported");
        P = j(...D.params || []).toRgb();
      }
    }), d.bitmap.data[I] = P.r, d.bitmap.data[I + 1] = P.g, d.bitmap.data[I + 2] = P.b;
  }), d;
} };
var lib$1 = {}, ieee754 = {
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  read: function(d, m, g, w, I) {
    var P, F, D = 8 * I - w - 1, U = (1 << D) - 1, Z = U >> 1, $ = -7, j = g ? I - 1 : 0, G = g ? -1 : 1, Q = d[m + j];
    for (j += G, P = Q & (1 << -$) - 1, Q >>= -$, $ += D; $ > 0; P = 256 * P + d[m + j], j += G, $ -= 8) ;
    for (F = P & (1 << -$) - 1, P >>= -$, $ += w; $ > 0; F = 256 * F + d[m + j], j += G, $ -= 8) ;
    if (P === 0) P = 1 - Z;
    else {
      if (P === U) return F ? NaN : 1 / 0 * (Q ? -1 : 1);
      F += Math.pow(2, w), P -= Z;
    }
    return (Q ? -1 : 1) * F * Math.pow(2, P - w);
  },
  write: function(d, m, g, w, I, P) {
    var F, D, U, Z = 8 * P - I - 1, $ = (1 << Z) - 1, j = $ >> 1, G = I === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Q = w ? 0 : P - 1, H = w ? 1 : -1, W = m < 0 || m === 0 && 1 / m < 0 ? 1 : 0;
    for (m = Math.abs(m), isNaN(m) || m === 1 / 0 ? (D = isNaN(m) ? 1 : 0, F = $) : (F = Math.floor(Math.log(m) / Math.LN2), m * (U = Math.pow(2, -F)) < 1 && (F--, U *= 2), (m += F + j >= 1 ? G / U : G * Math.pow(2, 1 - j)) * U >= 2 && (F++, U /= 2), F + j >= $ ? (D = 0, F = $) : F + j >= 1 ? (D = (m * U - 1) * Math.pow(2, I), F += j) : (D = m * Math.pow(2, j - 1) * Math.pow(2, I), F = 0)); I >= 8; d[g + Q] = 255 & D, Q += H, D /= 256, I -= 8) ;
    for (F = F << I | D, Z += I; Z > 0; d[g + Q] = 255 & F, Q += H, F /= 256, Z -= 8) ;
    d[g + Q - H] |= 128 * W;
  }
};
(function(d) {
  Object.defineProperty(d, "__esModule", { value: !0 }), d.AnsiStringType = d.StringType = d.BufferType = d.Uint8ArrayType = d.IgnoreType = d.Float80_LE = d.Float80_BE = d.Float64_LE = d.Float64_BE = d.Float32_LE = d.Float32_BE = d.Float16_LE = d.Float16_BE = d.INT64_BE = d.UINT64_BE = d.INT64_LE = d.UINT64_LE = d.INT32_LE = d.INT32_BE = d.INT24_BE = d.INT24_LE = d.INT16_LE = d.INT16_BE = d.INT8 = d.UINT32_BE = d.UINT32_LE = d.UINT24_BE = d.UINT24_LE = d.UINT16_BE = d.UINT16_LE = d.UINT8 = void 0;
  const m = ieee754;
  function g(I) {
    return new DataView(I.buffer, I.byteOffset);
  }
  d.UINT8 = { len: 1, get: (I, P) => g(I).getUint8(P), put: (I, P, F) => (g(I).setUint8(P, F), P + 1) }, d.UINT16_LE = { len: 2, get: (I, P) => g(I).getUint16(P, !0), put: (I, P, F) => (g(I).setUint16(P, F, !0), P + 2) }, d.UINT16_BE = { len: 2, get: (I, P) => g(I).getUint16(P), put: (I, P, F) => (g(I).setUint16(P, F), P + 2) }, d.UINT24_LE = { len: 3, get(I, P) {
    const F = g(I);
    return F.getUint8(P) + (F.getUint16(P + 1, !0) << 8);
  }, put(I, P, F) {
    const D = g(I);
    return D.setUint8(P, 255 & F), D.setUint16(P + 1, F >> 8, !0), P + 3;
  } }, d.UINT24_BE = { len: 3, get(I, P) {
    const F = g(I);
    return (F.getUint16(P) << 8) + F.getUint8(P + 2);
  }, put(I, P, F) {
    const D = g(I);
    return D.setUint16(P, F >> 8), D.setUint8(P + 2, 255 & F), P + 3;
  } }, d.UINT32_LE = { len: 4, get: (I, P) => g(I).getUint32(P, !0), put: (I, P, F) => (g(I).setUint32(P, F, !0), P + 4) }, d.UINT32_BE = { len: 4, get: (I, P) => g(I).getUint32(P), put: (I, P, F) => (g(I).setUint32(P, F), P + 4) }, d.INT8 = { len: 1, get: (I, P) => g(I).getInt8(P), put: (I, P, F) => (g(I).setInt8(P, F), P + 1) }, d.INT16_BE = { len: 2, get: (I, P) => g(I).getInt16(P), put: (I, P, F) => (g(I).setInt16(P, F), P + 2) }, d.INT16_LE = { len: 2, get: (I, P) => g(I).getInt16(P, !0), put: (I, P, F) => (g(I).setInt16(P, F, !0), P + 2) }, d.INT24_LE = { len: 3, get(I, P) {
    const F = d.UINT24_LE.get(I, P);
    return F > 8388607 ? F - 16777216 : F;
  }, put(I, P, F) {
    const D = g(I);
    return D.setUint8(P, 255 & F), D.setUint16(P + 1, F >> 8, !0), P + 3;
  } }, d.INT24_BE = { len: 3, get(I, P) {
    const F = d.UINT24_BE.get(I, P);
    return F > 8388607 ? F - 16777216 : F;
  }, put(I, P, F) {
    const D = g(I);
    return D.setUint16(P, F >> 8), D.setUint8(P + 2, 255 & F), P + 3;
  } }, d.INT32_BE = { len: 4, get: (I, P) => g(I).getInt32(P), put: (I, P, F) => (g(I).setInt32(P, F), P + 4) }, d.INT32_LE = { len: 4, get: (I, P) => g(I).getInt32(P, !0), put: (I, P, F) => (g(I).setInt32(P, F, !0), P + 4) }, d.UINT64_LE = { len: 8, get: (I, P) => g(I).getBigUint64(P, !0), put: (I, P, F) => (g(I).setBigUint64(P, F, !0), P + 8) }, d.INT64_LE = { len: 8, get: (I, P) => g(I).getBigInt64(P, !0), put: (I, P, F) => (g(I).setBigInt64(P, F, !0), P + 8) }, d.UINT64_BE = { len: 8, get: (I, P) => g(I).getBigUint64(P), put: (I, P, F) => (g(I).setBigUint64(P, F), P + 8) }, d.INT64_BE = { len: 8, get: (I, P) => g(I).getBigInt64(P), put: (I, P, F) => (g(I).setBigInt64(P, F), P + 8) }, d.Float16_BE = { len: 2, get(I, P) {
    return m.read(I, P, !1, 10, this.len);
  }, put(I, P, F) {
    return m.write(I, F, P, !1, 10, this.len), P + this.len;
  } }, d.Float16_LE = { len: 2, get(I, P) {
    return m.read(I, P, !0, 10, this.len);
  }, put(I, P, F) {
    return m.write(I, F, P, !0, 10, this.len), P + this.len;
  } }, d.Float32_BE = { len: 4, get: (I, P) => g(I).getFloat32(P), put: (I, P, F) => (g(I).setFloat32(P, F), P + 4) }, d.Float32_LE = { len: 4, get: (I, P) => g(I).getFloat32(P, !0), put: (I, P, F) => (g(I).setFloat32(P, F, !0), P + 4) }, d.Float64_BE = { len: 8, get: (I, P) => g(I).getFloat64(P), put: (I, P, F) => (g(I).setFloat64(P, F), P + 8) }, d.Float64_LE = { len: 8, get: (I, P) => g(I).getFloat64(P, !0), put: (I, P, F) => (g(I).setFloat64(P, F, !0), P + 8) }, d.Float80_BE = { len: 10, get(I, P) {
    return m.read(I, P, !1, 63, this.len);
  }, put(I, P, F) {
    return m.write(I, F, P, !1, 63, this.len), P + this.len;
  } }, d.Float80_LE = { len: 10, get(I, P) {
    return m.read(I, P, !0, 63, this.len);
  }, put(I, P, F) {
    return m.write(I, F, P, !0, 63, this.len), P + this.len;
  } }, d.IgnoreType = class {
    constructor(I) {
      this.len = I;
    }
    get(I, P) {
    }
  }, d.Uint8ArrayType = class {
    constructor(I) {
      this.len = I;
    }
    get(I, P) {
      return I.subarray(P, P + this.len);
    }
  }, d.BufferType = class {
    constructor(I) {
      this.len = I;
    }
    get(I, P) {
      return Buffer.from(I.subarray(P, P + this.len));
    }
  }, d.StringType = class {
    constructor(I, P) {
      this.len = I, this.encoding = P;
    }
    get(I, P) {
      return Buffer.from(I).toString(this.encoding, P, P + this.len);
    }
  };
  class w {
    constructor(P) {
      this.len = P;
    }
    static decode(P, F, D) {
      let U = "";
      for (let Z = F; Z < D; ++Z) U += w.codePointToString(w.singleByteDecoder(P[Z]));
      return U;
    }
    static inRange(P, F, D) {
      return F <= P && P <= D;
    }
    static codePointToString(P) {
      return P <= 65535 ? String.fromCharCode(P) : (P -= 65536, String.fromCharCode(55296 + (P >> 10), 56320 + (1023 & P)));
    }
    static singleByteDecoder(P) {
      if (w.inRange(P, 0, 127)) return P;
      const F = w.windows1252[P - 128];
      if (F === null) throw Error("invaliding encoding");
      return F;
    }
    get(P, F = 0) {
      return w.decode(P, F, F + this.len);
    }
  }
  d.AnsiStringType = w, w.windows1252 = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255];
})(lib$1);
var core$1 = {}, ReadStreamTokenizer$1 = {}, AbstractTokenizer$1 = {}, lib = {}, EndOfFileStream = {};
(function(d) {
  Object.defineProperty(d, "__esModule", { value: !0 }), d.EndOfStreamError = d.defaultMessages = void 0, d.defaultMessages = "End-Of-Stream";
  class m extends Error {
    constructor() {
      super(d.defaultMessages);
    }
  }
  d.EndOfStreamError = m;
})(EndOfFileStream);
var StreamReader = {}, Deferred$1 = {};
Object.defineProperty(Deferred$1, "__esModule", { value: !0 }), Deferred$1.Deferred = void 0;
class Deferred {
  constructor() {
    this.resolve = () => null, this.reject = () => null, this.promise = new Promise((m, g) => {
      this.reject = g, this.resolve = m;
    });
  }
}
Deferred$1.Deferred = Deferred, function(d) {
  Object.defineProperty(d, "__esModule", { value: !0 }), d.StreamReader = d.EndOfStreamError = void 0;
  const m = EndOfFileStream, g = Deferred$1;
  var w = EndOfFileStream;
  Object.defineProperty(d, "EndOfStreamError", { enumerable: !0, get: function() {
    return w.EndOfStreamError;
  } }), d.StreamReader = class {
    constructor(I) {
      if (this.s = I, this.deferred = null, this.endOfStream = !1, this.peekQueue = [], !I.read || !I.once) throw new Error("Expected an instance of stream.Readable");
      this.s.once("end", () => this.reject(new m.EndOfStreamError())), this.s.once("error", (P) => this.reject(P)), this.s.once("close", () => this.reject(new Error("Stream closed")));
    }
    async peek(I, P, F) {
      const D = await this.read(I, P, F);
      return this.peekQueue.push(I.subarray(P, P + D)), D;
    }
    async read(I, P, F) {
      if (F === 0) return 0;
      if (this.peekQueue.length === 0 && this.endOfStream) throw new m.EndOfStreamError();
      let D = F, U = 0;
      for (; this.peekQueue.length > 0 && D > 0; ) {
        const Z = this.peekQueue.pop();
        if (!Z) throw new Error("peekData should be defined");
        const $ = Math.min(Z.length, D);
        I.set(Z.subarray(0, $), P + U), U += $, D -= $, $ < Z.length && this.peekQueue.push(Z.subarray($));
      }
      for (; D > 0 && !this.endOfStream; ) {
        const Z = Math.min(D, 1048576), $ = await this.readFromStream(I, P + U, Z);
        if (U += $, $ < Z) break;
        D -= $;
      }
      return U;
    }
    async readFromStream(I, P, F) {
      const D = this.s.read(F);
      if (D) return I.set(D, P), D.length;
      {
        const U = { buffer: I, offset: P, length: F, deferred: new g.Deferred() };
        return this.deferred = U.deferred, this.s.once("readable", () => {
          this.readDeferred(U);
        }), U.deferred.promise;
      }
    }
    readDeferred(I) {
      const P = this.s.read(I.length);
      P ? (I.buffer.set(P, I.offset), I.deferred.resolve(P.length), this.deferred = null) : this.s.once("readable", () => {
        this.readDeferred(I);
      });
    }
    reject(I) {
      this.endOfStream = !0, this.deferred && (this.deferred.reject(I), this.deferred = null);
    }
  };
}(StreamReader), function(d) {
  Object.defineProperty(d, "__esModule", { value: !0 }), d.StreamReader = d.EndOfStreamError = void 0;
  var m = EndOfFileStream;
  Object.defineProperty(d, "EndOfStreamError", { enumerable: !0, get: function() {
    return m.EndOfStreamError;
  } });
  var g = StreamReader;
  Object.defineProperty(d, "StreamReader", { enumerable: !0, get: function() {
    return g.StreamReader;
  } });
}(lib), Object.defineProperty(AbstractTokenizer$1, "__esModule", { value: !0 }), AbstractTokenizer$1.AbstractTokenizer = void 0;
const peek_readable_1$2 = lib;
class AbstractTokenizer {
  constructor(m) {
    this.position = 0, this.numBuffer = new Uint8Array(8), this.fileInfo = m || {};
  }
  async readToken(m, g = this.position) {
    const w = Buffer.alloc(m.len);
    if (await this.readBuffer(w, { position: g }) < m.len) throw new peek_readable_1$2.EndOfStreamError();
    return m.get(w, 0);
  }
  async peekToken(m, g = this.position) {
    const w = Buffer.alloc(m.len);
    if (await this.peekBuffer(w, { position: g }) < m.len) throw new peek_readable_1$2.EndOfStreamError();
    return m.get(w, 0);
  }
  async readNumber(m) {
    if (await this.readBuffer(this.numBuffer, { length: m.len }) < m.len) throw new peek_readable_1$2.EndOfStreamError();
    return m.get(this.numBuffer, 0);
  }
  async peekNumber(m) {
    if (await this.peekBuffer(this.numBuffer, { length: m.len }) < m.len) throw new peek_readable_1$2.EndOfStreamError();
    return m.get(this.numBuffer, 0);
  }
  async ignore(m) {
    if (this.fileInfo.size !== void 0) {
      const g = this.fileInfo.size - this.position;
      if (m > g) return this.position += g, g;
    }
    return this.position += m, m;
  }
  async close() {
  }
  normalizeOptions(m, g) {
    if (g && g.position !== void 0 && g.position < this.position) throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    return g ? { mayBeLess: g.mayBeLess === !0, offset: g.offset ? g.offset : 0, length: g.length ? g.length : m.length - (g.offset ? g.offset : 0), position: g.position ? g.position : this.position } : { mayBeLess: !1, offset: 0, length: m.length, position: this.position };
  }
}
AbstractTokenizer$1.AbstractTokenizer = AbstractTokenizer, Object.defineProperty(ReadStreamTokenizer$1, "__esModule", { value: !0 }), ReadStreamTokenizer$1.ReadStreamTokenizer = void 0;
const AbstractTokenizer_1$1 = AbstractTokenizer$1, peek_readable_1$1 = lib, maxBufferSize = 256e3;
class ReadStreamTokenizer extends AbstractTokenizer_1$1.AbstractTokenizer {
  constructor(m, g) {
    super(g), this.streamReader = new peek_readable_1$1.StreamReader(m);
  }
  async getFileInfo() {
    return this.fileInfo;
  }
  async readBuffer(m, g) {
    const w = this.normalizeOptions(m, g), I = w.position - this.position;
    if (I > 0) return await this.ignore(I), this.readBuffer(m, g);
    if (I < 0) throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    if (w.length === 0) return 0;
    const P = await this.streamReader.read(m, w.offset, w.length);
    if (this.position += P, (!g || !g.mayBeLess) && P < w.length) throw new peek_readable_1$1.EndOfStreamError();
    return P;
  }
  async peekBuffer(m, g) {
    const w = this.normalizeOptions(m, g);
    let I = 0;
    if (w.position) {
      const P = w.position - this.position;
      if (P > 0) {
        const F = new Uint8Array(w.length + P);
        return I = await this.peekBuffer(F, { mayBeLess: w.mayBeLess }), m.set(F.subarray(P), w.offset), I - P;
      }
      if (P < 0) throw new Error("Cannot peek from a negative offset in a stream");
    }
    if (w.length > 0) {
      try {
        I = await this.streamReader.peek(m, w.offset, w.length);
      } catch (P) {
        if (g && g.mayBeLess && P instanceof peek_readable_1$1.EndOfStreamError) return 0;
        throw P;
      }
      if (!w.mayBeLess && I < w.length) throw new peek_readable_1$1.EndOfStreamError();
    }
    return I;
  }
  async ignore(m) {
    const g = Math.min(maxBufferSize, m), w = new Uint8Array(g);
    let I = 0;
    for (; I < m; ) {
      const P = m - I, F = await this.readBuffer(w, { length: Math.min(g, P) });
      if (F < 0) return F;
      I += F;
    }
    return I;
  }
}
ReadStreamTokenizer$1.ReadStreamTokenizer = ReadStreamTokenizer;
var BufferTokenizer$1 = {};
Object.defineProperty(BufferTokenizer$1, "__esModule", { value: !0 }), BufferTokenizer$1.BufferTokenizer = void 0;
const peek_readable_1 = lib, AbstractTokenizer_1 = AbstractTokenizer$1;
class BufferTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
  constructor(m, g) {
    super(g), this.uint8Array = m, this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : m.length;
  }
  async readBuffer(m, g) {
    if (g && g.position) {
      if (g.position < this.position) throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      this.position = g.position;
    }
    const w = await this.peekBuffer(m, g);
    return this.position += w, w;
  }
  async peekBuffer(m, g) {
    const w = this.normalizeOptions(m, g), I = Math.min(this.uint8Array.length - w.position, w.length);
    if (!w.mayBeLess && I < w.length) throw new peek_readable_1.EndOfStreamError();
    return m.set(this.uint8Array.subarray(w.position, w.position + I), w.offset), I;
  }
  async close() {
  }
}
BufferTokenizer$1.BufferTokenizer = BufferTokenizer, function(d) {
  Object.defineProperty(d, "__esModule", { value: !0 }), d.fromBuffer = d.fromStream = d.EndOfStreamError = void 0;
  const m = ReadStreamTokenizer$1, g = BufferTokenizer$1;
  var w = lib;
  Object.defineProperty(d, "EndOfStreamError", { enumerable: !0, get: function() {
    return w.EndOfStreamError;
  } }), d.fromStream = function(I, P) {
    return P = P || {}, new m.ReadStreamTokenizer(I, P);
  }, d.fromBuffer = function(I, P) {
    return new g.BufferTokenizer(I, P);
  };
}(core$1);
var util = { stringToBytes: (d) => [...d].map((m) => m.charCodeAt(0)), tarHeaderChecksumMatches: (d, m = 0) => {
  const g = parseInt(d.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8);
  if (isNaN(g)) return !1;
  let w = 256;
  for (let I = m; I < m + 148; I++) w += d[I];
  for (let I = m + 156; I < m + 512; I++) w += d[I];
  return g === w;
}, uint32SyncSafeToken: { get: (d, m) => 127 & d[m + 3] | d[m + 2] << 7 | d[m + 1] << 14 | d[m] << 21, len: 4 } }, supported$1 = { extensions: ["jpg", "png", "apng", "gif", "webp", "flif", "xcf", "cr2", "cr3", "orf", "arw", "dng", "nef", "rw2", "raf", "tif", "bmp", "icns", "jxr", "psd", "indd", "zip", "tar", "rar", "gz", "bz2", "7z", "dmg", "mp4", "mid", "mkv", "webm", "mov", "avi", "mpg", "mp2", "mp3", "m4a", "oga", "ogg", "ogv", "opus", "flac", "wav", "spx", "amr", "pdf", "epub", "exe", "swf", "rtf", "wasm", "woff", "woff2", "eot", "ttf", "otf", "ico", "flv", "ps", "xz", "sqlite", "nes", "crx", "xpi", "cab", "deb", "ar", "rpm", "Z", "lz", "cfb", "mxf", "mts", "blend", "bpg", "docx", "pptx", "xlsx", "3gp", "3g2", "jp2", "jpm", "jpx", "mj2", "aif", "qcp", "odt", "ods", "odp", "xml", "mobi", "heic", "cur", "ktx", "ape", "wv", "dcm", "ics", "glb", "pcap", "dsf", "lnk", "alias", "voc", "ac3", "m4v", "m4p", "m4b", "f4v", "f4p", "f4b", "f4a", "mie", "asf", "ogm", "ogx", "mpc", "arrow", "shp", "aac", "mp1", "it", "s3m", "xm", "ai", "skp", "avif", "eps", "lzh", "pgp", "asar", "stl", "chm", "3mf", "zst", "jxl", "vcf"], mimeTypes: ["image/jpeg", "image/png", "image/gif", "image/webp", "image/flif", "image/x-xcf", "image/x-canon-cr2", "image/x-canon-cr3", "image/tiff", "image/bmp", "image/vnd.ms-photo", "image/vnd.adobe.photoshop", "application/x-indesign", "application/epub+zip", "application/x-xpinstall", "application/vnd.oasis.opendocument.text", "application/vnd.oasis.opendocument.spreadsheet", "application/vnd.oasis.opendocument.presentation", "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "application/vnd.openxmlformats-officedocument.presentationml.presentation", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "application/zip", "application/x-tar", "application/x-rar-compressed", "application/gzip", "application/x-bzip2", "application/x-7z-compressed", "application/x-apple-diskimage", "application/x-apache-arrow", "video/mp4", "audio/midi", "video/x-matroska", "video/webm", "video/quicktime", "video/vnd.avi", "audio/vnd.wave", "audio/qcelp", "audio/x-ms-asf", "video/x-ms-asf", "application/vnd.ms-asf", "video/mpeg", "video/3gpp", "audio/mpeg", "audio/mp4", "audio/opus", "video/ogg", "audio/ogg", "application/ogg", "audio/x-flac", "audio/ape", "audio/wavpack", "audio/amr", "application/pdf", "application/x-msdownload", "application/x-shockwave-flash", "application/rtf", "application/wasm", "font/woff", "font/woff2", "application/vnd.ms-fontobject", "font/ttf", "font/otf", "image/x-icon", "video/x-flv", "application/postscript", "application/eps", "application/x-xz", "application/x-sqlite3", "application/x-nintendo-nes-rom", "application/x-google-chrome-extension", "application/vnd.ms-cab-compressed", "application/x-deb", "application/x-unix-archive", "application/x-rpm", "application/x-compress", "application/x-lzip", "application/x-cfb", "application/x-mie", "application/mxf", "video/mp2t", "application/x-blender", "image/bpg", "image/jp2", "image/jpx", "image/jpm", "image/mj2", "audio/aiff", "application/xml", "application/x-mobipocket-ebook", "image/heif", "image/heif-sequence", "image/heic", "image/heic-sequence", "image/icns", "image/ktx", "application/dicom", "audio/x-musepack", "text/calendar", "text/vcard", "model/gltf-binary", "application/vnd.tcpdump.pcap", "audio/x-dsf", "application/x.ms.shortcut", "application/x.apple.alias", "audio/x-voc", "audio/vnd.dolby.dd-raw", "audio/x-m4a", "image/apng", "image/x-olympus-orf", "image/x-sony-arw", "image/x-adobe-dng", "image/x-nikon-nef", "image/x-panasonic-rw2", "image/x-fujifilm-raf", "video/x-m4v", "video/3gpp2", "application/x-esri-shape", "audio/aac", "audio/x-it", "audio/x-s3m", "audio/x-xm", "video/MP1S", "video/MP2P", "application/vnd.sketchup.skp", "image/avif", "application/x-lzh-compressed", "application/pgp-encrypted", "application/x-asar", "model/stl", "application/vnd.ms-htmlhelp", "model/3mf", "image/jxl", "application/zstd"] };
const Token = lib$1, strtok3 = core$1, { stringToBytes, tarHeaderChecksumMatches, uint32SyncSafeToken } = util, supported = supported$1, minimumBytes = 4100;
async function fromStream(d) {
  const m = await strtok3.fromStream(d);
  try {
    return await fromTokenizer(m);
  } finally {
    await m.close();
  }
}
async function fromBuffer(d) {
  if (!(d instanceof Uint8Array || d instanceof ArrayBuffer || Buffer.isBuffer(d))) throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof d}\``);
  const m = d instanceof Buffer ? d : Buffer.from(d);
  if (m && m.length > 1)
    return fromTokenizer(strtok3.fromBuffer(m));
}
function _check(d, m, g) {
  g = { offset: 0, ...g };
  for (const [w, I] of m.entries()) if (g.mask) {
    if (I !== (g.mask[w] & d[w + g.offset])) return !1;
  } else if (I !== d[w + g.offset]) return !1;
  return !0;
}
async function fromTokenizer(d) {
  try {
    return _fromTokenizer(d);
  } catch (m) {
    if (!(m instanceof strtok3.EndOfStreamError)) throw m;
  }
}
async function _fromTokenizer(d) {
  let m = Buffer.alloc(minimumBytes);
  const g = (I, P) => _check(m, I, P), w = (I, P) => g(stringToBytes(I), P);
  if (d.fileInfo.size || (d.fileInfo.size = Number.MAX_SAFE_INTEGER), await d.peekBuffer(m, { length: 12, mayBeLess: !0 }), g([66, 77])) return { ext: "bmp", mime: "image/bmp" };
  if (g([11, 119])) return { ext: "ac3", mime: "audio/vnd.dolby.dd-raw" };
  if (g([120, 1])) return { ext: "dmg", mime: "application/x-apple-diskimage" };
  if (g([77, 90])) return { ext: "exe", mime: "application/x-msdownload" };
  if (g([37, 33])) return await d.peekBuffer(m, { length: 24, mayBeLess: !0 }), w("PS-Adobe-", { offset: 2 }) && w(" EPSF-", { offset: 14 }) ? { ext: "eps", mime: "application/eps" } : { ext: "ps", mime: "application/postscript" };
  if (g([31, 160]) || g([31, 157])) return { ext: "Z", mime: "application/x-compress" };
  if (g([255, 216, 255])) return { ext: "jpg", mime: "image/jpeg" };
  if (g([73, 73, 188])) return { ext: "jxr", mime: "image/vnd.ms-photo" };
  if (g([31, 139, 8])) return { ext: "gz", mime: "application/gzip" };
  if (g([66, 90, 104])) return { ext: "bz2", mime: "application/x-bzip2" };
  if (w("ID3")) {
    await d.ignore(6);
    const I = await d.readToken(uint32SyncSafeToken);
    return d.position + I > d.fileInfo.size ? { ext: "mp3", mime: "audio/mpeg" } : (await d.ignore(I), fromTokenizer(d));
  }
  if (w("MP+")) return { ext: "mpc", mime: "audio/x-musepack" };
  if ((m[0] === 67 || m[0] === 70) && g([87, 83], { offset: 1 })) return { ext: "swf", mime: "application/x-shockwave-flash" };
  if (g([71, 73, 70])) return { ext: "gif", mime: "image/gif" };
  if (w("FLIF")) return { ext: "flif", mime: "image/flif" };
  if (w("8BPS")) return { ext: "psd", mime: "image/vnd.adobe.photoshop" };
  if (w("WEBP", { offset: 8 })) return { ext: "webp", mime: "image/webp" };
  if (w("MPCK")) return { ext: "mpc", mime: "audio/x-musepack" };
  if (w("FORM")) return { ext: "aif", mime: "audio/aiff" };
  if (w("icns", { offset: 0 })) return { ext: "icns", mime: "image/icns" };
  if (g([80, 75, 3, 4])) {
    try {
      for (; d.position + 30 < d.fileInfo.size; ) {
        await d.readBuffer(m, { length: 30 });
        const I = { compressedSize: m.readUInt32LE(18), uncompressedSize: m.readUInt32LE(22), filenameLength: m.readUInt16LE(26), extraFieldLength: m.readUInt16LE(28) };
        if (I.filename = await d.readToken(new Token.StringType(I.filenameLength, "utf-8")), await d.ignore(I.extraFieldLength), I.filename === "META-INF/mozilla.rsa") return { ext: "xpi", mime: "application/x-xpinstall" };
        if (I.filename.endsWith(".rels") || I.filename.endsWith(".xml"))
          switch (I.filename.split("/")[0]) {
            case "_rels":
            default:
              break;
            case "word":
              return { ext: "docx", mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document" };
            case "ppt":
              return { ext: "pptx", mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation" };
            case "xl":
              return { ext: "xlsx", mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" };
          }
        if (I.filename.startsWith("xl/")) return { ext: "xlsx", mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" };
        if (I.filename.startsWith("3D/") && I.filename.endsWith(".model")) return { ext: "3mf", mime: "model/3mf" };
        if (I.filename === "mimetype" && I.compressedSize === I.uncompressedSize)
          switch (await d.readToken(new Token.StringType(I.compressedSize, "utf-8"))) {
            case "application/epub+zip":
              return { ext: "epub", mime: "application/epub+zip" };
            case "application/vnd.oasis.opendocument.text":
              return { ext: "odt", mime: "application/vnd.oasis.opendocument.text" };
            case "application/vnd.oasis.opendocument.spreadsheet":
              return { ext: "ods", mime: "application/vnd.oasis.opendocument.spreadsheet" };
            case "application/vnd.oasis.opendocument.presentation":
              return { ext: "odp", mime: "application/vnd.oasis.opendocument.presentation" };
          }
        if (I.compressedSize === 0) {
          let P = -1;
          for (; P < 0 && d.position < d.fileInfo.size; ) await d.peekBuffer(m, { mayBeLess: !0 }), P = m.indexOf("504B0304", 0, "hex"), await d.ignore(P >= 0 ? P : m.length);
        } else await d.ignore(I.compressedSize);
      }
    } catch (I) {
      if (!(I instanceof strtok3.EndOfStreamError)) throw I;
    }
    return { ext: "zip", mime: "application/zip" };
  }
  if (w("OggS")) {
    await d.ignore(28);
    const I = Buffer.alloc(8);
    return await d.readBuffer(I), _check(I, [79, 112, 117, 115, 72, 101, 97, 100]) ? { ext: "opus", mime: "audio/opus" } : _check(I, [128, 116, 104, 101, 111, 114, 97]) ? { ext: "ogv", mime: "video/ogg" } : _check(I, [1, 118, 105, 100, 101, 111, 0]) ? { ext: "ogm", mime: "video/ogg" } : _check(I, [127, 70, 76, 65, 67]) ? { ext: "oga", mime: "audio/ogg" } : _check(I, [83, 112, 101, 101, 120, 32, 32]) ? { ext: "spx", mime: "audio/ogg" } : _check(I, [1, 118, 111, 114, 98, 105, 115]) ? { ext: "ogg", mime: "audio/ogg" } : { ext: "ogx", mime: "application/ogg" };
  }
  if (g([80, 75]) && (m[2] === 3 || m[2] === 5 || m[2] === 7) && (m[3] === 4 || m[3] === 6 || m[3] === 8)) return { ext: "zip", mime: "application/zip" };
  if (w("ftyp", { offset: 4 }) && 96 & m[8]) {
    const I = m.toString("binary", 8, 12).replace("\0", " ").trim();
    switch (I) {
      case "avif":
        return { ext: "avif", mime: "image/avif" };
      case "mif1":
        return { ext: "heic", mime: "image/heif" };
      case "msf1":
        return { ext: "heic", mime: "image/heif-sequence" };
      case "heic":
      case "heix":
        return { ext: "heic", mime: "image/heic" };
      case "hevc":
      case "hevx":
        return { ext: "heic", mime: "image/heic-sequence" };
      case "qt":
        return { ext: "mov", mime: "video/quicktime" };
      case "M4V":
      case "M4VH":
      case "M4VP":
        return { ext: "m4v", mime: "video/x-m4v" };
      case "M4P":
        return { ext: "m4p", mime: "video/mp4" };
      case "M4B":
        return { ext: "m4b", mime: "audio/mp4" };
      case "M4A":
        return { ext: "m4a", mime: "audio/x-m4a" };
      case "F4V":
        return { ext: "f4v", mime: "video/mp4" };
      case "F4P":
        return { ext: "f4p", mime: "video/mp4" };
      case "F4A":
        return { ext: "f4a", mime: "audio/mp4" };
      case "F4B":
        return { ext: "f4b", mime: "audio/mp4" };
      case "crx":
        return { ext: "cr3", mime: "image/x-canon-cr3" };
      default:
        return I.startsWith("3g") ? I.startsWith("3g2") ? { ext: "3g2", mime: "video/3gpp2" } : { ext: "3gp", mime: "video/3gpp" } : { ext: "mp4", mime: "video/mp4" };
    }
  }
  if (w("MThd")) return { ext: "mid", mime: "audio/midi" };
  if (w("wOFF") && (g([0, 1, 0, 0], { offset: 4 }) || w("OTTO", { offset: 4 }))) return { ext: "woff", mime: "font/woff" };
  if (w("wOF2") && (g([0, 1, 0, 0], { offset: 4 }) || w("OTTO", { offset: 4 }))) return { ext: "woff2", mime: "font/woff2" };
  if (g([212, 195, 178, 161]) || g([161, 178, 195, 212])) return { ext: "pcap", mime: "application/vnd.tcpdump.pcap" };
  if (w("DSD ")) return { ext: "dsf", mime: "audio/x-dsf" };
  if (w("LZIP")) return { ext: "lz", mime: "application/x-lzip" };
  if (w("fLaC")) return { ext: "flac", mime: "audio/x-flac" };
  if (g([66, 80, 71, 251])) return { ext: "bpg", mime: "image/bpg" };
  if (w("wvpk")) return { ext: "wv", mime: "audio/wavpack" };
  if (w("%PDF")) {
    await d.ignore(1350);
    const I = 10485760, P = Buffer.alloc(Math.min(I, d.fileInfo.size));
    return await d.readBuffer(P, { mayBeLess: !0 }), P.includes(Buffer.from("AIPrivateData")) ? { ext: "ai", mime: "application/postscript" } : { ext: "pdf", mime: "application/pdf" };
  }
  if (g([0, 97, 115, 109])) return { ext: "wasm", mime: "application/wasm" };
  if (g([73, 73, 42, 0])) return w("CR", { offset: 8 }) ? { ext: "cr2", mime: "image/x-canon-cr2" } : g([28, 0, 254, 0], { offset: 8 }) || g([31, 0, 11, 0], { offset: 8 }) ? { ext: "nef", mime: "image/x-nikon-nef" } : g([8, 0, 0, 0], { offset: 4 }) && (g([45, 0, 254, 0], { offset: 8 }) || g([39, 0, 254, 0], { offset: 8 })) ? { ext: "dng", mime: "image/x-adobe-dng" } : (m = Buffer.alloc(24), await d.peekBuffer(m), (g([16, 251, 134, 1], { offset: 4 }) || g([8, 0, 0, 0], { offset: 4 })) && g([0, 254, 0, 4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 1], { offset: 9 }) ? { ext: "arw", mime: "image/x-sony-arw" } : { ext: "tif", mime: "image/tiff" });
  if (g([77, 77, 0, 42])) return { ext: "tif", mime: "image/tiff" };
  if (w("MAC ")) return { ext: "ape", mime: "audio/ape" };
  if (g([26, 69, 223, 163])) {
    async function I() {
      const U = await d.peekNumber(Token.UINT8);
      let Z = 128, $ = 0;
      for (; !(U & Z) && Z !== 0; ) ++$, Z >>= 1;
      const j = Buffer.alloc($ + 1);
      return await d.readBuffer(j), j;
    }
    async function P() {
      const U = await I(), Z = await I();
      Z[0] ^= 128 >> Z.length - 1;
      const $ = Math.min(6, Z.length);
      return { id: U.readUIntBE(0, U.length), len: Z.readUIntBE(Z.length - $, $) };
    }
    async function F(U, Z) {
      for (; Z > 0; ) {
        const $ = await P();
        if ($.id === 17026) return d.readToken(new Token.StringType($.len, "utf-8"));
        await d.ignore($.len), --Z;
      }
    }
    const D = await P();
    switch (await F(0, D.len)) {
      case "webm":
        return { ext: "webm", mime: "video/webm" };
      case "matroska":
        return { ext: "mkv", mime: "video/x-matroska" };
      default:
        return;
    }
  }
  if (g([82, 73, 70, 70])) {
    if (g([65, 86, 73], { offset: 8 })) return { ext: "avi", mime: "video/vnd.avi" };
    if (g([87, 65, 86, 69], { offset: 8 })) return { ext: "wav", mime: "audio/vnd.wave" };
    if (g([81, 76, 67, 77], { offset: 8 })) return { ext: "qcp", mime: "audio/qcelp" };
  }
  if (w("SQLi")) return { ext: "sqlite", mime: "application/x-sqlite3" };
  if (g([78, 69, 83, 26])) return { ext: "nes", mime: "application/x-nintendo-nes-rom" };
  if (w("Cr24")) return { ext: "crx", mime: "application/x-google-chrome-extension" };
  if (w("MSCF") || w("ISc(")) return { ext: "cab", mime: "application/vnd.ms-cab-compressed" };
  if (g([237, 171, 238, 219])) return { ext: "rpm", mime: "application/x-rpm" };
  if (g([197, 208, 211, 198])) return { ext: "eps", mime: "application/eps" };
  if (g([40, 181, 47, 253])) return { ext: "zst", mime: "application/zstd" };
  if (g([79, 84, 84, 79, 0])) return { ext: "otf", mime: "font/otf" };
  if (w("#!AMR")) return { ext: "amr", mime: "audio/amr" };
  if (w("{\\rtf")) return { ext: "rtf", mime: "application/rtf" };
  if (g([70, 76, 86, 1])) return { ext: "flv", mime: "video/x-flv" };
  if (w("IMPM")) return { ext: "it", mime: "audio/x-it" };
  if (w("-lh0-", { offset: 2 }) || w("-lh1-", { offset: 2 }) || w("-lh2-", { offset: 2 }) || w("-lh3-", { offset: 2 }) || w("-lh4-", { offset: 2 }) || w("-lh5-", { offset: 2 }) || w("-lh6-", { offset: 2 }) || w("-lh7-", { offset: 2 }) || w("-lzs-", { offset: 2 }) || w("-lz4-", { offset: 2 }) || w("-lz5-", { offset: 2 }) || w("-lhd-", { offset: 2 })) return { ext: "lzh", mime: "application/x-lzh-compressed" };
  if (g([0, 0, 1, 186])) {
    if (g([33], { offset: 4, mask: [241] })) return { ext: "mpg", mime: "video/MP1S" };
    if (g([68], { offset: 4, mask: [196] })) return { ext: "mpg", mime: "video/MP2P" };
  }
  if (w("ITSF")) return { ext: "chm", mime: "application/vnd.ms-htmlhelp" };
  if (g([253, 55, 122, 88, 90, 0])) return { ext: "xz", mime: "application/x-xz" };
  if (w("<?xml ")) return { ext: "xml", mime: "application/xml" };
  if (g([55, 122, 188, 175, 39, 28])) return { ext: "7z", mime: "application/x-7z-compressed" };
  if (g([82, 97, 114, 33, 26, 7]) && (m[6] === 0 || m[6] === 1)) return { ext: "rar", mime: "application/x-rar-compressed" };
  if (w("solid ")) return { ext: "stl", mime: "model/stl" };
  if (w("BLENDER")) return { ext: "blend", mime: "application/x-blender" };
  if (w("!<arch>"))
    return await d.ignore(8), await d.readToken(new Token.StringType(13, "ascii")) === "debian-binary" ? { ext: "deb", mime: "application/x-deb" } : { ext: "ar", mime: "application/x-unix-archive" };
  if (g([137, 80, 78, 71, 13, 10, 26, 10])) {
    async function I() {
      return { length: await d.readToken(Token.INT32_BE), type: await d.readToken(new Token.StringType(4, "binary")) };
    }
    await d.ignore(8);
    do {
      const P = await I();
      if (P.length < 0) return;
      switch (P.type) {
        case "IDAT":
          return { ext: "png", mime: "image/png" };
        case "acTL":
          return { ext: "apng", mime: "image/apng" };
        default:
          await d.ignore(P.length + 4);
      }
    } while (d.position + 8 < d.fileInfo.size);
    return { ext: "png", mime: "image/png" };
  }
  if (g([65, 82, 82, 79, 87, 49, 0, 0])) return { ext: "arrow", mime: "application/x-apache-arrow" };
  if (g([103, 108, 84, 70, 2, 0, 0, 0])) return { ext: "glb", mime: "model/gltf-binary" };
  if (g([102, 114, 101, 101], { offset: 4 }) || g([109, 100, 97, 116], { offset: 4 }) || g([109, 111, 111, 118], { offset: 4 }) || g([119, 105, 100, 101], { offset: 4 })) return { ext: "mov", mime: "video/quicktime" };
  if (g([73, 73, 82, 79, 8, 0, 0, 0, 24])) return { ext: "orf", mime: "image/x-olympus-orf" };
  if (w("gimp xcf ")) return { ext: "xcf", mime: "image/x-xcf" };
  if (g([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) return { ext: "rw2", mime: "image/x-panasonic-rw2" };
  if (g([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
    async function I() {
      const P = Buffer.alloc(16);
      return await d.readBuffer(P), { id: P, size: Number(await d.readToken(Token.UINT64_LE)) };
    }
    for (await d.ignore(30); d.position + 24 < d.fileInfo.size; ) {
      const P = await I();
      let F = P.size - 24;
      if (_check(P.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
        const D = Buffer.alloc(16);
        if (F -= await d.readBuffer(D), _check(D, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) return { ext: "asf", mime: "audio/x-ms-asf" };
        if (_check(D, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) return { ext: "asf", mime: "video/x-ms-asf" };
        break;
      }
      await d.ignore(F);
    }
    return { ext: "asf", mime: "application/vnd.ms-asf" };
  }
  if (g([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) return { ext: "ktx", mime: "image/ktx" };
  if ((g([126, 16, 4]) || g([126, 24, 4])) && g([48, 77, 73, 69], { offset: 4 })) return { ext: "mie", mime: "application/x-mie" };
  if (g([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) return { ext: "shp", mime: "application/x-esri-shape" };
  if (g([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10]))
    switch (await d.ignore(20), await d.readToken(new Token.StringType(4, "ascii"))) {
      case "jp2 ":
        return { ext: "jp2", mime: "image/jp2" };
      case "jpx ":
        return { ext: "jpx", mime: "image/jpx" };
      case "jpm ":
        return { ext: "jpm", mime: "image/jpm" };
      case "mjp2":
        return { ext: "mj2", mime: "image/mj2" };
      default:
        return;
    }
  if (g([255, 10]) || g([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) return { ext: "jxl", mime: "image/jxl" };
  if (g([0, 0, 1, 186]) || g([0, 0, 1, 179])) return { ext: "mpg", mime: "video/mpeg" };
  if (g([0, 1, 0, 0, 0])) return { ext: "ttf", mime: "font/ttf" };
  if (g([0, 0, 1, 0])) return { ext: "ico", mime: "image/x-icon" };
  if (g([0, 0, 2, 0])) return { ext: "cur", mime: "image/x-icon" };
  if (g([208, 207, 17, 224, 161, 177, 26, 225])) return { ext: "cfb", mime: "application/x-cfb" };
  if (await d.peekBuffer(m, { length: Math.min(256, d.fileInfo.size), mayBeLess: !0 }), w("BEGIN:")) {
    if (w("VCARD", { offset: 6 })) return { ext: "vcf", mime: "text/vcard" };
    if (w("VCALENDAR", { offset: 6 })) return { ext: "ics", mime: "text/calendar" };
  }
  if (w("FUJIFILMCCD-RAW")) return { ext: "raf", mime: "image/x-fujifilm-raf" };
  if (w("Extended Module:")) return { ext: "xm", mime: "audio/x-xm" };
  if (w("Creative Voice File")) return { ext: "voc", mime: "audio/x-voc" };
  if (g([4, 0, 0, 0]) && m.length >= 16) {
    const I = m.readUInt32LE(12);
    if (I > 12 && m.length >= I + 16) try {
      const P = m.slice(16, I + 16).toString();
      if (JSON.parse(P).files) return { ext: "asar", mime: "application/x-asar" };
    } catch {
    }
  }
  if (g([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) return { ext: "mxf", mime: "application/mxf" };
  if (w("SCRM", { offset: 44 })) return { ext: "s3m", mime: "audio/x-s3m" };
  if (g([71], { offset: 4 }) && (g([71], { offset: 192 }) || g([71], { offset: 196 }))) return { ext: "mts", mime: "video/mp2t" };
  if (g([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) return { ext: "mobi", mime: "application/x-mobipocket-ebook" };
  if (g([68, 73, 67, 77], { offset: 128 })) return { ext: "dcm", mime: "application/dicom" };
  if (g([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) return { ext: "lnk", mime: "application/x.ms.shortcut" };
  if (g([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) return { ext: "alias", mime: "application/x.apple.alias" };
  if (g([76, 80], { offset: 34 }) && (g([0, 0, 1], { offset: 8 }) || g([1, 0, 2], { offset: 8 }) || g([2, 0, 2], { offset: 8 }))) return { ext: "eot", mime: "application/vnd.ms-fontobject" };
  if (g([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) return { ext: "indd", mime: "application/x-indesign" };
  if (await d.peekBuffer(m, { length: Math.min(512, d.fileInfo.size), mayBeLess: !0 }), tarHeaderChecksumMatches(m)) return { ext: "tar", mime: "application/x-tar" };
  if (g([255, 254, 255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0])) return { ext: "skp", mime: "application/vnd.sketchup.skp" };
  if (w("-----BEGIN PGP MESSAGE-----")) return { ext: "pgp", mime: "application/pgp-encrypted" };
  if (m.length >= 2 && g([255, 224], { offset: 0, mask: [255, 224] })) {
    if (g([16], { offset: 1, mask: [22] })) return g([8], { offset: 1, mask: [8] }), { ext: "aac", mime: "audio/aac" };
    if (g([2], { offset: 1, mask: [6] })) return { ext: "mp3", mime: "audio/mpeg" };
    if (g([4], { offset: 1, mask: [6] })) return { ext: "mp2", mime: "audio/mpeg" };
    if (g([6], { offset: 1, mask: [6] })) return { ext: "mp1", mime: "audio/mpeg" };
  }
}
const stream = (readableStream) => new Promise((resolve, reject) => {
  const stream = eval("require")("stream");
  readableStream.on("error", reject), readableStream.once("readable", async () => {
    const d = new stream.PassThrough();
    let m;
    m = stream.pipeline ? stream.pipeline(readableStream, d, () => {
    }) : readableStream.pipe(d);
    const g = readableStream.read(minimumBytes) || readableStream.read() || Buffer.alloc(0);
    try {
      const w = await fromBuffer(g);
      d.fileType = w;
    } catch (w) {
      reject(w);
    }
    resolve(m);
  });
}), fileType = { fromStream, fromTokenizer, fromBuffer, stream };
Object.defineProperty(fileType, "extensions", { get: () => new Set(supported.extensions) }), Object.defineProperty(fileType, "mimeTypes", { get: () => new Set(supported.mimeTypes) });
var core = fileType, fileType$1 = getDefaultExportFromCjs(core);
function to(d, m) {
  return d.then(function(g) {
    return [null, g];
  }).catch(function(g) {
    return [g, void 0];
  });
}
const writeFile = async () => {
  throw new Error("Not supported");
};
function Mime$1() {
  this._types = /* @__PURE__ */ Object.create(null), this._extensions = /* @__PURE__ */ Object.create(null);
  for (let d = 0; d < arguments.length; d++) this.define(arguments[d]);
  this.define = this.define.bind(this), this.getType = this.getType.bind(this), this.getExtension = this.getExtension.bind(this);
}
Mime$1.prototype.define = function(d, m) {
  for (let g in d) {
    let w = d[g].map(function(I) {
      return I.toLowerCase();
    });
    g = g.toLowerCase();
    for (let I = 0; I < w.length; I++) {
      const P = w[I];
      if (P[0] !== "*") {
        if (!m && P in this._types) throw new Error('Attempt to change mapping for "' + P + '" extension from "' + this._types[P] + '" to "' + g + '". Pass `force=true` to allow this, otherwise remove "' + P + '" from the list of extensions for "' + g + '".');
        this._types[P] = g;
      }
    }
    if (m || !this._extensions[g]) {
      const I = w[0];
      this._extensions[g] = I[0] !== "*" ? I : I.substr(1);
    }
  }
}, Mime$1.prototype.getType = function(d) {
  let m = (d = String(d)).replace(/^.*[/\\]/, "").toLowerCase(), g = m.replace(/^.*\./, "").toLowerCase(), w = m.length < d.length;
  return (g.length < m.length - 1 || !w) && this._types[g] || null;
}, Mime$1.prototype.getExtension = function(d) {
  return (d = /^\s*([^;\s]*)/.test(d) && RegExp.$1) && this._extensions[d.toLowerCase()] || null;
};
var Mime_1 = Mime$1, standard = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
let Mime = Mime_1;
var lite = new Mime(standard), mime = getDefaultExportFromCjs(lite), HorizontalAlign, HorizontalAlign2, VerticalAlign, VerticalAlign2, BlendMode, BlendMode2;
function srcOver(d, m, g = 1) {
  d.a *= g;
  const w = m.a + d.a - m.a * d.a;
  return { r: (d.r * d.a + m.r * m.a * (1 - d.a)) / w, g: (d.g * d.a + m.g * m.a * (1 - d.a)) / w, b: (d.b * d.a + m.b * m.a * (1 - d.a)) / w, a: w };
}
function dstOver(d, m, g = 1) {
  d.a *= g;
  const w = m.a + d.a - m.a * d.a;
  return { r: (m.r * m.a + d.r * d.a * (1 - m.a)) / w, g: (m.g * m.a + d.g * d.a * (1 - m.a)) / w, b: (m.b * m.a + d.b * d.a * (1 - m.a)) / w, a: w };
}
function multiply(d, m, g = 1) {
  d.a *= g;
  const w = m.a + d.a - m.a * d.a, I = d.r * d.a, P = d.g * d.a, F = d.b * d.a, D = m.r * m.a, U = m.g * m.a, Z = m.b * m.a;
  return { r: (I * D + I * (1 - m.a) + D * (1 - d.a)) / w, g: (P * U + P * (1 - m.a) + U * (1 - d.a)) / w, b: (F * Z + F * (1 - m.a) + Z * (1 - d.a)) / w, a: w };
}
function add(d, m, g = 1) {
  d.a *= g;
  const w = m.a + d.a - m.a * d.a, I = d.r * d.a, P = d.g * d.a, F = d.b * d.a;
  return { r: (I + m.r * m.a) / w, g: (P + m.g * m.a) / w, b: (F + m.b * m.a) / w, a: w };
}
function screen(d, m, g = 1) {
  d.a *= g;
  const w = m.a + d.a - m.a * d.a, I = d.r * d.a, P = d.g * d.a, F = d.b * d.a, D = m.r * m.a, U = m.g * m.a, Z = m.b * m.a;
  return { r: (I * m.a + D * d.a - I * D + I * (1 - m.a) + D * (1 - d.a)) / w, g: (P * m.a + U * d.a - P * U + P * (1 - m.a) + U * (1 - d.a)) / w, b: (F * m.a + Z * d.a - F * Z + F * (1 - m.a) + Z * (1 - d.a)) / w, a: w };
}
function overlay(d, m, g = 1) {
  d.a *= g;
  const w = m.a + d.a - m.a * d.a, I = d.r * d.a, P = d.g * d.a, F = d.b * d.a, D = m.r * m.a, U = m.g * m.a, Z = m.b * m.a;
  return { r: (2 * D <= m.a ? 2 * I * D + I * (1 - m.a) + D * (1 - d.a) : I * (1 + m.a) + D * (1 + d.a) - 2 * D * I - m.a * d.a) / w, g: (2 * U <= m.a ? 2 * P * U + P * (1 - m.a) + U * (1 - d.a) : P * (1 + m.a) + U * (1 + d.a) - 2 * U * P - m.a * d.a) / w, b: (2 * Z <= m.a ? 2 * F * Z + F * (1 - m.a) + Z * (1 - d.a) : F * (1 + m.a) + Z * (1 + d.a) - 2 * Z * F - m.a * d.a) / w, a: w };
}
function darken(d, m, g = 1) {
  d.a *= g;
  const w = m.a + d.a - m.a * d.a, I = d.r * d.a, P = d.g * d.a, F = d.b * d.a, D = m.r * m.a, U = m.g * m.a, Z = m.b * m.a;
  return { r: (Math.min(I * m.a, D * d.a) + I * (1 - m.a) + D * (1 - d.a)) / w, g: (Math.min(P * m.a, U * d.a) + P * (1 - m.a) + U * (1 - d.a)) / w, b: (Math.min(F * m.a, Z * d.a) + F * (1 - m.a) + Z * (1 - d.a)) / w, a: w };
}
function lighten(d, m, g = 1) {
  d.a *= g;
  const w = m.a + d.a - m.a * d.a, I = d.r * d.a, P = d.g * d.a, F = d.b * d.a, D = m.r * m.a, U = m.g * m.a, Z = m.b * m.a;
  return { r: (Math.max(I * m.a, D * d.a) + I * (1 - m.a) + D * (1 - d.a)) / w, g: (Math.max(P * m.a, U * d.a) + P * (1 - m.a) + U * (1 - d.a)) / w, b: (Math.max(F * m.a, Z * d.a) + F * (1 - m.a) + Z * (1 - d.a)) / w, a: w };
}
function hardLight(d, m, g = 1) {
  d.a *= g;
  const w = m.a + d.a - m.a * d.a, I = d.r * d.a, P = d.g * d.a, F = d.b * d.a, D = m.r * m.a, U = m.g * m.a, Z = m.b * m.a;
  return { r: (2 * I <= d.a ? 2 * I * D + I * (1 - m.a) + D * (1 - d.a) : I * (1 + m.a) + D * (1 + d.a) - 2 * D * I - m.a * d.a) / w, g: (2 * P <= d.a ? 2 * P * U + P * (1 - m.a) + U * (1 - d.a) : P * (1 + m.a) + U * (1 + d.a) - 2 * U * P - m.a * d.a) / w, b: (2 * F <= d.a ? 2 * F * Z + F * (1 - m.a) + Z * (1 - d.a) : F * (1 + m.a) + Z * (1 + d.a) - 2 * Z * F - m.a * d.a) / w, a: w };
}
function difference(d, m, g = 1) {
  d.a *= g;
  const w = m.a + d.a - m.a * d.a, I = d.r * d.a, P = d.g * d.a, F = d.b * d.a, D = m.r * m.a, U = m.g * m.a, Z = m.b * m.a;
  return { r: (I + D - 2 * Math.min(I * m.a, D * d.a)) / w, g: (P + U - 2 * Math.min(P * m.a, U * d.a)) / w, b: (F + Z - 2 * Math.min(F * m.a, Z * d.a)) / w, a: w };
}
function exclusion(d, m, g = 1) {
  d.a *= g;
  const w = m.a + d.a - m.a * d.a, I = d.r * d.a, P = d.g * d.a, F = d.b * d.a, D = m.r * m.a, U = m.g * m.a, Z = m.b * m.a;
  return { r: (I * m.a + D * d.a - 2 * I * D + I * (1 - m.a) + D * (1 - d.a)) / w, g: (P * m.a + U * d.a - 2 * P * U + P * (1 - m.a) + U * (1 - d.a)) / w, b: (F * m.a + Z * d.a - 2 * F * Z + F * (1 - m.a) + Z * (1 - d.a)) / w, a: w };
}
HorizontalAlign2 = HorizontalAlign || (HorizontalAlign = {}), HorizontalAlign2[HorizontalAlign2.LEFT = 1] = "LEFT", HorizontalAlign2[HorizontalAlign2.CENTER = 2] = "CENTER", HorizontalAlign2[HorizontalAlign2.RIGHT = 4] = "RIGHT", VerticalAlign2 = VerticalAlign || (VerticalAlign = {}), VerticalAlign2[VerticalAlign2.TOP = 8] = "TOP", VerticalAlign2[VerticalAlign2.MIDDLE = 16] = "MIDDLE", VerticalAlign2[VerticalAlign2.BOTTOM = 32] = "BOTTOM", BlendMode2 = BlendMode || (BlendMode = {}), BlendMode2.SRC_OVER = "srcOver", BlendMode2.DST_OVER = "dstOver", BlendMode2.MULTIPLY = "multiply", BlendMode2.ADD = "add", BlendMode2.SCREEN = "screen", BlendMode2.OVERLAY = "overlay", BlendMode2.DARKEN = "darken", BlendMode2.LIGHTEN = "lighten", BlendMode2.HARD_LIGHT = "hardLight", BlendMode2.DIFFERENCE = "difference", BlendMode2.EXCLUSION = "exclusion";
const names = [srcOver, dstOver, multiply, add, screen, overlay, darken, lighten, hardLight, difference, exclusion];
var compositeModes = Object.freeze({ __proto__: null, add, darken, difference, dstOver, exclusion, hardLight, lighten, multiply, names, overlay, screen, srcOver });
function composite(d, m, g = 0, w = 0, I = {}) {
  if (!(m instanceof d.constructor)) throw new Error("The source must be a Jimp image");
  if (typeof g != "number" || typeof w != "number") throw new Error("x and y must be numbers");
  const { mode: P = BlendMode.SRC_OVER } = I;
  let { opacitySource: F = 1, opacityDest: D = 1 } = I;
  (typeof F != "number" || F < 0 || F > 1) && (F = 1), (typeof D != "number" || D < 0 || D > 1) && (D = 1);
  const U = compositeModes[P];
  return g = Math.round(g), w = Math.round(w), D !== 1 && d.scan((Z, $, j) => {
    const G = d.bitmap.data[j + 3] * D;
    d.bitmap.data[j + 3] = G;
  }), m.scan((Z, $, j) => {
    const G = d.getPixelIndex(g + Z, w + $, Edge.CROP);
    if (G === -1) return;
    const Q = U({ r: m.bitmap.data[j + 0] / 255, g: m.bitmap.data[j + 1] / 255, b: m.bitmap.data[j + 2] / 255, a: m.bitmap.data[j + 3] / 255 }, { r: d.bitmap.data[G + 0] / 255, g: d.bitmap.data[G + 1] / 255, b: d.bitmap.data[G + 2] / 255, a: d.bitmap.data[G + 3] / 255 }, F);
    d.bitmap.data[G + 0] = limit255(255 * Q.r), d.bitmap.data[G + 1] = limit255(255 * Q.g), d.bitmap.data[G + 2] = limit255(255 * Q.b), d.bitmap.data[G + 3] = limit255(255 * Q.a);
  }), d;
}
var jpeg$1 = { parseSections: function(d, m) {
  var g, w;
  for (d.setBigEndian(!0); d.remainingLength() > 0 && w !== 218; ) {
    if (d.nextUInt8() !== 255) throw new Error("Invalid JPEG section offset");
    g = (w = d.nextUInt8()) >= 208 && w <= 217 || w === 218 ? 0 : d.nextUInt16() - 2, m(w, d.branch(0, g)), d.skip(g);
  }
}, getSizeFromSOFSection: function(d) {
  return d.skip(1), { height: d.nextUInt16(), width: d.nextUInt16() };
}, getSectionName: function(d) {
  var m, g;
  switch (d) {
    case 216:
      m = "SOI";
      break;
    case 196:
      m = "DHT";
      break;
    case 219:
      m = "DQT";
      break;
    case 221:
      m = "DRI";
      break;
    case 218:
      m = "SOS";
      break;
    case 254:
      m = "COM";
      break;
    case 217:
      m = "EOI";
      break;
    default:
      d >= 224 && d <= 239 ? (m = "APP", g = d - 224) : d >= 192 && d <= 207 && d !== 196 && d !== 200 && d !== 204 ? (m = "SOF", g = d - 192) : d >= 208 && d <= 215 && (m = "RST", g = d - 208);
  }
  var w = { name: m };
  return typeof g == "number" && (w.index = g), w;
} };
function readExifValue(d, m) {
  switch (d) {
    case 1:
      return m.nextUInt8();
    case 3:
    case 8:
      return m.nextUInt16();
    case 4:
    case 9:
      return m.nextUInt32();
    case 5:
      return [m.nextUInt32(), m.nextUInt32()];
    case 6:
      return m.nextInt8();
    case 10:
      return [m.nextInt32(), m.nextInt32()];
    case 11:
      return m.nextFloat();
    case 12:
      return m.nextDouble();
    default:
      throw new Error("Invalid format while decoding: " + d);
  }
}
function getBytesPerComponent(d) {
  switch (d) {
    case 1:
    case 2:
    case 6:
    case 7:
      return 1;
    case 3:
    case 8:
      return 2;
    case 4:
    case 9:
    case 11:
      return 4;
    case 5:
    case 10:
    case 12:
      return 8;
    default:
      return 0;
  }
}
function readExifTag(d, m) {
  var g, w, I = m.nextUInt16(), P = m.nextUInt16(), F = getBytesPerComponent(P), D = m.nextUInt32(), U = F * D;
  if (U > 4 && (m = d.openWithOffset(m.nextUInt32())), P === 2) {
    var Z = (g = m.nextString(D)).indexOf("\0");
    Z !== -1 && (g = g.substr(0, Z));
  } else if (P === 7) g = m.nextBuffer(D);
  else if (P !== 0) for (g = [], w = 0; w < D; ++w) g.push(readExifValue(P, m));
  return U < 4 && m.skip(4 - U), [I, g, P];
}
function readIFDSection(d, m, g) {
  var w, I, P = m.nextUInt16();
  for (I = 0; I < P; ++I) g((w = readExifTag(d, m))[0], w[1], w[2]);
}
function readHeader(d) {
  if (d.nextString(6) !== "Exif\0\0") throw new Error("Invalid EXIF header");
  var m = d.mark(), g = d.nextUInt16();
  if (g === 18761) d.setBigEndian(!1);
  else {
    if (g !== 19789) throw new Error("Invalid TIFF header");
    d.setBigEndian(!0);
  }
  if (d.nextUInt16() !== 42) throw new Error("Invalid TIFF data");
  return m;
}
var exif$2 = { IFD0: 1, IFD1: 2, GPSIFD: 3, SubIFD: 4, InteropIFD: 5, parseTags: function(d, m) {
  var g, w, I, P;
  try {
    g = readHeader(d);
  } catch {
    return !1;
  }
  var F = g.openWithOffset(d.nextUInt32()), D = this.IFD0;
  readIFDSection(g, F, function(H, W, q) {
    switch (H) {
      case 34853:
        I = W[0];
        break;
      case 34665:
        w = W[0];
        break;
      default:
        m(D, H, W, q);
    }
  });
  var U = F.nextUInt32();
  if (U !== 0) {
    var Z = g.openWithOffset(U);
    readIFDSection(g, Z, m.bind(null, this.IFD1));
  }
  if (I) {
    var $ = g.openWithOffset(I);
    readIFDSection(g, $, m.bind(null, this.GPSIFD));
  }
  if (w) {
    var j = g.openWithOffset(w), G = this.InteropIFD;
    readIFDSection(g, j, function(H, W, q) {
      H === 40965 ? P = W[0] : m(G, H, W, q);
    });
  }
  if (P) {
    var Q = g.openWithOffset(P);
    readIFDSection(g, Q, m.bind(null, this.InteropIFD));
  }
  return !0;
} };
function parseNumber(d) {
  return parseInt(d, 10);
}
var hours = 3600, minutes = 60;
function parseDateTimeParts(d, m) {
  d = d.map(parseNumber), m = m.map(parseNumber);
  var g = d[0], w = d[1] - 1, I = d[2], P = m[0], F = m[1], D = m[2];
  return Date.UTC(g, w, I, P, F, D, 0) / 1e3;
}
function parseDateWithTimezoneFormat(d) {
  var m = d.substr(0, 10).split("-"), g = d.substr(11, 8).split(":"), w = d.substr(19, 6).split(":").map(parseNumber), I = w[0] * hours + w[1] * minutes, P = parseDateTimeParts(m, g);
  if (typeof (P -= I) == "number" && !isNaN(P)) return P;
}
function parseDateWithSpecFormat(d) {
  var m = d.split(" "), g = parseDateTimeParts(m[0].split(":"), m[1].split(":"));
  if (typeof g == "number" && !isNaN(g)) return g;
}
function parseExifDate(d) {
  var m = d.length === 19 && d.charAt(4) === ":";
  return d.length === 25 && d.charAt(10) === "T" ? parseDateWithTimezoneFormat(d) : m ? parseDateWithSpecFormat(d) : void 0;
}
var date$1 = { parseDateWithSpecFormat, parseDateWithTimezoneFormat, parseExifDate }, exif$1 = exif$2, date = date$1, degreeTags = [{ section: exif$1.GPSIFD, type: 2, name: "GPSLatitude", refType: 1, refName: "GPSLatitudeRef", posVal: "N" }, { section: exif$1.GPSIFD, type: 4, name: "GPSLongitude", refType: 3, refName: "GPSLongitudeRef", posVal: "E" }], dateTags = [{ section: exif$1.SubIFD, type: 306, name: "ModifyDate" }, { section: exif$1.SubIFD, type: 36867, name: "DateTimeOriginal" }, { section: exif$1.SubIFD, type: 36868, name: "CreateDate" }, { section: exif$1.SubIFD, type: 306, name: "ModifyDate" }], simplify$1 = { castDegreeValues: function(d, m) {
  degreeTags.forEach(function(g) {
    var w = d(g);
    if (w) {
      var I = d({ section: g.section, type: g.refType, name: g.refName }) === g.posVal ? 1 : -1, P = (w[0] + w[1] / 60 + w[2] / 3600) * I;
      m(g, P);
    }
  });
}, castDateValues: function(d, m) {
  dateTags.forEach(function(g) {
    var w = d(g);
    if (w) {
      var I = date.parseExifDate(w);
      I !== void 0 && m(g, I);
    }
  });
}, simplifyValue: function(d, m) {
  return Array.isArray(d) && (d = d.map(function(g) {
    return m === 10 || m === 5 ? g[0] / g[1] : g;
  })).length === 1 && (d = d[0]), d;
} }, exifTags, hasRequiredExifTags;
function requireExifTags() {
  return hasRequiredExifTags ? exifTags : (hasRequiredExifTags = 1, exifTags = { exif: { 1: "InteropIndex", 2: "InteropVersion", 11: "ProcessingSoftware", 254: "SubfileType", 255: "OldSubfileType", 256: "ImageWidth", 257: "ImageHeight", 258: "BitsPerSample", 259: "Compression", 262: "PhotometricInterpretation", 263: "Thresholding", 264: "CellWidth", 265: "CellLength", 266: "FillOrder", 269: "DocumentName", 270: "ImageDescription", 271: "Make", 272: "Model", 273: "StripOffsets", 274: "Orientation", 277: "SamplesPerPixel", 278: "RowsPerStrip", 279: "StripByteCounts", 280: "MinSampleValue", 281: "MaxSampleValue", 282: "XResolution", 283: "YResolution", 284: "PlanarConfiguration", 285: "PageName", 286: "XPosition", 287: "YPosition", 288: "FreeOffsets", 289: "FreeByteCounts", 290: "GrayResponseUnit", 291: "GrayResponseCurve", 292: "T4Options", 293: "T6Options", 296: "ResolutionUnit", 297: "PageNumber", 300: "ColorResponseUnit", 301: "TransferFunction", 305: "Software", 306: "ModifyDate", 315: "Artist", 316: "HostComputer", 317: "Predictor", 318: "WhitePoint", 319: "PrimaryChromaticities", 320: "ColorMap", 321: "HalftoneHints", 322: "TileWidth", 323: "TileLength", 324: "TileOffsets", 325: "TileByteCounts", 326: "BadFaxLines", 327: "CleanFaxData", 328: "ConsecutiveBadFaxLines", 330: "SubIFD", 332: "InkSet", 333: "InkNames", 334: "NumberofInks", 336: "DotRange", 337: "TargetPrinter", 338: "ExtraSamples", 339: "SampleFormat", 340: "SMinSampleValue", 341: "SMaxSampleValue", 342: "TransferRange", 343: "ClipPath", 344: "XClipPathUnits", 345: "YClipPathUnits", 346: "Indexed", 347: "JPEGTables", 351: "OPIProxy", 400: "GlobalParametersIFD", 401: "ProfileType", 402: "FaxProfile", 403: "CodingMethods", 404: "VersionYear", 405: "ModeNumber", 433: "Decode", 434: "DefaultImageColor", 435: "T82Options", 437: "JPEGTables", 512: "JPEGProc", 513: "ThumbnailOffset", 514: "ThumbnailLength", 515: "JPEGRestartInterval", 517: "JPEGLosslessPredictors", 518: "JPEGPointTransforms", 519: "JPEGQTables", 520: "JPEGDCTables", 521: "JPEGACTables", 529: "YCbCrCoefficients", 530: "YCbCrSubSampling", 531: "YCbCrPositioning", 532: "ReferenceBlackWhite", 559: "StripRowCounts", 700: "ApplicationNotes", 999: "USPTOMiscellaneous", 4096: "RelatedImageFileFormat", 4097: "RelatedImageWidth", 4098: "RelatedImageHeight", 18246: "Rating", 18247: "XP_DIP_XML", 18248: "StitchInfo", 18249: "RatingPercent", 32781: "ImageID", 32931: "WangTag1", 32932: "WangAnnotation", 32933: "WangTag3", 32934: "WangTag4", 32995: "Matteing", 32996: "DataType", 32997: "ImageDepth", 32998: "TileDepth", 33405: "Model2", 33421: "CFARepeatPatternDim", 33422: "CFAPattern2", 33423: "BatteryLevel", 33424: "KodakIFD", 33432: "Copyright", 33434: "ExposureTime", 33437: "FNumber", 33445: "MDFileTag", 33446: "MDScalePixel", 33447: "MDColorTable", 33448: "MDLabName", 33449: "MDSampleInfo", 33450: "MDPrepDate", 33451: "MDPrepTime", 33452: "MDFileUnits", 33550: "PixelScale", 33589: "AdventScale", 33590: "AdventRevision", 33628: "UIC1Tag", 33629: "UIC2Tag", 33630: "UIC3Tag", 33631: "UIC4Tag", 33723: "IPTC-NAA", 33918: "IntergraphPacketData", 33919: "IntergraphFlagRegisters", 33920: "IntergraphMatrix", 33921: "INGRReserved", 33922: "ModelTiePoint", 34016: "Site", 34017: "ColorSequence", 34018: "IT8Header", 34019: "RasterPadding", 34020: "BitsPerRunLength", 34021: "BitsPerExtendedRunLength", 34022: "ColorTable", 34023: "ImageColorIndicator", 34024: "BackgroundColorIndicator", 34025: "ImageColorValue", 34026: "BackgroundColorValue", 34027: "PixelIntensityRange", 34028: "TransparencyIndicator", 34029: "ColorCharacterization", 34030: "HCUsage", 34031: "TrapIndicator", 34032: "CMYKEquivalent", 34118: "SEMInfo", 34152: "AFCP_IPTC", 34232: "PixelMagicJBIGOptions", 34264: "ModelTransform", 34306: "WB_GRGBLevels", 34310: "LeafData", 34377: "PhotoshopSettings", 34665: "ExifOffset", 34675: "ICC_Profile", 34687: "TIFF_FXExtensions", 34688: "MultiProfiles", 34689: "SharedData", 34690: "T88Options", 34732: "ImageLayer", 34735: "GeoTiffDirectory", 34736: "GeoTiffDoubleParams", 34737: "GeoTiffAsciiParams", 34850: "ExposureProgram", 34852: "SpectralSensitivity", 34853: "GPSInfo", 34855: "ISO", 34856: "Opto-ElectricConvFactor", 34857: "Interlace", 34858: "TimeZoneOffset", 34859: "SelfTimerMode", 34864: "SensitivityType", 34865: "StandardOutputSensitivity", 34866: "RecommendedExposureIndex", 34867: "ISOSpeed", 34868: "ISOSpeedLatitudeyyy", 34869: "ISOSpeedLatitudezzz", 34908: "FaxRecvParams", 34909: "FaxSubAddress", 34910: "FaxRecvTime", 34954: "LeafSubIFD", 36864: "ExifVersion", 36867: "DateTimeOriginal", 36868: "CreateDate", 37121: "ComponentsConfiguration", 37122: "CompressedBitsPerPixel", 37377: "ShutterSpeedValue", 37378: "ApertureValue", 37379: "BrightnessValue", 37380: "ExposureCompensation", 37381: "MaxApertureValue", 37382: "SubjectDistance", 37383: "MeteringMode", 37384: "LightSource", 37385: "Flash", 37386: "FocalLength", 37387: "FlashEnergy", 37388: "SpatialFrequencyResponse", 37389: "Noise", 37390: "FocalPlaneXResolution", 37391: "FocalPlaneYResolution", 37392: "FocalPlaneResolutionUnit", 37393: "ImageNumber", 37394: "SecurityClassification", 37395: "ImageHistory", 37396: "SubjectArea", 37397: "ExposureIndex", 37398: "TIFF-EPStandardID", 37399: "SensingMethod", 37434: "CIP3DataFile", 37435: "CIP3Sheet", 37436: "CIP3Side", 37439: "StoNits", 37500: "MakerNote", 37510: "UserComment", 37520: "SubSecTime", 37521: "SubSecTimeOriginal", 37522: "SubSecTimeDigitized", 37679: "MSDocumentText", 37680: "MSPropertySetStorage", 37681: "MSDocumentTextPosition", 37724: "ImageSourceData", 40091: "XPTitle", 40092: "XPComment", 40093: "XPAuthor", 40094: "XPKeywords", 40095: "XPSubject", 40960: "FlashpixVersion", 40961: "ColorSpace", 40962: "ExifImageWidth", 40963: "ExifImageHeight", 40964: "RelatedSoundFile", 40965: "InteropOffset", 41483: "FlashEnergy", 41484: "SpatialFrequencyResponse", 41485: "Noise", 41486: "FocalPlaneXResolution", 41487: "FocalPlaneYResolution", 41488: "FocalPlaneResolutionUnit", 41489: "ImageNumber", 41490: "SecurityClassification", 41491: "ImageHistory", 41492: "SubjectLocation", 41493: "ExposureIndex", 41494: "TIFF-EPStandardID", 41495: "SensingMethod", 41728: "FileSource", 41729: "SceneType", 41730: "CFAPattern", 41985: "CustomRendered", 41986: "ExposureMode", 41987: "WhiteBalance", 41988: "DigitalZoomRatio", 41989: "FocalLengthIn35mmFormat", 41990: "SceneCaptureType", 41991: "GainControl", 41992: "Contrast", 41993: "Saturation", 41994: "Sharpness", 41995: "DeviceSettingDescription", 41996: "SubjectDistanceRange", 42016: "ImageUniqueID", 42032: "OwnerName", 42033: "SerialNumber", 42034: "LensInfo", 42035: "LensMake", 42036: "LensModel", 42037: "LensSerialNumber", 42112: "GDALMetadata", 42113: "GDALNoData", 42240: "Gamma", 44992: "ExpandSoftware", 44993: "ExpandLens", 44994: "ExpandFilm", 44995: "ExpandFilterLens", 44996: "ExpandScanner", 44997: "ExpandFlashLamp", 48129: "PixelFormat", 48130: "Transformation", 48131: "Uncompressed", 48132: "ImageType", 48256: "ImageWidth", 48257: "ImageHeight", 48258: "WidthResolution", 48259: "HeightResolution", 48320: "ImageOffset", 48321: "ImageByteCount", 48322: "AlphaOffset", 48323: "AlphaByteCount", 48324: "ImageDataDiscard", 48325: "AlphaDataDiscard", 50215: "OceScanjobDesc", 50216: "OceApplicationSelector", 50217: "OceIDNumber", 50218: "OceImageLogic", 50255: "Annotations", 50341: "PrintIM", 50560: "USPTOOriginalContentType", 50706: "DNGVersion", 50707: "DNGBackwardVersion", 50708: "UniqueCameraModel", 50709: "LocalizedCameraModel", 50710: "CFAPlaneColor", 50711: "CFALayout", 50712: "LinearizationTable", 50713: "BlackLevelRepeatDim", 50714: "BlackLevel", 50715: "BlackLevelDeltaH", 50716: "BlackLevelDeltaV", 50717: "WhiteLevel", 50718: "DefaultScale", 50719: "DefaultCropOrigin", 50720: "DefaultCropSize", 50721: "ColorMatrix1", 50722: "ColorMatrix2", 50723: "CameraCalibration1", 50724: "CameraCalibration2", 50725: "ReductionMatrix1", 50726: "ReductionMatrix2", 50727: "AnalogBalance", 50728: "AsShotNeutral", 50729: "AsShotWhiteXY", 50730: "BaselineExposure", 50731: "BaselineNoise", 50732: "BaselineSharpness", 50733: "BayerGreenSplit", 50734: "LinearResponseLimit", 50735: "CameraSerialNumber", 50736: "DNGLensInfo", 50737: "ChromaBlurRadius", 50738: "AntiAliasStrength", 50739: "ShadowScale", 50740: "DNGPrivateData", 50741: "MakerNoteSafety", 50752: "RawImageSegmentation", 50778: "CalibrationIlluminant1", 50779: "CalibrationIlluminant2", 50780: "BestQualityScale", 50781: "RawDataUniqueID", 50784: "AliasLayerMetadata", 50827: "OriginalRawFileName", 50828: "OriginalRawFileData", 50829: "ActiveArea", 50830: "MaskedAreas", 50831: "AsShotICCProfile", 50832: "AsShotPreProfileMatrix", 50833: "CurrentICCProfile", 50834: "CurrentPreProfileMatrix", 50879: "ColorimetricReference", 50898: "PanasonicTitle", 50899: "PanasonicTitle2", 50931: "CameraCalibrationSig", 50932: "ProfileCalibrationSig", 50933: "ProfileIFD", 50934: "AsShotProfileName", 50935: "NoiseReductionApplied", 50936: "ProfileName", 50937: "ProfileHueSatMapDims", 50938: "ProfileHueSatMapData1", 50939: "ProfileHueSatMapData2", 50940: "ProfileToneCurve", 50941: "ProfileEmbedPolicy", 50942: "ProfileCopyright", 50964: "ForwardMatrix1", 50965: "ForwardMatrix2", 50966: "PreviewApplicationName", 50967: "PreviewApplicationVersion", 50968: "PreviewSettingsName", 50969: "PreviewSettingsDigest", 50970: "PreviewColorSpace", 50971: "PreviewDateTime", 50972: "RawImageDigest", 50973: "OriginalRawFileDigest", 50974: "SubTileBlockSize", 50975: "RowInterleaveFactor", 50981: "ProfileLookTableDims", 50982: "ProfileLookTableData", 51008: "OpcodeList1", 51009: "OpcodeList2", 51022: "OpcodeList3", 51041: "NoiseProfile", 51043: "TimeCodes", 51044: "FrameRate", 51058: "TStop", 51081: "ReelName", 51089: "OriginalDefaultFinalSize", 51090: "OriginalBestQualitySize", 51091: "OriginalDefaultCropSize", 51105: "CameraLabel", 51107: "ProfileHueSatMapEncoding", 51108: "ProfileLookTableEncoding", 51109: "BaselineExposureOffset", 51110: "DefaultBlackRender", 51111: "NewRawImageDigest", 51112: "RawToPreviewGain", 51125: "DefaultUserCrop", 59932: "Padding", 59933: "OffsetSchema", 65e3: "OwnerName", 65001: "SerialNumber", 65002: "Lens", 65024: "KDC_IFD", 65100: "RawFile", 65101: "Converter", 65102: "WhiteBalance", 65105: "Exposure", 65106: "Shadows", 65107: "Brightness", 65108: "Contrast", 65109: "Saturation", 65110: "Sharpness", 65111: "Smoothness", 65112: "MoireFilter" }, gps: { 0: "GPSVersionID", 1: "GPSLatitudeRef", 2: "GPSLatitude", 3: "GPSLongitudeRef", 4: "GPSLongitude", 5: "GPSAltitudeRef", 6: "GPSAltitude", 7: "GPSTimeStamp", 8: "GPSSatellites", 9: "GPSStatus", 10: "GPSMeasureMode", 11: "GPSDOP", 12: "GPSSpeedRef", 13: "GPSSpeed", 14: "GPSTrackRef", 15: "GPSTrack", 16: "GPSImgDirectionRef", 17: "GPSImgDirection", 18: "GPSMapDatum", 19: "GPSDestLatitudeRef", 20: "GPSDestLatitude", 21: "GPSDestLongitudeRef", 22: "GPSDestLongitude", 23: "GPSDestBearingRef", 24: "GPSDestBearing", 25: "GPSDestDistanceRef", 26: "GPSDestDistance", 27: "GPSProcessingMethod", 28: "GPSAreaInformation", 29: "GPSDateStamp", 30: "GPSDifferential", 31: "GPSHPositioningError" } });
}
var jpeg = jpeg$1, exif = exif$2, simplify = simplify$1;
function ExifResult(d, m, g, w, I, P, F) {
  this.startMarker = d, this.tags = m, this.imageSize = g, this.thumbnailOffset = w, this.thumbnailLength = I, this.thumbnailType = P, this.app1Offset = F;
}
function Parser$1(d) {
  this.stream = d, this.flags = { readBinaryTags: !1, resolveTagNames: !0, simplifyValues: !0, imageSize: !0, hidePointers: !0, returnTags: !0 };
}
ExifResult.prototype = { hasThumbnail: function(d) {
  return !(!this.thumbnailOffset || !this.thumbnailLength) && (typeof d != "string" || (d.toLowerCase().trim() === "image/jpeg" ? this.thumbnailType === 6 : d.toLowerCase().trim() === "image/tiff" && this.thumbnailType === 1));
}, getThumbnailOffset: function() {
  return this.app1Offset + 6 + this.thumbnailOffset;
}, getThumbnailLength: function() {
  return this.thumbnailLength;
}, getThumbnailBuffer: function() {
  return this._getThumbnailStream().nextBuffer(this.thumbnailLength);
}, _getThumbnailStream: function() {
  return this.startMarker.openWithOffset(this.getThumbnailOffset());
}, getImageSize: function() {
  return this.imageSize;
}, getThumbnailSize: function() {
  var d, m = this._getThumbnailStream();
  return jpeg.parseSections(m, function(g, w) {
    jpeg.getSectionName(g).name === "SOF" && (d = jpeg.getSizeFromSOFSection(w));
  }), d;
} }, Parser$1.prototype = { enableBinaryFields: function(d) {
  return this.flags.readBinaryTags = !!d, this;
}, enablePointers: function(d) {
  return this.flags.hidePointers = !d, this;
}, enableTagNames: function(d) {
  return this.flags.resolveTagNames = !!d, this;
}, enableImageSize: function(d) {
  return this.flags.imageSize = !!d, this;
}, enableReturnTags: function(d) {
  return this.flags.returnTags = !!d, this;
}, enableSimpleValues: function(d) {
  return this.flags.simplifyValues = !!d, this;
}, parse: function() {
  var d, m, g, w, I, P, F, D, U, Z = this.stream.mark(), $ = Z.openWithOffset(0), j = this.flags;
  return j.resolveTagNames && (F = requireExifTags()), j.resolveTagNames ? (d = {}, D = function(G) {
    return d[G.name];
  }, U = function(G, Q) {
    d[G.name] = Q;
  }) : (d = [], D = function(G) {
    var Q;
    for (Q = 0; Q < d.length; ++Q) if (d[Q].type === G.type && d[Q].section === G.section) return d.value;
  }, U = function(G, Q) {
    var H;
    for (H = 0; H < d.length; ++H) if (d[H].type === G.type && d[H].section === G.section) return void (d.value = Q);
  }), jpeg.parseSections($, function(G, Q) {
    var H = Q.offsetFrom(Z);
    G === 225 ? exif.parseTags(Q, function(W, q, et, rt) {
      if (j.readBinaryTags || rt !== 7) {
        if (q === 513) {
          if (g = et[0], j.hidePointers) return;
        } else if (q === 514) {
          if (w = et[0], j.hidePointers) return;
        } else if (q === 259 && (I = et[0], j.hidePointers)) return;
        if (j.returnTags) if (j.simplifyValues && (et = simplify.simplifyValue(et, rt)), j.resolveTagNames) {
          var tt = (W === exif.GPSIFD ? F.gps : F.exif)[q];
          tt || (tt = F.exif[q]), d.hasOwnProperty(tt) || (d[tt] = et);
        } else d.push({ section: W, type: q, value: et });
      }
    }) && (P = H) : j.imageSize && jpeg.getSectionName(G).name === "SOF" && (m = jpeg.getSizeFromSOFSection(Q));
  }), j.simplifyValues && (simplify.castDegreeValues(D, U), simplify.castDateValues(D, U)), new ExifResult(Z, d, m, g, w, I, P);
} };
var parser = Parser$1, domBufferstream, hasRequiredDomBufferstream, bufferstream, hasRequiredBufferstream;
function requireDomBufferstream() {
  if (hasRequiredDomBufferstream) return domBufferstream;
  function d(m, g, w, I, P, F) {
    this.global = P, g = g || 0, w = w || m.byteLength - g, this.arrayBuffer = m.slice(g, g + w), this.view = new P.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength), this.setBigEndian(I), this.offset = 0, this.parentOffset = (F || 0) + g;
  }
  return hasRequiredDomBufferstream = 1, d.prototype = { setBigEndian: function(m) {
    this.littleEndian = !m;
  }, nextUInt8: function() {
    var m = this.view.getUint8(this.offset);
    return this.offset += 1, m;
  }, nextInt8: function() {
    var m = this.view.getInt8(this.offset);
    return this.offset += 1, m;
  }, nextUInt16: function() {
    var m = this.view.getUint16(this.offset, this.littleEndian);
    return this.offset += 2, m;
  }, nextUInt32: function() {
    var m = this.view.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, m;
  }, nextInt16: function() {
    var m = this.view.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, m;
  }, nextInt32: function() {
    var m = this.view.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, m;
  }, nextFloat: function() {
    var m = this.view.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, m;
  }, nextDouble: function() {
    var m = this.view.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, m;
  }, nextBuffer: function(m) {
    var g = this.arrayBuffer.slice(this.offset, this.offset + m);
    return this.offset += m, g;
  }, remainingLength: function() {
    return this.arrayBuffer.byteLength - this.offset;
  }, nextString: function(m) {
    var g = this.arrayBuffer.slice(this.offset, this.offset + m);
    return g = String.fromCharCode.apply(null, new this.global.Uint8Array(g)), this.offset += m, g;
  }, mark: function() {
    var m = this;
    return { openWithOffset: function(g) {
      return g = (g || 0) + this.offset, new d(m.arrayBuffer, g, m.arrayBuffer.byteLength - g, !m.littleEndian, m.global, m.parentOffset);
    }, offset: this.offset, getParentOffset: function() {
      return m.parentOffset;
    } };
  }, offsetFrom: function(m) {
    return this.parentOffset + this.offset - (m.offset + m.getParentOffset());
  }, skip: function(m) {
    this.offset += m;
  }, branch: function(m, g) {
    return g = typeof g == "number" ? g : this.arrayBuffer.byteLength - (this.offset + m), new d(this.arrayBuffer, this.offset + m, g, !this.littleEndian, this.global, this.parentOffset);
  } }, domBufferstream = d;
}
function requireBufferstream() {
  if (hasRequiredBufferstream) return bufferstream;
  function d(m, g, w, I) {
    this.buffer = m, this.offset = g || 0, w = typeof w == "number" ? w : m.length, this.endPosition = this.offset + w, this.setBigEndian(I);
  }
  return hasRequiredBufferstream = 1, d.prototype = { setBigEndian: function(m) {
    this.bigEndian = !!m;
  }, nextUInt8: function() {
    var m = this.buffer.readUInt8(this.offset);
    return this.offset += 1, m;
  }, nextInt8: function() {
    var m = this.buffer.readInt8(this.offset);
    return this.offset += 1, m;
  }, nextUInt16: function() {
    var m = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);
    return this.offset += 2, m;
  }, nextUInt32: function() {
    var m = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);
    return this.offset += 4, m;
  }, nextInt16: function() {
    var m = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);
    return this.offset += 2, m;
  }, nextInt32: function() {
    var m = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);
    return this.offset += 4, m;
  }, nextFloat: function() {
    var m = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);
    return this.offset += 4, m;
  }, nextDouble: function() {
    var m = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);
    return this.offset += 8, m;
  }, nextBuffer: function(m) {
    var g = this.buffer.slice(this.offset, this.offset + m);
    return this.offset += m, g;
  }, remainingLength: function() {
    return this.endPosition - this.offset;
  }, nextString: function(m) {
    var g = this.buffer.toString("utf8", this.offset, this.offset + m);
    return this.offset += m, g;
  }, mark: function() {
    var m = this;
    return { openWithOffset: function(g) {
      return g = (g || 0) + this.offset, new d(m.buffer, g, m.endPosition - g, m.bigEndian);
    }, offset: this.offset };
  }, offsetFrom: function(m) {
    return this.offset - m.offset;
  }, skip: function(m) {
    this.offset += m;
  }, branch: function(m, g) {
    return g = typeof g == "number" ? g : this.endPosition - (this.offset + m), new d(this.buffer, this.offset + m, g, this.bigEndian);
  } }, bufferstream = d;
}
var Parser = parser;
function getGlobal() {
  return (0, eval)("this");
}
var exifParser = { create: function(d, m) {
  if (d instanceof (m = m || getGlobal()).ArrayBuffer) {
    var g = requireDomBufferstream();
    return new Parser(new g(d, 0, d.byteLength, !0, m));
  }
  var w = requireBufferstream();
  return new Parser(new w(d, 0, d.length, !0));
} }, EXIFParser = getDefaultExportFromCjs(exifParser);
function getExifOrientation(d) {
  const m = d._exif;
  return m && m.tags && m.tags.Orientation || 1;
}
function getExifOrientationTransformation(d) {
  const m = d.bitmap.width, g = d.bitmap.height;
  switch (getExifOrientation(d)) {
    case 1:
    default:
      return null;
    case 2:
      return function(w, I) {
        return [m - w - 1, I];
      };
    case 3:
      return function(w, I) {
        return [m - w - 1, g - I - 1];
      };
    case 4:
      return function(w, I) {
        return [w, g - I - 1];
      };
    case 5:
      return function(w, I) {
        return [I, w];
      };
    case 6:
      return function(w, I) {
        return [I, g - w - 1];
      };
    case 7:
      return function(w, I) {
        return [m - I - 1, g - w - 1];
      };
    case 8:
      return function(w, I) {
        return [m - I - 1, w];
      };
  }
}
function transformBitmap(d, m, g, w) {
  const I = d.bitmap.data, P = d.bitmap.width, F = Buffer.alloc(I.length);
  for (let D = 0; D < m; D++) for (let U = 0; U < g; U++) {
    const [Z, $] = w(D, U), j = m * U + D << 2, G = P * $ + Z << 2, Q = I.readUInt32BE(G);
    F.writeUInt32BE(Q, j);
  }
  d.bitmap.data = F, d.bitmap.width = m, d.bitmap.height = g, d._exif.tags.Orientation = 1;
}
function exifRotate(d) {
  if (getExifOrientation(d) < 2) return;
  const m = getExifOrientationTransformation(d), g = getExifOrientation(d) > 4, w = g ? d.bitmap.height : d.bitmap.width, I = g ? d.bitmap.width : d.bitmap.height;
  m && transformBitmap(d, w, I, m);
}
async function attemptExifRotate(d, m) {
  try {
    d._exif = EXIFParser.create(m).parse(), exifRotate(d);
  } catch {
  }
}
var __defProp$2 = Object.defineProperty, __defNormalProp$2 = (d, m, g) => m in d ? __defProp$2(d, m, { enumerable: !0, configurable: !0, writable: !0, value: g }) : d[m] = g, __publicField$2 = (d, m, g) => __defNormalProp$2(d, typeof m != "symbol" ? m + "" : m, g);
const emptyBitmap = { data: Buffer.alloc(0), width: 0, height: 0 };
function bufferFromArrayBuffer(d) {
  const m = Buffer.alloc(d.byteLength), g = new Uint8Array(d);
  for (let w = 0; w < m.length; ++w) m[w] = g[w];
  return m;
}
function createJimp({ plugins: d, formats: m } = {}) {
  const g = d || [], w = (m || []).map((P) => P()), I = class {
    constructor(P = emptyBitmap) {
      if (__publicField$2(this, "bitmap", emptyBitmap), __publicField$2(this, "background", 0), __publicField$2(this, "formats", []), __publicField$2(this, "mime"), this.formats = w, "data" in P) this.bitmap = P;
      else if (this.bitmap = { data: Buffer.alloc(P.width * P.height * 4), width: P.width, height: P.height }, P.color) {
        this.background = typeof P.color == "string" ? cssColorToHex(P.color) : P.color;
        for (let F = 0; F < this.bitmap.data.length; F += 4) this.bitmap.data.writeUInt32BE(this.background, F);
      }
      for (const F of g) for (const D in F) this[D] = (...U) => {
        var $;
        const Z = ($ = F[D]) == null ? void 0 : $.call(F, this, ...U);
        return typeof Z == "object" && "bitmap" in Z ? (this.bitmap = Z.bitmap, this) : Z;
      };
    }
    static async read(P, F) {
      if (Buffer.isBuffer(P) || P instanceof ArrayBuffer) return this.fromBuffer(P);
      const [D, U] = await to(fetch(P));
      if (D) throw new Error(`Could not load Buffer from URL: ${P}`);
      if (!U.ok) throw new Error(`HTTP Status ${U.status} for url ${P}`);
      const [Z, $] = await to(U.arrayBuffer());
      if (Z) throw new Error(`Could not load Buffer from ${P}`);
      const j = bufferFromArrayBuffer($);
      return this.fromBuffer(j, F);
    }
    static fromBitmap(P) {
      let F;
      if (P.data instanceof Buffer && (F = Buffer.from(P.data)), (P.data instanceof Uint8Array || P.data instanceof Uint8ClampedArray) && (F = Buffer.from(P.data.buffer)), Array.isArray(P.data) && (F = Buffer.concat(P.data.map((D) => Buffer.from(D.toString(16).padStart(8, "0"), "hex")))), !F) throw new Error("data must be a Buffer");
      if (typeof P.height != "number" || typeof P.width != "number") throw new Error("bitmap must have width and height");
      return new I({ height: P.height, width: P.width, data: F });
    }
    static async fromBuffer(P, F) {
      const D = P instanceof ArrayBuffer ? bufferFromArrayBuffer(P) : P, U = await fileType$1.fromBuffer(D);
      if (!U || !U.mime) throw new Error("Could not find MIME for Buffer");
      const Z = w.find((j) => j.mime === U.mime);
      if (!Z || !Z.decode) throw new Error(`Mime type ${U.mime} does not support decoding`);
      const $ = new I(await Z.decode(D, F == null ? void 0 : F[Z.mime]));
      return $.mime = U.mime, attemptExifRotate($, D), $;
    }
    inspect() {
      return "<Jimp " + (this.bitmap === emptyBitmap ? "pending..." : this.bitmap.width + "x" + this.bitmap.height) + ">";
    }
    toString() {
      return "[object Jimp]";
    }
    get width() {
      return this.bitmap.width;
    }
    get height() {
      return this.bitmap.height;
    }
    async getBuffer(P, F) {
      const D = this.formats.find((Z) => Z.mime === P);
      if (!D || !D.encode) throw new Error(`Unsupported MIME type: ${P}`);
      let U;
      return D.hasAlpha ? U = this : (U = new I({ width: this.bitmap.width, height: this.bitmap.height, color: this.background }), composite(U, this)), D.encode(U.bitmap, F);
    }
    async getBase64(P, F) {
      return "data:" + P + ";base64," + (await this.getBuffer(P, F)).toString("base64");
    }
    async write(P, F) {
      const D = mime.getType(P);
      await writeFile(P, await this.getBuffer(D, F));
    }
    clone() {
      return new I({ ...this.bitmap, data: Buffer.from(this.bitmap.data) });
    }
    getPixelIndex(P, F, D) {
      let U, Z;
      if (D || (D = Edge.EXTEND), typeof P != "number" || typeof F != "number") throw new Error("x and y must be numbers");
      U = P = Math.round(P), Z = F = Math.round(F), D === Edge.EXTEND && (P < 0 && (U = 0), P >= this.bitmap.width && (U = this.bitmap.width - 1), F < 0 && (Z = 0), F >= this.bitmap.height && (Z = this.bitmap.height - 1)), D === Edge.WRAP && (P < 0 && (U = this.bitmap.width + P), P >= this.bitmap.width && (U = P % this.bitmap.width), F < 0 && (Z = this.bitmap.height + F), F >= this.bitmap.height && (Z = F % this.bitmap.height));
      let $ = this.bitmap.width * Z + U << 2;
      return (U < 0 || U >= this.bitmap.width) && ($ = -1), (Z < 0 || Z >= this.bitmap.height) && ($ = -1), $;
    }
    getPixelColor(P, F) {
      if (typeof P != "number" || typeof F != "number") throw new Error("x and y must be numbers");
      const D = this.getPixelIndex(P, F);
      return this.bitmap.data.readUInt32BE(D);
    }
    setPixelColor(P, F, D) {
      if (typeof P != "number" || typeof F != "number" || typeof D != "number") throw new Error("hex, x and y must be numbers");
      const U = this.getPixelIndex(F, D);
      return this.bitmap.data.writeUInt32BE(P, U), this;
    }
    hasAlpha() {
      const { width: P, height: F, data: D } = this.bitmap, U = P * F << 2;
      for (let Z = 3; Z < U; Z += 4) if (D[Z] !== 255) return !0;
      return !1;
    }
    composite(P, F = 0, D = 0, U = {}) {
      return composite(this, P, F, D, U);
    }
    scan(P, F, D, U, Z) {
      return scan(this, P, F, D, U, Z);
    }
    scanIterator(P = 0, F = 0, D = this.bitmap.width, U = this.bitmap.height) {
      if (typeof P != "number" || typeof F != "number") throw new Error("x and y must be numbers");
      if (typeof D != "number" || typeof U != "number") throw new Error("w and h must be numbers");
      return scanIterator(this, P, F, D, U);
    }
  };
  return I;
}
var ResizeStrategy, ResizeStrategy2;
function Resize(d, m, g, w, I, P, F) {
  this.widthOriginal = Math.abs(Math.floor(d) || 0), this.heightOriginal = Math.abs(Math.floor(m) || 0), this.targetWidth = Math.abs(Math.floor(g) || 0), this.targetHeight = Math.abs(Math.floor(w) || 0), this.colorChannels = I ? 4 : 3, this.interpolationPass = !!P, this.resizeCallback = typeof F == "function" ? F : function() {
  }, this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels, this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels, this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels, this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal, this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight, this.initialize();
}
ResizeStrategy2 = ResizeStrategy || (ResizeStrategy = {}), ResizeStrategy2.NEAREST_NEIGHBOR = "nearestNeighbor", ResizeStrategy2.BILINEAR = "bilinearInterpolation", ResizeStrategy2.BICUBIC = "bicubicInterpolation", ResizeStrategy2.HERMITE = "hermiteInterpolation", ResizeStrategy2.BEZIER = "bezierInterpolation", Resize.prototype.initialize = function() {
  if (!(this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0)) throw console.log(this), new Error("Invalid settings specified for the resizer.");
  this.configurePasses();
}, Resize.prototype.configurePasses = function() {
  this.widthOriginal === this.targetWidth ? this.resizeWidth = this.bypassResizer : (this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth, this.ratioWeightWidthPass < 1 && this.interpolationPass ? (this.initializeFirstPassBuffers(!0), this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB) : (this.initializeFirstPassBuffers(!1), this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB)), this.heightOriginal === this.targetHeight ? this.resizeHeight = this.bypassResizer : (this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight, this.ratioWeightHeightPass < 1 && this.interpolationPass ? (this.initializeSecondPassBuffers(!0), this.resizeHeight = this.resizeHeightInterpolated) : (this.initializeSecondPassBuffers(!1), this.resizeHeight = this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB));
}, Resize.prototype._resizeWidthInterpolatedRGBChannels = function(d, m) {
  const g = m ? 4 : 3, w = this.ratioWeightWidthPass, I = this.widthBuffer;
  let P, F, D = 0, U = 0, Z = 0, $ = 0, j = 0;
  for (P = 0; D < 1 / 3; P += g, D += w) for (U = P, Z = 0; U < this.widthPassResultSize; Z += this.originalWidthMultipliedByChannels, U += this.targetWidthMultipliedByChannels) I[U] = d[Z], I[U + 1] = d[Z + 1], I[U + 2] = d[Z + 2], m && (I[U + 3] = d[Z + 3]);
  for (D -= 1 / 3, F = this.widthOriginal - 1; D < F; P += g, D += w) for (j = D % 1, $ = 1 - j, U = P, Z = Math.floor(D) * g; U < this.widthPassResultSize; Z += this.originalWidthMultipliedByChannels, U += this.targetWidthMultipliedByChannels) I[U + 0] = d[Z + 0] * $ + d[Z + g + 0] * j, I[U + 1] = d[Z + 1] * $ + d[Z + g + 1] * j, I[U + 2] = d[Z + 2] * $ + d[Z + g + 2] * j, m && (I[U + 3] = d[Z + 3] * $ + d[Z + g + 3] * j);
  for (F = this.originalWidthMultipliedByChannels - g; P < this.targetWidthMultipliedByChannels; P += g) for (U = P, Z = F; U < this.widthPassResultSize; Z += this.originalWidthMultipliedByChannels, U += this.targetWidthMultipliedByChannels) I[U] = d[Z], I[U + 1] = d[Z + 1], I[U + 2] = d[Z + 2], m && (I[U + 3] = d[Z + 3]);
  return I;
}, Resize.prototype._resizeWidthRGBChannels = function(d, m) {
  const g = m ? 4 : 3, w = this.ratioWeightWidthPass, I = 1 / w, P = this.originalWidthMultipliedByChannels - g + 1, F = this.targetWidthMultipliedByChannels - g + 1, D = this.outputWidthWorkBench, U = this.widthBuffer, Z = this.outputWidthWorkBenchOpaquePixelsCount;
  let $ = 0, j = 0, G = 0, Q = 0, H = 0, W = 0, q = 0, et = 1, rt = 0, tt = 0, V = 0, X = 0;
  do {
    for (H = 0; H < this.originalHeightMultipliedByChannels; ) D[H++] = 0, D[H++] = 0, D[H++] = 0, m && (D[H++] = 0, Z[H / g - 1] = 0);
    $ = w;
    do {
      for (j = 1 + G - Q, et = Math.min($, j), H = 0, W = G; H < this.originalHeightMultipliedByChannels; W += P) rt = d[W], tt = d[++W], V = d[++W], X = m ? d[++W] : 255, D[H++] += (X ? rt : 0) * et, D[H++] += (X ? tt : 0) * et, D[H++] += (X ? V : 0) * et, m && (D[H++] += X * et, Z[H / g - 1] += X ? et : 0);
      if (!($ >= j)) {
        Q += $;
        break;
      }
      G += g, Q = G, $ -= j;
    } while ($ > 0 && G < this.originalWidthMultipliedByChannels);
    for (H = 0, W = q; H < this.originalHeightMultipliedByChannels; W += F) $ = m ? Z[H / g] : 1, et = m ? $ ? 1 / $ : 0 : I, U[W] = D[H++] * et, U[++W] = D[H++] * et, U[++W] = D[H++] * et, m && (U[++W] = D[H++] * I);
    q += g;
  } while (q < this.targetWidthMultipliedByChannels);
  return U;
}, Resize.prototype._resizeHeightRGBChannels = function(d, m) {
  const g = this.ratioWeightHeightPass, w = 1 / g, I = this.outputHeightWorkBench, P = this.heightBuffer, F = this.outputHeightWorkBenchOpaquePixelsCount;
  let D = 0, U = 0, Z = 0, $ = 0, j = 0, G = 0, Q = 0, H = 1, W = 0, q = 0, et = 0, rt = 0;
  do {
    for (j = 0; j < this.targetWidthMultipliedByChannels; ) I[j++] = 0, I[j++] = 0, I[j++] = 0, m && (I[j++] = 0, F[j / 4 - 1] = 0);
    D = g;
    do {
      for (U = 1 + Z - $, H = Math.min(D, U), Q = Z, j = 0; j < this.targetWidthMultipliedByChannels; ) W = d[Q++], q = d[Q++], et = d[Q++], rt = m ? d[Q++] : 255, I[j++] += (rt ? W : 0) * H, I[j++] += (rt ? q : 0) * H, I[j++] += (rt ? et : 0) * H, m && (I[j++] += rt * H, F[j / 4 - 1] += rt ? H : 0);
      if (!(D >= U)) {
        $ += D;
        break;
      }
      Z = Q, $ = Z, D -= U;
    } while (D > 0 && Z < this.widthPassResultSize);
    for (j = 0; j < this.targetWidthMultipliedByChannels; ) D = m ? F[j / 4] : 1, H = m ? D ? 1 / D : 0 : w, P[G++] = Math.round(I[j++] * H), P[G++] = Math.round(I[j++] * H), P[G++] = Math.round(I[j++] * H), m && (P[G++] = Math.round(I[j++] * w));
  } while (G < this.finalResultSize);
  return P;
}, Resize.prototype.resizeWidthInterpolatedRGB = function(d) {
  return this._resizeWidthInterpolatedRGBChannels(d, !1);
}, Resize.prototype.resizeWidthInterpolatedRGBA = function(d) {
  return this._resizeWidthInterpolatedRGBChannels(d, !0);
}, Resize.prototype.resizeWidthRGB = function(d) {
  return this._resizeWidthRGBChannels(d, !1);
}, Resize.prototype.resizeWidthRGBA = function(d) {
  return this._resizeWidthRGBChannels(d, !0);
}, Resize.prototype.resizeHeightInterpolated = function(d) {
  const m = this.ratioWeightHeightPass, g = this.heightBuffer;
  let w, I = 0, P = 0, F = 0, D = 0, U = 0, Z = 0, $ = 0;
  for (; I < 1 / 3; I += m) for (F = 0; F < this.targetWidthMultipliedByChannels; ) g[P++] = Math.round(d[F++]);
  for (I -= 1 / 3, w = this.heightOriginal - 1; I < w; I += m) for ($ = I % 1, Z = 1 - $, D = Math.floor(I) * this.targetWidthMultipliedByChannels, U = D + this.targetWidthMultipliedByChannels, F = 0; F < this.targetWidthMultipliedByChannels; ++F) g[P++] = Math.round(d[D++] * Z + d[U++] * $);
  for (; P < this.finalResultSize; ) for (F = 0, D = w * this.targetWidthMultipliedByChannels; F < this.targetWidthMultipliedByChannels; ++F) g[P++] = Math.round(d[D++]);
  return g;
}, Resize.prototype.resizeHeightRGB = function(d) {
  return this._resizeHeightRGBChannels(d, !1);
}, Resize.prototype.resizeHeightRGBA = function(d) {
  return this._resizeHeightRGBChannels(d, !0);
}, Resize.prototype.resize = function(d) {
  this.resizeCallback(this.resizeHeight(this.resizeWidth(d)));
}, Resize.prototype.bypassResizer = function(d) {
  return d;
}, Resize.prototype.initializeFirstPassBuffers = function(d) {
  this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize), d || (this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels), this.colorChannels > 3 && (this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal)));
}, Resize.prototype.initializeSecondPassBuffers = function(d) {
  this.heightBuffer = this.generateUint8Buffer(this.finalResultSize), d || (this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels), this.colorChannels > 3 && (this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth)));
}, Resize.prototype.generateFloatBuffer = function(d) {
  try {
    return new Float32Array(d);
  } catch (m) {
    return console.error(m), [];
  }
}, Resize.prototype.generateFloat64Buffer = function(d) {
  try {
    return new Float64Array(d);
  } catch (m) {
    return console.error(m), [];
  }
}, Resize.prototype.generateUint8Buffer = function(d) {
  try {
    return new Uint8Array(d);
  } catch (m) {
    return console.error(m), [];
  }
};
const operations = { nearestNeighbor(d, m) {
  const g = d.width, w = d.height, I = m.width, P = m.height, F = d.data, D = m.data;
  for (let U = 0; U < P; U++) for (let Z = 0; Z < I; Z++) {
    let $ = 4 * (U * I + Z), j = 4 * (Math.floor(U * w / P) * g + Math.floor(Z * g / I));
    D[$++] = F[j++], D[$++] = F[j++], D[$++] = F[j++], D[$++] = F[j++];
  }
}, bilinearInterpolation(d, m) {
  const g = d.width, w = d.height, I = m.width, P = m.height, F = d.data, D = m.data, U = function($, j, G, Q, H) {
    return j === Q ? G : Math.round(($ - j) * H + (Q - $) * G);
  }, Z = function($, j, G, Q, H, W, q, et) {
    let rt = 4 * (q * g + Q) + j, tt = 4 * (q * g + H) + j;
    const V = U(G, Q, F[rt], H, F[tt]);
    if (et === q) D[$ + j] = V;
    else {
      rt = 4 * (et * g + Q) + j, tt = 4 * (et * g + H) + j;
      const X = U(G, Q, F[rt], H, F[tt]);
      D[$ + j] = U(W, q, V, et, X);
    }
  };
  for (let $ = 0; $ < P; $++) for (let j = 0; j < I; j++) {
    const G = 4 * ($ * I + j), Q = j * g / I, H = Math.floor(Q), W = Math.min(Math.ceil(Q), g - 1), q = $ * w / P, et = Math.floor(q), rt = Math.min(Math.ceil(q), w - 1);
    Z(G, 0, Q, H, W, q, et, rt), Z(G, 1, Q, H, W, q, et, rt), Z(G, 2, Q, H, W, q, et, rt), Z(G, 3, Q, H, W, q, et, rt);
  }
}, _interpolate2D(d, m, g, w) {
  const I = d.data, P = m.data, F = d.width, D = d.height, U = m.width, Z = m.height, $ = Math.max(1, Math.floor(F / U)), j = U * $, G = Math.max(1, Math.floor(D / Z)), Q = Z * G, H = Buffer.alloc(j * D * 4);
  for (let et = 0; et < D; et++) for (let rt = 0; rt < j; rt++) {
    const tt = rt * (F - 1) / j, V = Math.floor(tt), X = tt - V, ot = 4 * (et * F + V), it = 4 * (et * j + rt);
    for (let st = 0; st < 4; st++) {
      const at = ot + st, ct = V > 0 ? I[at - 4] : 2 * I[at] - I[at + 4], K = I[at], lt = I[at + 4], vt = V < F - 2 ? I[at + 8] : 2 * I[at + 4] - I[at];
      H[it + st] = w(ct, K, lt, vt, X);
    }
  }
  const W = Buffer.alloc(j * Q * 4);
  for (let et = 0; et < Q; et++) for (let rt = 0; rt < j; rt++) {
    const tt = et * (D - 1) / Q, V = Math.floor(tt), X = tt - V, ot = 4 * (V * j + rt), it = 4 * (et * j + rt);
    for (let st = 0; st < 4; st++) {
      const at = ot + st, ct = V > 0 ? H[at - 4 * j] : 2 * H[at] - H[at + 4 * j], K = H[at], lt = H[at + 4 * j], vt = V < D - 2 ? H[at + 8 * j] : 2 * H[at + 4 * j] - H[at];
      W[it + st] = w(ct, K, lt, vt, X);
    }
  }
  const q = $ * G;
  if (q > 1) for (let et = 0; et < Z; et++) for (let rt = 0; rt < U; rt++) {
    let tt = 0, V = 0, X = 0, ot = 0, it = 0;
    for (let at = 0; at < G; at++) {
      const ct = et * G + at;
      for (let K = 0; K < $; K++) {
        const lt = 4 * (ct * j + (rt * $ + K)), vt = W[lt + 3];
        vt && (tt += W[lt], V += W[lt + 1], X += W[lt + 2], it++), ot += vt;
      }
    }
    const st = 4 * (et * U + rt);
    P[st] = it ? Math.round(tt / it) : 0, P[st + 1] = it ? Math.round(V / it) : 0, P[st + 2] = it ? Math.round(X / it) : 0, P[st + 3] = Math.round(ot / q);
  }
  else m.data = W;
}, bicubicInterpolation(d, m, g) {
  return this._interpolate2D(d, m, g, function(w, I, P, F, D) {
    const U = F - P - w + I, Z = w - I - U, $ = P - w, j = I;
    return Math.max(0, Math.min(255, U * (D * D * D) + Z * (D * D) + $ * D + j));
  });
}, hermiteInterpolation(d, m, g) {
  return this._interpolate2D(d, m, g, function(w, I, P, F, D) {
    const U = I, Z = 0.5 * (P - w), $ = w - 2.5 * I + 2 * P - 0.5 * F, j = 0.5 * (F - w) + 1.5 * (I - P);
    return Math.max(0, Math.min(255, Math.round(((j * D + $) * D + Z) * D + U)));
  });
}, bezierInterpolation(d, m, g) {
  return this._interpolate2D(d, m, g, function(w, I, P, F, D) {
    const U = 1 - D, Z = I * U * U * U, $ = 3 * (I + (P - w) / 4) * U * U * D, j = 3 * (P - (F - I) / 4) * U * D * D, G = P * D * D * D;
    return Math.max(0, Math.min(255, Math.round(Z + $ + j + G)));
  });
} }, ResizeOptionsSchema = z.union([z.object({ w: z.number().min(0), h: z.number().min(0).optional(), mode: z.nativeEnum(ResizeStrategy).optional() }), z.object({ w: z.number().min(0).optional(), h: z.number().min(0), mode: z.nativeEnum(ResizeStrategy).optional() })]), ScaleToFitOptionsSchema = z.object({ w: z.number().min(0), h: z.number().min(0), mode: z.nativeEnum(ResizeStrategy).optional() }), ScaleComplexOptionsSchema = z.object({ f: z.number().min(0), mode: z.nativeEnum(ResizeStrategy).optional() }), methods$d = { resize(d, m) {
  const { mode: g } = ResizeOptionsSchema.parse(m);
  let w, I;
  if (typeof m.w == "number") w = m.w, I = m.h ?? d.bitmap.height * (w / d.bitmap.width);
  else {
    if (typeof m.h != "number") throw new Error("w must be a number");
    I = m.h, w = m.w ?? d.bitmap.width * (I / d.bitmap.height);
  }
  if (w = Math.round(w) || 1, I = Math.round(I) || 1, g && typeof operations[g] == "function") {
    const P = { data: Buffer.alloc(w * I * 4), width: w, height: I };
    operations[g](d.bitmap, P), d.bitmap = P;
  } else
    new Resize(d.bitmap.width, d.bitmap.height, w, I, !0, !0, (P) => {
      d.bitmap.data = Buffer.from(P), d.bitmap.width = w, d.bitmap.height = I;
    }).resize(d.bitmap.data);
  return d;
}, scale(d, m) {
  const { f: g, mode: w } = typeof m == "number" ? { f: m } : ScaleComplexOptionsSchema.parse(m), I = d.bitmap.width * g, P = d.bitmap.height * g;
  return this.resize(d, { w: I, h: P, mode: w });
}, scaleToFit(d, m) {
  const { h: g, w, mode: I } = ScaleToFitOptionsSchema.parse(m), P = w / g > d.bitmap.width / d.bitmap.height ? g / d.bitmap.height : w / d.bitmap.width;
  return this.scale(d, { f: P, mode: I });
} }, ContainOptionsSchema = z.object({ w: z.number(), h: z.number(), align: z.number().optional(), mode: z.nativeEnum(ResizeStrategy).optional() }), methods$c = { contain(d, m) {
  const { w: g, h: w, align: I = HorizontalAlign.CENTER | VerticalAlign.MIDDLE, mode: P } = ContainOptionsSchema.parse(m), F = 7 & I, D = I >> 3;
  if ((F === 0 || F & F - 1) && (D === 0 || D & D - 1)) throw new Error("only use one flag per alignment direction");
  const U = F >> 1, Z = D >> 1, $ = g / w > d.bitmap.width / d.bitmap.height ? w / d.bitmap.height : g / d.bitmap.width, j = methods$d.scale(clone(d), { f: $, mode: P });
  return (d = methods$d.resize(d, { w: g, h: w, mode: P })).scan((G, Q, H) => {
    d.bitmap.data.writeUInt32BE(d.background, H);
  }), d = methods$h.blit(d, { src: j, x: (d.bitmap.width - j.bitmap.width) / 2 * U, y: (d.bitmap.height - j.bitmap.height) / 2 * Z });
} }, CropOptionsSchema = z.object({ x: z.number(), y: z.number(), w: z.number(), h: z.number() }), AutocropComplexOptionsSchema = z.object({ tolerance: z.number().min(0).max(1).optional(), cropOnlyFrames: z.boolean().optional(), cropSymmetric: z.boolean().optional(), leaveBorder: z.number().optional(), ignoreSides: z.object({ north: z.boolean().optional(), south: z.boolean().optional(), east: z.boolean().optional(), west: z.boolean().optional() }).optional() }), methods$b = { crop(d, m) {
  let { x: g, y: w, w: I, h: P } = CropOptionsSchema.parse(m);
  if (g = Math.round(g), w = Math.round(w), I = Math.round(I), P = Math.round(P), g === 0 && I === d.bitmap.width) {
    const F = I * w + g << 2, D = F + (P * I << 2);
    d.bitmap.data = d.bitmap.data.slice(F, D);
  } else {
    const F = Buffer.allocUnsafe(I * P * 4);
    let D = 0;
    scan(d, g, w, I, P, function(U, Z, $) {
      const j = d.bitmap.data.readUInt32BE($);
      F.writeUInt32BE(j, D), D += 4;
    }), d.bitmap.data = F;
  }
  return d.bitmap.width = I, d.bitmap.height = P, d;
}, autocrop(d, m = {}) {
  const { tolerance: g = 2e-4, cropOnlyFrames: w = !0, cropSymmetric: I = !1, leaveBorder: P = 0, ignoreSides: F } = typeof m == "number" ? { tolerance: m } : AutocropComplexOptionsSchema.parse(m), D = d.bitmap.width, U = d.bitmap.height, Z = { north: !1, south: !1, east: !1, west: !1, ...F };
  let $ = d.getPixelColor(0, 0);
  const j = intToRGBA$1($);
  let G = 0, Q = 0, H = 0, W = 0;
  if ($ = d.getPixelColor(0, 0), !Z.north) t: for (let tt = 0; tt < U - 1; tt++) {
    for (let V = 0; V < D; V++)
      if (colorDiff(j, intToRGBA$1(d.getPixelColor(V, tt))) > g) break t;
    G++;
  }
  if ($ = d.getPixelColor(D, 0), !Z.west) t: for (let tt = 0; tt < D - 1; tt++) {
    for (let V = 0 + G; V < U; V++)
      if (colorDiff(j, intToRGBA$1(d.getPixelColor(tt, V))) > g) break t;
    W++;
  }
  if ($ = d.getPixelColor(0, U), !Z.south) t: for (let tt = U - 1; tt >= G + 1; tt--) {
    for (let V = D - Q - 1; V >= 0; V--)
      if (colorDiff(j, intToRGBA$1(d.getPixelColor(V, tt))) > g) break t;
    H++;
  }
  if ($ = d.getPixelColor(D, U), !Z.east) t: for (let tt = D - 1; tt >= 0 + W + 1; tt--) {
    for (let V = U - 1; V >= 0 + G; V--)
      if (colorDiff(j, intToRGBA$1(d.getPixelColor(tt, V))) > g) break t;
    Q++;
  }
  let q = !1;
  if (W -= P, Q -= P, G -= P, H -= P, I) {
    const tt = Math.min(Q, W), V = Math.min(G, H);
    W = tt, Q = tt, G = V, H = V;
  }
  W = W >= 0 ? W : 0, Q = Q >= 0 ? Q : 0, G = G >= 0 ? G : 0, H = H >= 0 ? H : 0;
  const et = D - (W + Q), rt = U - (H + G);
  return q = w ? Q !== 0 && G !== 0 && W !== 0 && H !== 0 : Q !== 0 || G !== 0 || W !== 0 || H !== 0, q && this.crop(d, { x: W, y: G, w: et, h: rt }), d;
} }, CoverOptionsSchema = z.object({ w: z.number(), h: z.number(), align: z.number().optional(), mode: z.nativeEnum(ResizeStrategy).optional() }), methods$a = { cover(d, m) {
  const { w: g, h: w, align: I = HorizontalAlign.CENTER | VerticalAlign.MIDDLE, mode: P } = CoverOptionsSchema.parse(m), F = 7 & I, D = I >> 3;
  if ((F === 0 || F & F - 1) && (D === 0 || D & D - 1)) throw new Error("only use one flag per alignment direction");
  const U = F >> 1, Z = D >> 1, $ = g / w > d.bitmap.width / d.bitmap.height ? g / d.bitmap.width : w / d.bitmap.height;
  return d = methods$d.scale(d, { f: $, mode: P }), d = methods$b.crop(d, { x: (d.bitmap.width - g) / 2 * U, y: (d.bitmap.height - w) / 2 * Z, w: g, h: w });
} }, DisplaceOptionsSchema = z.object({ map: JimpClassSchema, offset: z.number() }), methods$9 = { displace(d, m) {
  const { map: g, offset: w } = DisplaceOptionsSchema.parse(m), I = clone(d);
  return d.scan((P, F, D) => {
    let U = g.bitmap.data[D] / 256 * w;
    U = Math.round(U);
    const Z = d.getPixelIndex(P + U, F);
    d.bitmap.data[Z] = I.bitmap.data[D], d.bitmap.data[Z + 1] = I.bitmap.data[D + 1], d.bitmap.data[Z + 2] = I.bitmap.data[D + 2];
  }), d;
} }, methods$8 = { dither(d) {
  const m = [1, 9, 3, 11, 13, 5, 15, 7, 4, 12, 2, 10, 16, 8, 14, 6];
  return d.scan((g, w, I) => {
    const P = m[((3 & w) << 2) + g % 4];
    d.bitmap.data[I] = Math.min(d.bitmap.data[I] + P, 255), d.bitmap.data[I + 1] = Math.min(d.bitmap.data[I + 1] + P, 255), d.bitmap.data[I + 2] = Math.min(d.bitmap.data[I + 2] + P, 255);
  }), d;
} }, FisheyeOptionsSchema = z.object({ radius: z.number().min(0).optional() }), methods$7 = { fisheye(d, m = {}) {
  const { radius: g = 2.5 } = FisheyeOptionsSchema.parse(m), w = clone(d), { width: I, height: P } = w.bitmap;
  return w.scan((F, D) => {
    const U = F / I, Z = D / P, $ = Math.sqrt(Math.pow(U - 0.5, 2) + Math.pow(Z - 0.5, 2)), j = 2 * Math.pow($, g), G = (U - 0.5) / $, Q = (Z - 0.5) / $, H = Math.round((j * G + 0.5) * I), W = Math.round((j * Q + 0.5) * P), q = w.getPixelColor(H, W);
    d.setPixelColor(q, F, D);
  }), d.setPixelColor(w.getPixelColor(I / 2, P / 2), I / 2, P / 2), d;
} }, FlipOptionsSchema = z.object({ horizontal: z.boolean().optional(), vertical: z.boolean().optional() }), methods$6 = { flip(d, m) {
  const { horizontal: g, vertical: w } = FlipOptionsSchema.parse(m), I = Buffer.alloc(d.bitmap.data.length);
  return d.scan((P, F, D) => {
    const U = g ? d.bitmap.width - 1 - P : P, Z = w ? d.bitmap.height - 1 - F : F, $ = d.bitmap.width * Z + U << 2, j = d.bitmap.data.readUInt32BE(D);
    I.writeUInt32BE(j, $);
  }), d.bitmap.data = Buffer.from(I), d;
} };
function Converter$1(d, m) {
  if (!(d && m && d.length && m.length)) throw new Error("Bad alphabet");
  this.srcAlphabet = d, this.dstAlphabet = m;
}
Converter$1.prototype.convert = function(d) {
  var m, g, w, I = {}, P = this.srcAlphabet.length, F = this.dstAlphabet.length, D = d.length, U = typeof d == "string" ? "" : [];
  if (!this.isValid(d)) throw new Error('Number "' + d + '" contains of non-alphabetic digits (' + this.srcAlphabet + ")");
  if (this.srcAlphabet === this.dstAlphabet) return d;
  for (m = 0; m < D; m++) I[m] = this.srcAlphabet.indexOf(d[m]);
  do {
    for (g = 0, w = 0, m = 0; m < D; m++) (g = g * P + I[m]) >= F ? (I[w++] = parseInt(g / F, 10), g %= F) : w > 0 && (I[w++] = 0);
    D = w, U = this.dstAlphabet.slice(g, g + 1).concat(U);
  } while (w !== 0);
  return U;
}, Converter$1.prototype.isValid = function(d) {
  for (var m = 0; m < d.length; ++m) if (this.srcAlphabet.indexOf(d[m]) === -1) return !1;
  return !0;
};
var converter = Converter$1, Converter = converter;
function anyBase(d, m) {
  var g = new Converter(d, m);
  return function(w) {
    return g.convert(w);
  };
}
anyBase.BIN = "01", anyBase.OCT = "01234567", anyBase.DEC = "0123456789", anyBase.HEX = "0123456789abcdef";
var anyBase_1 = anyBase, anyBase$1 = getDefaultExportFromCjs(anyBase_1), __defProp$1 = Object.defineProperty, __defNormalProp$1 = (d, m, g) => m in d ? __defProp$1(d, m, { enumerable: !0, configurable: !0, writable: !0, value: g }) : d[m] = g, __publicField$1 = (d, m, g) => __defNormalProp$1(d, typeof m != "symbol" ? m + "" : m, g);
class ImagePHash {
  constructor(m, g) {
    __publicField$1(this, "size"), __publicField$1(this, "smallerSize"), this.size = m || 32, this.smallerSize = g || 8, initCoefficients(this.size);
  }
  distance(m, g) {
    let w = 0;
    for (let I = 0; I < m.length; I++) m[I] !== g[I] && w++;
    return w / m.length;
  }
  getHash(m) {
    m = methods$d.resize(clone(m), { w: this.size, h: this.size }), m = methods$e.greyscale(m);
    const g = [];
    for (let D = 0; D < m.bitmap.width; D++) {
      const U = [];
      for (let Z = 0; Z < m.bitmap.height; Z++) U[Z] = intToRGBA(m.getPixelColor(D, Z)).b;
      g[D] = U;
    }
    const w = applyDCT(g, this.size);
    let I = 0;
    for (let D = 0; D < this.smallerSize; D++) for (let U = 0; U < this.smallerSize; U++) I += w[D][U];
    const P = I / (this.smallerSize * this.smallerSize);
    let F = "";
    for (let D = 0; D < this.smallerSize; D++) for (let U = 0; U < this.smallerSize; U++) F += w[D][U] > P ? "1" : "0";
    return F;
  }
}
function intToRGBA(d) {
  const m = 255 & d, g = 255 & (d >>>= 8), w = 255 & (d >>>= 8);
  return { r: 255 & (d >>>= 8), g: w, b: g, a: m };
}
const c$1 = [];
function initCoefficients(d) {
  for (let m = 1; m < d; m++) c$1[m] = 1;
  c$1[0] = 1 / Math.sqrt(2);
}
function applyDCT(d, m) {
  const g = m, w = [];
  for (let I = 0; I < g; I++) {
    const P = [];
    for (let F = 0; F < g; F++) {
      let D = 0;
      for (let U = 0; U < g; U++) for (let Z = 0; Z < g; Z++) D += Math.cos((2 * U + 1) / (2 * g) * I * Math.PI) * Math.cos((2 * Z + 1) / (2 * g) * F * Math.PI) * d[U][Z];
      D *= c$1[I] * c$1[F] / 4, P[F] = D, w[I] = P;
    }
  }
  return w;
}
const alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_", maxHashLength = [NaN, NaN];
for (let d = 2; d < 65; d++) {
  const m = anyBase$1(anyBase$1.BIN, alphabet.slice(0, d))(new Array(65).join("1"));
  maxHashLength.push(m.length);
}
const methods$5 = { pHash: (d) => new ImagePHash().getHash(d), hash(d, m = 64) {
  if (m < 2 || m > 64) throw new Error("base must be a number between 2 and 64");
  const g = alphabet.slice(0, m), w = this.pHash(d), I = maxHashLength[m];
  return anyBase$1(anyBase$1.BIN, g)(w).padStart(I, "0");
}, distanceFromHash(d, m) {
  const g = new ImagePHash(), w = g.getHash(d);
  return g.distance(w, m);
} }, MaskOptionsObjectSchema = z.object({ src: JimpClassSchema, x: z.number().optional(), y: z.number().optional() }), MaskOptionsSchema = z.union([JimpClassSchema, MaskOptionsObjectSchema]), methods$4 = { mask(d, m) {
  let g, w, I;
  MaskOptionsSchema.parse(m), "bitmap" in m ? (g = m, w = 0, I = 0) : (g = m.src, w = m.x ?? 0, I = m.y ?? 0), w = Math.round(w), I = Math.round(I);
  const P = d.bitmap.width, F = d.bitmap.height;
  return g.scan(function(D, U, Z) {
    const $ = w + D, j = I + U;
    if ($ >= 0 && j >= 0 && $ < P && j < F) {
      const G = d.getPixelIndex($, j), { data: Q } = g.bitmap, H = (Q[Z + 0] + Q[Z + 1] + Q[Z + 2]) / 3;
      d.bitmap.data[G + 3] *= H / 255;
    }
  }), d;
} };
function measureText(d, m) {
  let g = 0;
  for (let w = 0; w < m.length; w++) {
    const I = m[w], P = d.chars[I];
    if (P) {
      const F = d.kernings[I], D = m[w + 1], U = F && D && F[D] && F[D] || 0;
      g += (P.xadvance || 0) + U;
    }
  }
  return g;
}
function splitLines(d, m, g) {
  const w = m.replace(/[\r\n]+/g, ` 
`).split(" "), I = [];
  let P = [], F = 0;
  return w.forEach((D) => {
    if (measureText(d, D + (w.length > 1 ? " " : "")) > g) {
      const $ = D[Symbol.iterator]();
      let j = "";
      for (const G of $) {
        const Q = [...P, j + G].join(" "), H = measureText(d, Q);
        H < g ? j += G : H > g ? (I.push([...P, j]), P = [], j = G) : (I.push([...P, j + G]), P = [], j = "");
      }
      return;
    }
    const U = [...P, D].join(" "), Z = measureText(d, U);
    Z <= g && !D.includes(`
`) ? (Z > F && (F = Z), P.push(D)) : (I.push(P), P = [D.replace(`
`, "")]);
  }), I.push(P), { lines: I, longestLine: F };
}
function measureTextHeight(d, m, g) {
  const { lines: w } = splitLines(d, m, g);
  return w.length * d.common.lineHeight;
}
const PrintOptionsSchema = z.object({ x: z.number(), y: z.number(), text: z.union([z.union([z.string(), z.number()]), z.object({ text: z.union([z.string(), z.number()]), alignmentX: z.nativeEnum(HorizontalAlign).optional(), alignmentY: z.nativeEnum(VerticalAlign).optional() })]), maxWidth: z.number().optional(), maxHeight: z.number().optional(), cb: z.function(z.tuple([z.object({ x: z.number(), y: z.number() })])).optional() });
function xOffsetBasedOnAlignment(d, m, g, w) {
  return w === HorizontalAlign.LEFT ? 0 : w === HorizontalAlign.CENTER ? (g - measureText(d, m)) / 2 : g - measureText(d, m);
}
function drawCharacter(d, m, g, w, I) {
  if (I.width > 0 && I.height > 0) {
    const P = m.pages[I.page];
    P && (d = methods$h.blit(d, { src: P, x: g + I.xoffset, y: w + I.yoffset, srcX: I.x, srcY: I.y, srcW: I.width, srcH: I.height }));
  }
  return d;
}
function printText(d, m, g, w, I, P) {
  for (let F = 0; F < I.length; F++) {
    const D = I[F];
    let U;
    U = m.chars[D] ? D : /\s/.test(D) ? "" : "?";
    const Z = m.chars[U] || { xadvance: void 0 }, $ = m.kernings[U];
    Z && drawCharacter(d, m, g, w, Z);
    const j = I[F + 1];
    g += ($ && j && $[j] && $[j] || 0) + (Z.xadvance || P);
  }
}
const methods$3 = { print(d, { font: m, ...g }) {
  var H;
  let w, I, { x: P, y: F, text: D, maxWidth: U = 1 / 0, maxHeight: Z = 1 / 0, cb: $ = () => {
  } } = PrintOptionsSchema.parse(g);
  typeof D == "object" && D.text !== null && D.text !== void 0 ? (w = D.alignmentX || HorizontalAlign.LEFT, I = D.alignmentY || VerticalAlign.TOP, { text: D } = D) : (w = HorizontalAlign.LEFT, I = VerticalAlign.TOP, D = D.toString()), typeof D == "number" && (D = D.toString()), Z !== 1 / 0 && I === VerticalAlign.BOTTOM ? F += Z - measureTextHeight(m, D, U) : Z !== 1 / 0 && I === VerticalAlign.MIDDLE && (F += Z / 2 - measureTextHeight(m, D, U) / 2);
  const j = (H = Object.entries(m.chars).find((W) => W[1].xadvance)) == null ? void 0 : H[1].xadvance;
  if (typeof j != "number") throw new Error("Could not find default character width");
  const { lines: G, longestLine: Q } = splitLines(m, D, U);
  return G.forEach((W) => {
    const q = W.join(" "), et = xOffsetBasedOnAlignment(m, q, U, w);
    printText(d, m, P + et, F, q, j), F += m.common.lineHeight;
  }), $.bind(d)({ x: P + Q, y: F }), d;
} }, RotateOptionsSchema = z.union([z.number(), z.object({ deg: z.number(), mode: z.union([z.boolean(), z.nativeEnum(ResizeStrategy)]).optional() })]);
function createIdxTranslationFunction(d) {
  return function(m, g) {
    return g * d + m << 2;
  };
}
function matrixRotate(d, m) {
  if (Math.abs(m) % 90 != 0) throw new Error("Unsupported matrix rotation degree");
  const g = d.bitmap.width, w = d.bitmap.height;
  let I;
  switch (m) {
    case 90:
    case -270:
      I = 90;
      break;
    case 180:
    case -180:
      I = 180;
      break;
    case 270:
    case -90:
      I = -90;
      break;
    default:
      throw new Error("Unsupported matrix rotation degree");
  }
  const P = I === 180 ? g : w, F = I === 180 ? w : g, D = Buffer.alloc(d.bitmap.data.length), U = createIdxTranslationFunction(g), Z = createIdxTranslationFunction(P);
  for (let $ = 0; $ < g; $++) for (let j = 0; j < w; j++) {
    const G = U($, j), Q = d.bitmap.data.readUInt32BE(G);
    let H;
    switch (I) {
      case 90:
        H = Z(j, g - $ - 1);
        break;
      case -90:
        H = Z(w - j - 1, $);
        break;
      case 180:
        H = Z(g - $ - 1, w - j - 1);
        break;
      default:
        throw new Error("Unsupported matrix rotation angle");
    }
    D.writeUInt32BE(Q, H);
  }
  d.bitmap.data = D, d.bitmap.width = P, d.bitmap.height = F;
}
function createTranslationFunction(d, m) {
  return function(g, w) {
    return { x: g + d, y: w + m };
  };
}
function advancedRotate(d, m, g) {
  const w = m * Math.PI / 180, I = Math.cos(w), P = Math.sin(w);
  let F = d.bitmap.width, D = d.bitmap.height;
  if (g === !0 || typeof g == "string") {
    F = Math.ceil(Math.abs(d.bitmap.width * I) + Math.abs(d.bitmap.height * P)) + 1, D = Math.ceil(Math.abs(d.bitmap.width * P) + Math.abs(d.bitmap.height * I)) + 1, F % 2 != 0 && F++, D % 2 != 0 && D++;
    const Q = clone(d);
    d.scan((W, q, et) => {
      d.bitmap.data.writeUInt32BE(d.background, et);
    });
    const H = Math.max(F, D, d.bitmap.width, d.bitmap.height);
    d = composite(d = methods$d.resize(d, { h: H, w: H, mode: g === !0 ? void 0 : g }), Q, d.bitmap.width / 2 - Q.bitmap.width / 2, d.bitmap.height / 2 - Q.bitmap.height / 2);
  }
  const U = d.bitmap.width, Z = d.bitmap.height, $ = Buffer.alloc(d.bitmap.data.length), j = createTranslationFunction(-U / 2, -Z / 2), G = createTranslationFunction(U / 2 + 0.5, Z / 2 + 0.5);
  for (let Q = 1; Q <= Z; Q++) for (let H = 1; H <= U; H++) {
    const W = j(H, Q), q = G(I * W.x - P * W.y, I * W.y + P * W.x), et = U * (Q - 1) + H - 1 << 2;
    if (q.x >= 0 && q.x < U && q.y >= 0 && q.y < Z) {
      const rt = U * (0 | q.y) + q.x << 2, tt = d.bitmap.data.readUInt32BE(rt);
      $.writeUInt32BE(tt, et);
    } else $.writeUInt32BE(d.background, et);
  }
  if (d.bitmap.data = $, g === !0 || typeof g == "string") {
    const Q = Math.max(U / 2 - F / 2, 0), H = Math.max(Z / 2 - D / 2, 0);
    d = methods$b.crop(d, { x: Q, y: H, w: F, h: D });
  }
}
const methods$2 = { rotate(d, m) {
  const g = RotateOptionsSchema.parse(m), w = typeof g == "number" ? { deg: g } : g, { mode: I = !0 } = w;
  let { deg: P } = w;
  return P %= 360, P % 360 == 0 || (P % 90 == 0 && (I || d.bitmap.width === d.bitmap.height || P % 180 == 0) ? matrixRotate(d, P) : advancedRotate(d, P, I)), d;
} }, ThresholdOptionsSchema = z.object({ max: z.number().min(0).max(255), replace: z.number().min(0).max(255).optional(), autoGreyscale: z.boolean().optional() }), methods$1 = { threshold(d, m) {
  let { max: g, replace: w = 255, autoGreyscale: I = !0 } = ThresholdOptionsSchema.parse(m);
  return g = limit255(g), w = limit255(w), I && methods$e.greyscale(d), d.scan((P, F, D) => {
    const U = d.bitmap.data[D] < g ? d.bitmap.data[D] : w;
    d.bitmap.data[D] = U, d.bitmap.data[D + 1] = U, d.bitmap.data[D + 2] = U;
  }), d;
} };
var __defProp = Object.defineProperty, __defNormalProp = (d, m, g) => m in d ? __defProp(d, m, { enumerable: !0, configurable: !0, writable: !0, value: g }) : d[m] = g, __export = (d, m) => {
  for (var g in m) __defProp(d, g, { get: m[g], enumerable: !0 });
}, __publicField = (d, m, g) => (__defNormalProp(d, typeof m != "symbol" ? m + "" : m, g), g), constants_exports = {};
__export(constants_exports, { bt709: () => bt709_exports });
var bt709_exports = {};
__export(bt709_exports, { Y: () => Y, x: () => x$1, y: () => y$1 });
var Y = ((d) => (d[d.RED = 0.2126] = "RED", d[d.GREEN = 0.7152] = "GREEN", d[d.BLUE = 0.0722] = "BLUE", d[d.WHITE = 1] = "WHITE", d))(Y || {}), x$1 = ((d) => (d[d.RED = 0.64] = "RED", d[d.GREEN = 0.3] = "GREEN", d[d.BLUE = 0.15] = "BLUE", d[d.WHITE = 0.3127] = "WHITE", d))(x$1 || {}), y$1 = ((d) => (d[d.RED = 0.33] = "RED", d[d.GREEN = 0.6] = "GREEN", d[d.BLUE = 0.06] = "BLUE", d[d.WHITE = 0.329] = "WHITE", d))(y$1 || {}), conversion_exports = {};
function correctGamma(d) {
  return d > 0.04045 ? ((d + 0.055) / 1.055) ** 2.4 : d / 12.92;
}
function rgb2xyz(d, m, g) {
  return { x: 0.4124 * (d = correctGamma(d / 255)) + 0.3576 * (m = correctGamma(m / 255)) + 0.1805 * (g = correctGamma(g / 255)), y: 0.2126 * d + 0.7152 * m + 0.0722 * g, z: 0.0193 * d + 0.1192 * m + 0.9505 * g };
}
__export(conversion_exports, { lab2rgb: () => lab2rgb, lab2xyz: () => lab2xyz, rgb2hsl: () => rgb2hsl, rgb2lab: () => rgb2lab, rgb2xyz: () => rgb2xyz, xyz2lab: () => xyz2lab, xyz2rgb: () => xyz2rgb });
var arithmetic_exports = {};
function degrees2radians(d) {
  return d * (Math.PI / 180);
}
function max3(d, m, g) {
  let w = d;
  return w < m && (w = m), w < g && (w = g), w;
}
function min3(d, m, g) {
  let w = d;
  return w > m && (w = m), w > g && (w = g), w;
}
function intInRange(d, m, g) {
  return d > g && (d = g), d < m && (d = m), 0 | d;
}
function inRange0to255Rounded(d) {
  return (d = Math.round(d)) > 255 ? d = 255 : d < 0 && (d = 0), d;
}
function inRange0to255(d) {
  return d > 255 ? d = 255 : d < 0 && (d = 0), d;
}
function stableSort(d, m) {
  const g = typeof d[0];
  let w;
  if (g === "number" || g === "string") {
    const I = /* @__PURE__ */ Object.create(null);
    for (let P = 0, F = d.length; P < F; P++) {
      const D = d[P];
      I[D] || I[D] === 0 || (I[D] = P);
    }
    w = d.sort((P, F) => m(P, F) || I[P] - I[F]);
  } else {
    const I = d.slice(0);
    w = d.sort((P, F) => m(P, F) || I.indexOf(P) - I.indexOf(F));
  }
  return w;
}
function rgb2hsl(d, m, g) {
  const w = min3(d, m, g), I = max3(d, m, g), P = I - w, F = (w + I) / 510;
  let D = 0;
  F > 0 && F < 1 && (D = P / (F < 0.5 ? I + w : 510 - I - w));
  let U = 0;
  return P > 0 && (U = I === d ? (m - g) / P : I === m ? 2 + (g - d) / P : 4 + (d - m) / P, U *= 60, U < 0 && (U += 360)), { h: U, s: D, l: F };
}
__export(arithmetic_exports, { degrees2radians: () => degrees2radians, inRange0to255: () => inRange0to255, inRange0to255Rounded: () => inRange0to255Rounded, intInRange: () => intInRange, max3: () => max3, min3: () => min3, stableSort: () => stableSort });
var refX = 0.95047, refY = 1, refZ = 1.08883;
function pivot(d) {
  return d > 8856e-6 ? d ** (1 / 3) : 7.787 * d + 16 / 116;
}
function xyz2lab(d, m, g) {
  if (d = pivot(d / refX), m = pivot(m / refY), g = pivot(g / refZ), 116 * m - 16 < 0) throw new Error("xxx");
  return { L: Math.max(0, 116 * m - 16), a: 500 * (d - m), b: 200 * (m - g) };
}
function rgb2lab(d, m, g) {
  const w = rgb2xyz(d, m, g);
  return xyz2lab(w.x, w.y, w.z);
}
var refX2 = 0.95047, refY2 = 1, refZ2 = 1.08883;
function pivot2(d) {
  return d > 0.206893034 ? d ** 3 : (d - 16 / 116) / 7.787;
}
function lab2xyz(d, m, g) {
  const w = (d + 16) / 116, I = w - g / 200;
  return { x: refX2 * pivot2(m / 500 + w), y: refY2 * pivot2(w), z: refZ2 * pivot2(I) };
}
function correctGamma2(d) {
  return d > 31308e-7 ? 1.055 * d ** (1 / 2.4) - 0.055 : 12.92 * d;
}
function xyz2rgb(d, m, g) {
  const w = correctGamma2(3.2406 * d + -1.5372 * m + -0.4986 * g), I = correctGamma2(-0.9689 * d + 1.8758 * m + 0.0415 * g), P = correctGamma2(0.0557 * d + -0.204 * m + 1.057 * g);
  return { r: inRange0to255Rounded(255 * w), g: inRange0to255Rounded(255 * I), b: inRange0to255Rounded(255 * P) };
}
function lab2rgb(d, m, g) {
  const w = lab2xyz(d, m, g);
  return xyz2rgb(w.x, w.y, w.z);
}
var distance_exports = {};
__export(distance_exports, { AbstractDistanceCalculator: () => AbstractDistanceCalculator, AbstractEuclidean: () => AbstractEuclidean, AbstractManhattan: () => AbstractManhattan, CIE94GraphicArts: () => CIE94GraphicArts, CIE94Textiles: () => CIE94Textiles, CIEDE2000: () => CIEDE2000, CMetric: () => CMetric, Euclidean: () => Euclidean, EuclideanBT709: () => EuclideanBT709, EuclideanBT709NoAlpha: () => EuclideanBT709NoAlpha, Manhattan: () => Manhattan, ManhattanBT709: () => ManhattanBT709, ManhattanNommyde: () => ManhattanNommyde, PNGQuant: () => PNGQuant });
var AbstractDistanceCalculator = class {
  constructor() {
    __publicField(this, "_maxDistance"), __publicField(this, "_whitePoint"), this._setDefaults(), this.setWhitePoint(255, 255, 255, 255);
  }
  setWhitePoint(d, m, g, w) {
    this._whitePoint = { r: d > 0 ? 255 / d : 0, g: m > 0 ? 255 / m : 0, b: g > 0 ? 255 / g : 0, a: w > 0 ? 255 / w : 0 }, this._maxDistance = this.calculateRaw(d, m, g, w, 0, 0, 0, 0);
  }
  calculateNormalized(d, m) {
    return this.calculateRaw(d.r, d.g, d.b, d.a, m.r, m.g, m.b, m.a) / this._maxDistance;
  }
}, AbstractCIE94 = class extends AbstractDistanceCalculator {
  calculateRaw(d, m, g, w, I, P, F, D) {
    const U = rgb2lab(inRange0to255(d * this._whitePoint.r), inRange0to255(m * this._whitePoint.g), inRange0to255(g * this._whitePoint.b)), Z = rgb2lab(inRange0to255(I * this._whitePoint.r), inRange0to255(P * this._whitePoint.g), inRange0to255(F * this._whitePoint.b)), $ = U.L - Z.L, j = U.a - Z.a, G = U.b - Z.b, Q = Math.sqrt(U.a * U.a + U.b * U.b), H = Q - Math.sqrt(Z.a * Z.a + Z.b * Z.b);
    let W = j * j + G * G - H * H;
    W = W < 0 ? 0 : Math.sqrt(W);
    const q = (D - w) * this._whitePoint.a * this._kA;
    return Math.sqrt(($ / this._Kl) ** 2 + (H / (1 + this._K1 * Q)) ** 2 + (W / (1 + this._K2 * Q)) ** 2 + q ** 2);
  }
}, CIE94Textiles = class extends AbstractCIE94 {
  _setDefaults() {
    this._Kl = 2, this._K1 = 0.048, this._K2 = 0.014, this._kA = 12.5 / 255;
  }
}, CIE94GraphicArts = class extends AbstractCIE94 {
  _setDefaults() {
    this._Kl = 1, this._K1 = 0.045, this._K2 = 0.015, this._kA = 25 / 255;
  }
}, _CIEDE2000 = class extends AbstractDistanceCalculator {
  _setDefaults() {
  }
  static _calculatehp(d, m) {
    const g = Math.atan2(d, m);
    return g >= 0 ? g : g + _CIEDE2000._deg360InRad;
  }
  static _calculateRT(d, m) {
    const g = m ** 7, w = 2 * Math.sqrt(g / (g + _CIEDE2000._pow25to7)), I = _CIEDE2000._deg30InRad * Math.exp(-(((d - _CIEDE2000._deg275InRad) / _CIEDE2000._deg25InRad) ** 2));
    return -Math.sin(2 * I) * w;
  }
  static _calculateT(d) {
    return 1 - 0.17 * Math.cos(d - _CIEDE2000._deg30InRad) + 0.24 * Math.cos(2 * d) + 0.32 * Math.cos(3 * d + _CIEDE2000._deg6InRad) - 0.2 * Math.cos(4 * d - _CIEDE2000._deg63InRad);
  }
  static _calculate_ahp(d, m, g, w) {
    const I = g + w;
    return d === 0 ? I : m <= _CIEDE2000._deg180InRad ? I / 2 : I < _CIEDE2000._deg360InRad ? (I + _CIEDE2000._deg360InRad) / 2 : (I - _CIEDE2000._deg360InRad) / 2;
  }
  static _calculate_dHp(d, m, g, w) {
    let I;
    return I = d === 0 ? 0 : m <= _CIEDE2000._deg180InRad ? g - w : g <= w ? g - w + _CIEDE2000._deg360InRad : g - w - _CIEDE2000._deg360InRad, 2 * Math.sqrt(d) * Math.sin(I / 2);
  }
  calculateRaw(d, m, g, w, I, P, F, D) {
    const U = rgb2lab(inRange0to255(d * this._whitePoint.r), inRange0to255(m * this._whitePoint.g), inRange0to255(g * this._whitePoint.b)), Z = rgb2lab(inRange0to255(I * this._whitePoint.r), inRange0to255(P * this._whitePoint.g), inRange0to255(F * this._whitePoint.b)), $ = (D - w) * this._whitePoint.a * _CIEDE2000._kA, j = this.calculateRawInLab(U, Z);
    return Math.sqrt(j + $ * $);
  }
  calculateRawInLab(d, m) {
    const g = d.L, w = d.a, I = d.b, P = m.L, F = m.a, D = m.b, U = ((Math.sqrt(w * w + I * I) + Math.sqrt(F * F + D * D)) / 2) ** 7, Z = 0.5 * (1 - Math.sqrt(U / (U + _CIEDE2000._pow25to7))), $ = (1 + Z) * w, j = (1 + Z) * F, G = Math.sqrt($ * $ + I * I), Q = Math.sqrt(j * j + D * D), H = G * Q, W = _CIEDE2000._calculatehp(I, $), q = _CIEDE2000._calculatehp(D, j), et = Math.abs(W - q), rt = P - g, tt = Q - G, V = _CIEDE2000._calculate_dHp(H, et, q, W), X = _CIEDE2000._calculate_ahp(H, et, W, q), ot = (G + Q) / 2, it = ((g + P) / 2 - 50) ** 2, st = tt / (1 + 0.045 * ot), at = V / (1 + 0.015 * _CIEDE2000._calculateT(X) * ot);
    return (rt / (1 + 0.015 * it / Math.sqrt(20 + it))) ** 2 + st ** 2 + at ** 2 + _CIEDE2000._calculateRT(X, ot) * st * at;
  }
}, CIEDE2000 = _CIEDE2000;
__publicField(CIEDE2000, "_kA", 25 / 255), __publicField(CIEDE2000, "_pow25to7", 25 ** 7), __publicField(CIEDE2000, "_deg360InRad", degrees2radians(360)), __publicField(CIEDE2000, "_deg180InRad", degrees2radians(180)), __publicField(CIEDE2000, "_deg30InRad", degrees2radians(30)), __publicField(CIEDE2000, "_deg6InRad", degrees2radians(6)), __publicField(CIEDE2000, "_deg63InRad", degrees2radians(63)), __publicField(CIEDE2000, "_deg275InRad", degrees2radians(275)), __publicField(CIEDE2000, "_deg25InRad", degrees2radians(25));
var CMetric = class extends AbstractDistanceCalculator {
  calculateRaw(d, m, g, w, I, P, F, D) {
    const U = (d + I) / 2 * this._whitePoint.r, Z = (d - I) * this._whitePoint.r, $ = (m - P) * this._whitePoint.g, j = (g - F) * this._whitePoint.b, G = ((512 + U) * Z * Z >> 8) + 4 * $ * $ + ((767 - U) * j * j >> 8), Q = (D - w) * this._whitePoint.a;
    return Math.sqrt(G + Q * Q);
  }
  _setDefaults() {
  }
}, AbstractEuclidean = class extends AbstractDistanceCalculator {
  calculateRaw(d, m, g, w, I, P, F, D) {
    const U = I - d, Z = P - m, $ = F - g, j = D - w;
    return Math.sqrt(this._kR * U * U + this._kG * Z * Z + this._kB * $ * $ + this._kA * j * j);
  }
}, Euclidean = class extends AbstractEuclidean {
  _setDefaults() {
    this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
  }
}, EuclideanBT709 = class extends AbstractEuclidean {
  _setDefaults() {
    this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
  }
}, EuclideanBT709NoAlpha = class extends AbstractEuclidean {
  _setDefaults() {
    this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 0;
  }
}, AbstractManhattan = class extends AbstractDistanceCalculator {
  calculateRaw(d, m, g, w, I, P, F, D) {
    let U = I - d, Z = P - m, $ = F - g, j = D - w;
    return U < 0 && (U = 0 - U), Z < 0 && (Z = 0 - Z), $ < 0 && ($ = 0 - $), j < 0 && (j = 0 - j), this._kR * U + this._kG * Z + this._kB * $ + this._kA * j;
  }
}, Manhattan = class extends AbstractManhattan {
  _setDefaults() {
    this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
  }
}, ManhattanNommyde = class extends AbstractManhattan {
  _setDefaults() {
    this._kR = 0.4984, this._kG = 0.8625, this._kB = 0.2979, this._kA = 1;
  }
}, ManhattanBT709 = class extends AbstractManhattan {
  _setDefaults() {
    this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
  }
}, PNGQuant = class extends AbstractDistanceCalculator {
  calculateRaw(d, m, g, w, I, P, F, D) {
    const U = (D - w) * this._whitePoint.a;
    return this._colordifferenceCh(d * this._whitePoint.r, I * this._whitePoint.r, U) + this._colordifferenceCh(m * this._whitePoint.g, P * this._whitePoint.g, U) + this._colordifferenceCh(g * this._whitePoint.b, F * this._whitePoint.b, U);
  }
  _colordifferenceCh(d, m, g) {
    const w = d - m, I = w + g;
    return w * w + I * I;
  }
  _setDefaults() {
  }
}, palette_exports = {};
__export(palette_exports, { AbstractPaletteQuantizer: () => AbstractPaletteQuantizer, ColorHistogram: () => ColorHistogram, NeuQuant: () => NeuQuant, NeuQuantFloat: () => NeuQuantFloat, RGBQuant: () => RGBQuant, WuColorCube: () => WuColorCube, WuQuant: () => WuQuant });
var AbstractPaletteQuantizer = class {
  quantizeSync() {
    for (const d of this.quantize()) if (d.palette) return d.palette;
    throw new Error("unreachable");
  }
}, Point = class {
  constructor() {
    __publicField(this, "r"), __publicField(this, "g"), __publicField(this, "b"), __publicField(this, "a"), __publicField(this, "uint32"), __publicField(this, "rgba"), this.uint32 = -1 >>> 0, this.r = this.g = this.b = this.a = 0, this.rgba = new Array(4), this.rgba[0] = 0, this.rgba[1] = 0, this.rgba[2] = 0, this.rgba[3] = 0;
  }
  static createByQuadruplet(d) {
    const m = new Point();
    return m.r = 0 | d[0], m.g = 0 | d[1], m.b = 0 | d[2], m.a = 0 | d[3], m._loadUINT32(), m._loadQuadruplet(), m;
  }
  static createByRGBA(d, m, g, w) {
    const I = new Point();
    return I.r = 0 | d, I.g = 0 | m, I.b = 0 | g, I.a = 0 | w, I._loadUINT32(), I._loadQuadruplet(), I;
  }
  static createByUint32(d) {
    const m = new Point();
    return m.uint32 = d >>> 0, m._loadRGBA(), m._loadQuadruplet(), m;
  }
  from(d) {
    this.r = d.r, this.g = d.g, this.b = d.b, this.a = d.a, this.uint32 = d.uint32, this.rgba[0] = d.r, this.rgba[1] = d.g, this.rgba[2] = d.b, this.rgba[3] = d.a;
  }
  getLuminosity(d) {
    let m = this.r, g = this.g, w = this.b;
    return d && (m = Math.min(255, 255 - this.a + this.a * m / 255), g = Math.min(255, 255 - this.a + this.a * g / 255), w = Math.min(255, 255 - this.a + this.a * w / 255)), 0.2126 * m + 0.7152 * g + 0.0722 * w;
  }
  _loadUINT32() {
    this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
  }
  _loadRGBA() {
    this.r = 255 & this.uint32, this.g = this.uint32 >>> 8 & 255, this.b = this.uint32 >>> 16 & 255, this.a = this.uint32 >>> 24 & 255;
  }
  _loadQuadruplet() {
    this.rgba[0] = this.r, this.rgba[1] = this.g, this.rgba[2] = this.b, this.rgba[3] = this.a;
  }
}, PointContainer = class {
  constructor() {
    __publicField(this, "_pointArray"), __publicField(this, "_width"), __publicField(this, "_height"), this._width = 0, this._height = 0, this._pointArray = [];
  }
  getWidth() {
    return this._width;
  }
  getHeight() {
    return this._height;
  }
  setWidth(d) {
    this._width = d;
  }
  setHeight(d) {
    this._height = d;
  }
  getPointArray() {
    return this._pointArray;
  }
  clone() {
    const d = new PointContainer();
    d._width = this._width, d._height = this._height;
    for (let m = 0, g = this._pointArray.length; m < g; m++) d._pointArray[m] = Point.createByUint32(0 | this._pointArray[m].uint32);
    return d;
  }
  toUint32Array() {
    const d = this._pointArray.length, m = new Uint32Array(d);
    for (let g = 0; g < d; g++) m[g] = this._pointArray[g].uint32;
    return m;
  }
  toUint8Array() {
    return new Uint8Array(this.toUint32Array().buffer);
  }
  static fromHTMLImageElement(d) {
    const m = d.naturalWidth, g = d.naturalHeight, w = document.createElement("canvas");
    return w.width = m, w.height = g, w.getContext("2d").drawImage(d, 0, 0, m, g, 0, 0, m, g), PointContainer.fromHTMLCanvasElement(w);
  }
  static fromHTMLCanvasElement(d) {
    const m = d.width, g = d.height, w = d.getContext("2d").getImageData(0, 0, m, g);
    return PointContainer.fromImageData(w);
  }
  static fromImageData(d) {
    const m = d.width, g = d.height;
    return PointContainer.fromUint8Array(d.data, m, g);
  }
  static fromUint8Array(d, m, g) {
    switch (Object.prototype.toString.call(d)) {
      case "[object Uint8ClampedArray]":
      case "[object Uint8Array]":
        break;
      default:
        d = new Uint8Array(d);
    }
    const w = new Uint32Array(d.buffer);
    return PointContainer.fromUint32Array(w, m, g);
  }
  static fromUint32Array(d, m, g) {
    const w = new PointContainer();
    w._width = m, w._height = g;
    for (let I = 0, P = d.length; I < P; I++) w._pointArray[I] = Point.createByUint32(0 | d[I]);
    return w;
  }
  static fromBuffer(d, m, g) {
    const w = new Uint32Array(d.buffer, d.byteOffset, d.byteLength / Uint32Array.BYTES_PER_ELEMENT);
    return PointContainer.fromUint32Array(w, m, g);
  }
}, hueGroups = 10;
function hueGroup(d, m) {
  const g = 360 / m;
  for (let w = 1, I = g - g / 2; w < m; w++, I += g) if (d >= I && d < I + g) return w;
  return 0;
}
var Palette = class {
  constructor() {
    __publicField(this, "_pointContainer"), __publicField(this, "_pointArray", []), __publicField(this, "_i32idx", {}), this._pointContainer = new PointContainer(), this._pointContainer.setHeight(1), this._pointArray = this._pointContainer.getPointArray();
  }
  add(d) {
    this._pointArray.push(d), this._pointContainer.setWidth(this._pointArray.length);
  }
  has(d) {
    for (let m = this._pointArray.length - 1; m >= 0; m--) if (d.uint32 === this._pointArray[m].uint32) return !0;
    return !1;
  }
  getNearestColor(d, m) {
    return this._pointArray[0 | this._getNearestIndex(d, m)];
  }
  getPointContainer() {
    return this._pointContainer;
  }
  _nearestPointFromCache(d) {
    return typeof this._i32idx[d] == "number" ? this._i32idx[d] : -1;
  }
  _getNearestIndex(d, m) {
    let g = this._nearestPointFromCache("" + m.uint32);
    if (g >= 0) return g;
    let w = Number.MAX_VALUE;
    g = 0;
    for (let I = 0, P = this._pointArray.length; I < P; I++) {
      const F = this._pointArray[I], D = d.calculateRaw(m.r, m.g, m.b, m.a, F.r, F.g, F.b, F.a);
      D < w && (w = D, g = I);
    }
    return this._i32idx[m.uint32] = g, g;
  }
  sort() {
    this._i32idx = {}, this._pointArray.sort((d, m) => {
      const g = rgb2hsl(d.r, d.g, d.b), w = rgb2hsl(m.r, m.g, m.b), I = d.r === d.g && d.g === d.b ? 0 : 1 + hueGroup(g.h, hueGroups), P = (m.r === m.g && m.g === m.b ? 0 : 1 + hueGroup(w.h, hueGroups)) - I;
      if (P) return -P;
      const F = d.getLuminosity(!0), D = m.getLuminosity(!0);
      if (D - F != 0) return D - F;
      const U = (100 * w.s | 0) - (100 * g.s | 0);
      return U ? -U : 0;
    });
  }
}, utils_exports = {};
__export(utils_exports, { HueStatistics: () => HueStatistics, Palette: () => Palette, Point: () => Point, PointContainer: () => PointContainer, ProgressTracker: () => ProgressTracker, arithmetic: () => arithmetic_exports });
var HueGroup = class {
  constructor() {
    __publicField(this, "num", 0), __publicField(this, "cols", []);
  }
}, HueStatistics = class {
  constructor(d, m) {
    __publicField(this, "_numGroups"), __publicField(this, "_minCols"), __publicField(this, "_stats"), __publicField(this, "_groupsFull"), this._numGroups = d, this._minCols = m, this._stats = [];
    for (let g = 0; g <= d; g++) this._stats[g] = new HueGroup();
    this._groupsFull = 0;
  }
  check(d) {
    this._groupsFull === this._numGroups + 1 && (this.check = () => {
    });
    const m = 255 & d, g = d >>> 8 & 255, w = d >>> 16 & 255, I = m === g && g === w ? 0 : 1 + hueGroup(rgb2hsl(m, g, w).h, this._numGroups), P = this._stats[I], F = this._minCols;
    P.num++, P.num > F || (P.num === F && this._groupsFull++, P.num <= F && this._stats[I].cols.push(d));
  }
  injectIntoDictionary(d) {
    for (let m = 0; m <= this._numGroups; m++) this._stats[m].num <= this._minCols && this._stats[m].cols.forEach((g) => {
      d[g] ? d[g]++ : d[g] = 1;
    });
  }
  injectIntoArray(d) {
    for (let m = 0; m <= this._numGroups; m++) this._stats[m].num <= this._minCols && this._stats[m].cols.forEach((g) => {
      d.indexOf(g) === -1 && d.push(g);
    });
  }
}, _ProgressTracker = class {
  constructor(d, m) {
    __publicField(this, "progress"), __publicField(this, "_step"), __publicField(this, "_range"), __publicField(this, "_last"), __publicField(this, "_progressRange"), this._range = d, this._progressRange = m, this._step = Math.max(1, this._range / (_ProgressTracker.steps + 1) | 0), this._last = -this._step, this.progress = 0;
  }
  shouldNotify(d) {
    return d - this._last >= this._step && (this._last = d, this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange), !0);
  }
}, ProgressTracker = _ProgressTracker;
__publicField(ProgressTracker, "steps", 100);
var networkBiasShift = 3, Neuron = class {
  constructor(d) {
    __publicField(this, "r"), __publicField(this, "g"), __publicField(this, "b"), __publicField(this, "a"), this.r = this.g = this.b = this.a = d;
  }
  toPoint() {
    return Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
  }
  subtract(d, m, g, w) {
    this.r -= 0 | d, this.g -= 0 | m, this.b -= 0 | g, this.a -= 0 | w;
  }
}, _NeuQuant = class extends AbstractPaletteQuantizer {
  constructor(d, m = 256) {
    super(), __publicField(this, "_pointArray"), __publicField(this, "_networkSize"), __publicField(this, "_network"), __publicField(this, "_sampleFactor"), __publicField(this, "_radPower"), __publicField(this, "_freq"), __publicField(this, "_bias"), __publicField(this, "_distance"), this._distance = d, this._pointArray = [], this._sampleFactor = 1, this._networkSize = m, this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
  }
  sample(d) {
    this._pointArray = this._pointArray.concat(d.getPointArray());
  }
  *quantize() {
    this._init(), yield* this._learn(), yield { palette: this._buildPalette(), progress: 100 };
  }
  _init() {
    this._freq = [], this._bias = [], this._radPower = [], this._network = [];
    for (let d = 0; d < this._networkSize; d++) this._network[d] = new Neuron((d << networkBiasShift + 8) / this._networkSize | 0), this._freq[d] = _NeuQuant._initialBias / this._networkSize | 0, this._bias[d] = 0;
  }
  *_learn() {
    let d = this._sampleFactor;
    const m = this._pointArray.length;
    m < _NeuQuant._minpicturebytes && (d = 1);
    const g = 30 + (d - 1) / 3 | 0, w = m / d | 0;
    let I, P = w / _NeuQuant._nCycles | 0, F = _NeuQuant._initAlpha, D = (this._networkSize >> 3) * _NeuQuant._radiusBias, U = D >> _NeuQuant._radiusBiasShift;
    U <= 1 && (U = 0);
    for (let $ = 0; $ < U; $++) this._radPower[$] = F * ((U * U - $ * $) * _NeuQuant._radBias / (U * U)) >>> 0;
    I = m < _NeuQuant._minpicturebytes ? 1 : m % _NeuQuant._prime1 != 0 ? _NeuQuant._prime1 : m % _NeuQuant._prime2 != 0 ? _NeuQuant._prime2 : m % _NeuQuant._prime3 != 0 ? _NeuQuant._prime3 : _NeuQuant._prime4;
    const Z = new ProgressTracker(w, 99);
    for (let $ = 0, j = 0; $ < w; ) {
      Z.shouldNotify($) && (yield { progress: Z.progress });
      const G = this._pointArray[j], Q = G.b << networkBiasShift, H = G.g << networkBiasShift, W = G.r << networkBiasShift, q = G.a << networkBiasShift, et = this._contest(Q, H, W, q);
      if (this._alterSingle(F, et, Q, H, W, q), U !== 0 && this._alterNeighbour(U, et, Q, H, W, q), j += I, j >= m && (j -= m), $++, P === 0 && (P = 1), $ % P == 0) {
        F -= F / g | 0, D -= D / _NeuQuant._radiusDecrease | 0, U = D >> _NeuQuant._radiusBiasShift, U <= 1 && (U = 0);
        for (let rt = 0; rt < U; rt++) this._radPower[rt] = F * ((U * U - rt * rt) * _NeuQuant._radBias / (U * U)) >>> 0;
      }
    }
  }
  _buildPalette() {
    const d = new Palette();
    return this._network.forEach((m) => {
      d.add(m.toPoint());
    }), d.sort(), d;
  }
  _alterNeighbour(d, m, g, w, I, P) {
    let F = m - d;
    F < -1 && (F = -1);
    let D = m + d;
    D > this._networkSize && (D = this._networkSize);
    let U = m + 1, Z = m - 1, $ = 1;
    for (; U < D || Z > F; ) {
      const j = this._radPower[$++] / _NeuQuant._alphaRadBias;
      if (U < D) {
        const G = this._network[U++];
        G.subtract(j * (G.r - I), j * (G.g - w), j * (G.b - g), j * (G.a - P));
      }
      if (Z > F) {
        const G = this._network[Z--];
        G.subtract(j * (G.r - I), j * (G.g - w), j * (G.b - g), j * (G.a - P));
      }
    }
  }
  _alterSingle(d, m, g, w, I, P) {
    d /= _NeuQuant._initAlpha;
    const F = this._network[m];
    F.subtract(d * (F.r - I), d * (F.g - w), d * (F.b - g), d * (F.a - P));
  }
  _contest(d, m, g, w) {
    const I = 1020 << networkBiasShift;
    let P = 2147483647, F = P, D = -1, U = D;
    for (let Z = 0; Z < this._networkSize; Z++) {
      const $ = this._network[Z], j = this._distance.calculateNormalized($, { r: g, g: m, b: d, a: w }) * I | 0;
      j < P && (P = j, D = Z);
      const G = j - (this._bias[Z] >> _NeuQuant._initialBiasShift - networkBiasShift);
      G < F && (F = G, U = Z);
      const Q = this._freq[Z] >> _NeuQuant._betaShift;
      this._freq[Z] -= Q, this._bias[Z] += Q << _NeuQuant._gammaShift;
    }
    return this._freq[D] += _NeuQuant._beta, this._bias[D] -= _NeuQuant._betaGamma, U;
  }
}, NeuQuant = _NeuQuant;
__publicField(NeuQuant, "_prime1", 499), __publicField(NeuQuant, "_prime2", 491), __publicField(NeuQuant, "_prime3", 487), __publicField(NeuQuant, "_prime4", 503), __publicField(NeuQuant, "_minpicturebytes", _NeuQuant._prime4), __publicField(NeuQuant, "_nCycles", 100), __publicField(NeuQuant, "_initialBiasShift", 16), __publicField(NeuQuant, "_initialBias", 1 << _NeuQuant._initialBiasShift), __publicField(NeuQuant, "_gammaShift", 10), __publicField(NeuQuant, "_betaShift", 10), __publicField(NeuQuant, "_beta", _NeuQuant._initialBias >> _NeuQuant._betaShift), __publicField(NeuQuant, "_betaGamma", _NeuQuant._initialBias << _NeuQuant._gammaShift - _NeuQuant._betaShift), __publicField(NeuQuant, "_radiusBiasShift", 6), __publicField(NeuQuant, "_radiusBias", 1 << _NeuQuant._radiusBiasShift), __publicField(NeuQuant, "_radiusDecrease", 30), __publicField(NeuQuant, "_alphaBiasShift", 10), __publicField(NeuQuant, "_initAlpha", 1 << _NeuQuant._alphaBiasShift), __publicField(NeuQuant, "_radBiasShift", 8), __publicField(NeuQuant, "_radBias", 1 << _NeuQuant._radBiasShift), __publicField(NeuQuant, "_alphaRadBiasShift", _NeuQuant._alphaBiasShift + _NeuQuant._radBiasShift), __publicField(NeuQuant, "_alphaRadBias", 1 << _NeuQuant._alphaRadBiasShift);
var networkBiasShift2 = 3, NeuronFloat = class {
  constructor(d) {
    __publicField(this, "r"), __publicField(this, "g"), __publicField(this, "b"), __publicField(this, "a"), this.r = this.g = this.b = this.a = d;
  }
  toPoint() {
    return Point.createByRGBA(this.r >> networkBiasShift2, this.g >> networkBiasShift2, this.b >> networkBiasShift2, this.a >> networkBiasShift2);
  }
  subtract(d, m, g, w) {
    this.r -= d, this.g -= m, this.b -= g, this.a -= w;
  }
}, _NeuQuantFloat = class extends AbstractPaletteQuantizer {
  constructor(d, m = 256) {
    super(), __publicField(this, "_pointArray"), __publicField(this, "_networkSize"), __publicField(this, "_network"), __publicField(this, "_sampleFactor"), __publicField(this, "_radPower"), __publicField(this, "_freq"), __publicField(this, "_bias"), __publicField(this, "_distance"), this._distance = d, this._pointArray = [], this._sampleFactor = 1, this._networkSize = m, this._distance.setWhitePoint(255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2);
  }
  sample(d) {
    this._pointArray = this._pointArray.concat(d.getPointArray());
  }
  *quantize() {
    this._init(), yield* this._learn(), yield { palette: this._buildPalette(), progress: 100 };
  }
  _init() {
    this._freq = [], this._bias = [], this._radPower = [], this._network = [];
    for (let d = 0; d < this._networkSize; d++) this._network[d] = new NeuronFloat((d << networkBiasShift2 + 8) / this._networkSize), this._freq[d] = _NeuQuantFloat._initialBias / this._networkSize, this._bias[d] = 0;
  }
  *_learn() {
    let d = this._sampleFactor;
    const m = this._pointArray.length;
    m < _NeuQuantFloat._minpicturebytes && (d = 1);
    const g = 30 + (d - 1) / 3, w = m / d;
    let I, P = w / _NeuQuantFloat._nCycles | 0, F = _NeuQuantFloat._initAlpha, D = (this._networkSize >> 3) * _NeuQuantFloat._radiusBias, U = D >> _NeuQuantFloat._radiusBiasShift;
    U <= 1 && (U = 0);
    for (let $ = 0; $ < U; $++) this._radPower[$] = F * ((U * U - $ * $) * _NeuQuantFloat._radBias / (U * U));
    I = m < _NeuQuantFloat._minpicturebytes ? 1 : m % _NeuQuantFloat._prime1 != 0 ? _NeuQuantFloat._prime1 : m % _NeuQuantFloat._prime2 != 0 ? _NeuQuantFloat._prime2 : m % _NeuQuantFloat._prime3 != 0 ? _NeuQuantFloat._prime3 : _NeuQuantFloat._prime4;
    const Z = new ProgressTracker(w, 99);
    for (let $ = 0, j = 0; $ < w; ) {
      Z.shouldNotify($) && (yield { progress: Z.progress });
      const G = this._pointArray[j], Q = G.b << networkBiasShift2, H = G.g << networkBiasShift2, W = G.r << networkBiasShift2, q = G.a << networkBiasShift2, et = this._contest(Q, H, W, q);
      if (this._alterSingle(F, et, Q, H, W, q), U !== 0 && this._alterNeighbour(U, et, Q, H, W, q), j += I, j >= m && (j -= m), $++, P === 0 && (P = 1), $ % P == 0) {
        F -= F / g, D -= D / _NeuQuantFloat._radiusDecrease, U = D >> _NeuQuantFloat._radiusBiasShift, U <= 1 && (U = 0);
        for (let rt = 0; rt < U; rt++) this._radPower[rt] = F * ((U * U - rt * rt) * _NeuQuantFloat._radBias / (U * U));
      }
    }
  }
  _buildPalette() {
    const d = new Palette();
    return this._network.forEach((m) => {
      d.add(m.toPoint());
    }), d.sort(), d;
  }
  _alterNeighbour(d, m, g, w, I, P) {
    let F = m - d;
    F < -1 && (F = -1);
    let D = m + d;
    D > this._networkSize && (D = this._networkSize);
    let U = m + 1, Z = m - 1, $ = 1;
    for (; U < D || Z > F; ) {
      const j = this._radPower[$++] / _NeuQuantFloat._alphaRadBias;
      if (U < D) {
        const G = this._network[U++];
        G.subtract(j * (G.r - I), j * (G.g - w), j * (G.b - g), j * (G.a - P));
      }
      if (Z > F) {
        const G = this._network[Z--];
        G.subtract(j * (G.r - I), j * (G.g - w), j * (G.b - g), j * (G.a - P));
      }
    }
  }
  _alterSingle(d, m, g, w, I, P) {
    d /= _NeuQuantFloat._initAlpha;
    const F = this._network[m];
    F.subtract(d * (F.r - I), d * (F.g - w), d * (F.b - g), d * (F.a - P));
  }
  _contest(d, m, g, w) {
    const I = 1020 << networkBiasShift2;
    let P = 2147483647, F = P, D = -1, U = D;
    for (let Z = 0; Z < this._networkSize; Z++) {
      const $ = this._network[Z], j = this._distance.calculateNormalized($, { r: g, g: m, b: d, a: w }) * I;
      j < P && (P = j, D = Z);
      const G = j - (this._bias[Z] >> _NeuQuantFloat._initialBiasShift - networkBiasShift2);
      G < F && (F = G, U = Z);
      const Q = this._freq[Z] >> _NeuQuantFloat._betaShift;
      this._freq[Z] -= Q, this._bias[Z] += Q << _NeuQuantFloat._gammaShift;
    }
    return this._freq[D] += _NeuQuantFloat._beta, this._bias[D] -= _NeuQuantFloat._betaGamma, U;
  }
}, NeuQuantFloat = _NeuQuantFloat;
__publicField(NeuQuantFloat, "_prime1", 499), __publicField(NeuQuantFloat, "_prime2", 491), __publicField(NeuQuantFloat, "_prime3", 487), __publicField(NeuQuantFloat, "_prime4", 503), __publicField(NeuQuantFloat, "_minpicturebytes", _NeuQuantFloat._prime4), __publicField(NeuQuantFloat, "_nCycles", 100), __publicField(NeuQuantFloat, "_initialBiasShift", 16), __publicField(NeuQuantFloat, "_initialBias", 1 << _NeuQuantFloat._initialBiasShift), __publicField(NeuQuantFloat, "_gammaShift", 10), __publicField(NeuQuantFloat, "_betaShift", 10), __publicField(NeuQuantFloat, "_beta", _NeuQuantFloat._initialBias >> _NeuQuantFloat._betaShift), __publicField(NeuQuantFloat, "_betaGamma", _NeuQuantFloat._initialBias << _NeuQuantFloat._gammaShift - _NeuQuantFloat._betaShift), __publicField(NeuQuantFloat, "_radiusBiasShift", 6), __publicField(NeuQuantFloat, "_radiusBias", 1 << _NeuQuantFloat._radiusBiasShift), __publicField(NeuQuantFloat, "_radiusDecrease", 30), __publicField(NeuQuantFloat, "_alphaBiasShift", 10), __publicField(NeuQuantFloat, "_initAlpha", 1 << _NeuQuantFloat._alphaBiasShift), __publicField(NeuQuantFloat, "_radBiasShift", 8), __publicField(NeuQuantFloat, "_radBias", 1 << _NeuQuantFloat._radBiasShift), __publicField(NeuQuantFloat, "_alphaRadBiasShift", _NeuQuantFloat._alphaBiasShift + _NeuQuantFloat._radBiasShift), __publicField(NeuQuantFloat, "_alphaRadBias", 1 << _NeuQuantFloat._alphaRadBiasShift);
var _ColorHistogram = class {
  constructor(d, m) {
    __publicField(this, "_method"), __publicField(this, "_hueStats"), __publicField(this, "_histogram"), __publicField(this, "_initColors"), __publicField(this, "_minHueCols"), this._method = d, this._minHueCols = m << 2, this._initColors = m << 2, this._hueStats = new HueStatistics(_ColorHistogram._hueGroups, this._minHueCols), this._histogram = /* @__PURE__ */ Object.create(null);
  }
  sample(d) {
    switch (this._method) {
      case 1:
        this._colorStats1D(d);
        break;
      case 2:
        this._colorStats2D(d);
    }
  }
  getImportanceSortedColorsIDXI32() {
    const d = stableSort(Object.keys(this._histogram), (g, w) => this._histogram[w] - this._histogram[g]);
    if (d.length === 0) return [];
    let m;
    switch (this._method) {
      case 1:
        const g = Math.min(d.length, this._initColors), w = d[g - 1], I = this._histogram[w];
        m = d.slice(0, g);
        let P = g;
        const F = d.length;
        for (; P < F && this._histogram[d[P]] === I; ) m.push(d[P++]);
        this._hueStats.injectIntoArray(m);
        break;
      case 2:
        m = d;
        break;
      default:
        throw new Error("Incorrect method");
    }
    return m.map((g) => +g);
  }
  _colorStats1D(d) {
    const m = this._histogram, g = d.getPointArray(), w = g.length;
    for (let I = 0; I < w; I++) {
      const P = g[I].uint32;
      this._hueStats.check(P), P in m ? m[P]++ : m[P] = 1;
    }
  }
  _colorStats2D(d) {
    const m = d.getWidth(), g = d.getHeight(), w = d.getPointArray(), I = _ColorHistogram._boxSize[0], P = _ColorHistogram._boxSize[1], F = I * P, D = this._makeBoxes(m, g, I, P), U = this._histogram;
    D.forEach((Z) => {
      let $ = Math.round(Z.w * Z.h / F) * _ColorHistogram._boxPixels;
      $ < 2 && ($ = 2);
      const j = {};
      this._iterateBox(Z, m, (G) => {
        const Q = w[G].uint32;
        this._hueStats.check(Q), Q in U ? U[Q]++ : Q in j ? ++j[Q] >= $ && (U[Q] = j[Q]) : j[Q] = 1;
      });
    }), this._hueStats.injectIntoDictionary(U);
  }
  _iterateBox(d, m, g) {
    const w = d, I = w.y * m + w.x, P = (w.y + w.h - 1) * m + (w.x + w.w - 1), F = m - w.w + 1;
    let D = 0, U = I;
    do
      g.call(this, U), U += ++D % w.w == 0 ? F : 1;
    while (U <= P);
  }
  _makeBoxes(d, m, g, w) {
    const I = d % g, P = m % w, F = d - I, D = m - P, U = [];
    for (let Z = 0; Z < m; Z += w) for (let $ = 0; $ < d; $ += g) U.push({ x: $, y: Z, w: $ === F ? I : g, h: Z === D ? P : w });
    return U;
  }
}, ColorHistogram = _ColorHistogram;
__publicField(ColorHistogram, "_boxSize", [64, 64]), __publicField(ColorHistogram, "_boxPixels", 2), __publicField(ColorHistogram, "_hueGroups", 10);
var RemovedColor = class {
  constructor(d, m, g) {
    __publicField(this, "index"), __publicField(this, "color"), __publicField(this, "distance"), this.index = d, this.color = m, this.distance = g;
  }
}, RGBQuant = class extends AbstractPaletteQuantizer {
  constructor(d, m = 256, g = 2) {
    super(), __publicField(this, "_colors"), __publicField(this, "_initialDistance"), __publicField(this, "_distanceIncrement"), __publicField(this, "_histogram"), __publicField(this, "_distance"), this._distance = d, this._colors = m, this._histogram = new ColorHistogram(g, m), this._initialDistance = 0.01, this._distanceIncrement = 5e-3;
  }
  sample(d) {
    this._histogram.sample(d);
  }
  *quantize() {
    const d = this._histogram.getImportanceSortedColorsIDXI32();
    if (d.length === 0) throw new Error("No colors in image");
    yield* this._buildPalette(d);
  }
  *_buildPalette(d) {
    const m = new Palette(), g = m.getPointContainer().getPointArray(), w = new Array(d.length);
    for (let $ = 0; $ < d.length; $++) g.push(Point.createByUint32(d[$])), w[$] = 1;
    const I = g.length, P = [];
    let F = I, D = this._initialDistance;
    const U = new ProgressTracker(F - this._colors, 99);
    for (; F > this._colors; ) {
      P.length = 0;
      for (let $ = 0; $ < I; $++) {
        if (U.shouldNotify(I - F) && (yield { progress: U.progress }), w[$] === 0) continue;
        const j = g[$];
        for (let G = $ + 1; G < I; G++) {
          if (w[G] === 0) continue;
          const Q = g[G], H = this._distance.calculateNormalized(j, Q);
          H < D && (P.push(new RemovedColor(G, Q, H)), w[G] = 0, F--);
        }
      }
      D += F > 3 * this._colors ? this._initialDistance : this._distanceIncrement;
    }
    if (F < this._colors) {
      stableSort(P, (j, G) => G.distance - j.distance);
      let $ = 0;
      for (; F < this._colors && $ < P.length; )
        w[P[$].index] = 1, F++, $++;
    }
    let Z = g.length;
    for (let $ = Z - 1; $ >= 0; $--) w[$] === 0 && ($ !== Z - 1 && (g[$] = g[Z - 1]), --Z);
    g.length = Z, m.sort(), yield { palette: m, progress: 100 };
  }
};
function createArray1D(d) {
  const m = [];
  for (let g = 0; g < d; g++) m[g] = 0;
  return m;
}
function createArray4D(d, m, g, w) {
  const I = new Array(d);
  for (let P = 0; P < d; P++) {
    I[P] = new Array(m);
    for (let F = 0; F < m; F++) {
      I[P][F] = new Array(g);
      for (let D = 0; D < g; D++) {
        I[P][F][D] = new Array(w);
        for (let U = 0; U < w; U++) I[P][F][D][U] = 0;
      }
    }
  }
  return I;
}
function createArray3D(d, m, g) {
  const w = new Array(d);
  for (let I = 0; I < d; I++) {
    w[I] = new Array(m);
    for (let P = 0; P < m; P++) {
      w[I][P] = new Array(g);
      for (let F = 0; F < g; F++) w[I][P][F] = 0;
    }
  }
  return w;
}
function fillArray3D(d, m, g, w, I) {
  for (let P = 0; P < m; P++) {
    d[P] = [];
    for (let F = 0; F < g; F++) {
      d[P][F] = [];
      for (let D = 0; D < w; D++) d[P][F][D] = I;
    }
  }
}
function fillArray1D(d, m, g) {
  for (let w = 0; w < m; w++) d[w] = g;
}
var WuColorCube = class {
  constructor() {
    __publicField(this, "redMinimum"), __publicField(this, "redMaximum"), __publicField(this, "greenMinimum"), __publicField(this, "greenMaximum"), __publicField(this, "blueMinimum"), __publicField(this, "blueMaximum"), __publicField(this, "volume"), __publicField(this, "alphaMinimum"), __publicField(this, "alphaMaximum");
  }
}, _WuQuant = class extends AbstractPaletteQuantizer {
  constructor(d, m = 256, g = 5) {
    super(), __publicField(this, "_reds"), __publicField(this, "_greens"), __publicField(this, "_blues"), __publicField(this, "_alphas"), __publicField(this, "_sums"), __publicField(this, "_weights"), __publicField(this, "_momentsRed"), __publicField(this, "_momentsGreen"), __publicField(this, "_momentsBlue"), __publicField(this, "_momentsAlpha"), __publicField(this, "_moments"), __publicField(this, "_table"), __publicField(this, "_pixels"), __publicField(this, "_cubes"), __publicField(this, "_colors"), __publicField(this, "_significantBitsPerChannel"), __publicField(this, "_maxSideIndex"), __publicField(this, "_alphaMaxSideIndex"), __publicField(this, "_sideSize"), __publicField(this, "_alphaSideSize"), __publicField(this, "_distance"), this._distance = d, this._setQuality(g), this._initialize(m);
  }
  sample(d) {
    const m = d.getPointArray();
    for (let g = 0, w = m.length; g < w; g++) this._addColor(m[g]);
    this._pixels = this._pixels.concat(m);
  }
  *quantize() {
    yield* this._preparePalette();
    const d = new Palette();
    for (let m = 0; m < this._colors; m++) if (this._sums[m] > 0) {
      const g = this._sums[m], w = this._reds[m] / g, I = this._greens[m] / g, P = this._blues[m] / g, F = this._alphas[m] / g, D = Point.createByRGBA(0 | w, 0 | I, 0 | P, 0 | F);
      d.add(D);
    }
    d.sort(), yield { palette: d, progress: 100 };
  }
  *_preparePalette() {
    yield* this._calculateMoments();
    let d = 0;
    const m = createArray1D(this._colors);
    for (let F = 1; F < this._colors; ++F) {
      this._cut(this._cubes[d], this._cubes[F]) ? (m[d] = this._cubes[d].volume > 1 ? this._calculateVariance(this._cubes[d]) : 0, m[F] = this._cubes[F].volume > 1 ? this._calculateVariance(this._cubes[F]) : 0) : (m[d] = 0, F--), d = 0;
      let D = m[0];
      for (let U = 1; U <= F; ++U) m[U] > D && (D = m[U], d = U);
      if (D <= 0) {
        this._colors = F + 1;
        break;
      }
    }
    const g = [], w = [], I = [], P = [];
    for (let F = 0; F < this._colors; ++F) {
      const D = _WuQuant._volume(this._cubes[F], this._weights);
      D > 0 ? (g[F] = _WuQuant._volume(this._cubes[F], this._momentsRed) / D | 0, w[F] = _WuQuant._volume(this._cubes[F], this._momentsGreen) / D | 0, I[F] = _WuQuant._volume(this._cubes[F], this._momentsBlue) / D | 0, P[F] = _WuQuant._volume(this._cubes[F], this._momentsAlpha) / D | 0) : (g[F] = 0, w[F] = 0, I[F] = 0, P[F] = 0);
    }
    this._reds = createArray1D(this._colors + 1), this._greens = createArray1D(this._colors + 1), this._blues = createArray1D(this._colors + 1), this._alphas = createArray1D(this._colors + 1), this._sums = createArray1D(this._colors + 1);
    for (let F = 0, D = this._pixels.length; F < D; F++) {
      const U = this._pixels[F];
      let Z = -1, $ = Number.MAX_VALUE;
      for (let j = 0; j < this._colors; j++) {
        const G = g[j], Q = w[j], H = I[j], W = P[j], q = this._distance.calculateRaw(G, Q, H, W, U.r, U.g, U.b, U.a);
        q < $ && ($ = q, Z = j);
      }
      this._reds[Z] += U.r, this._greens[Z] += U.g, this._blues[Z] += U.b, this._alphas[Z] += U.a, this._sums[Z]++;
    }
  }
  _addColor(d) {
    const m = 8 - this._significantBitsPerChannel, g = 1 + (d.r >> m), w = 1 + (d.g >> m), I = 1 + (d.b >> m), P = 1 + (d.a >> m);
    this._weights[P][g][w][I]++, this._momentsRed[P][g][w][I] += d.r, this._momentsGreen[P][g][w][I] += d.g, this._momentsBlue[P][g][w][I] += d.b, this._momentsAlpha[P][g][w][I] += d.a, this._moments[P][g][w][I] += this._table[d.r] + this._table[d.g] + this._table[d.b] + this._table[d.a];
  }
  *_calculateMoments() {
    const d = [], m = [], g = [], w = [], I = [], P = [], F = createArray3D(this._sideSize, this._sideSize, this._sideSize), D = createArray3D(this._sideSize, this._sideSize, this._sideSize), U = createArray3D(this._sideSize, this._sideSize, this._sideSize), Z = createArray3D(this._sideSize, this._sideSize, this._sideSize), $ = createArray3D(this._sideSize, this._sideSize, this._sideSize), j = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    let G = 0;
    const Q = new ProgressTracker(this._alphaMaxSideIndex * this._maxSideIndex, 99);
    for (let H = 1; H <= this._alphaMaxSideIndex; ++H) {
      fillArray3D(F, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(D, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(U, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(Z, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D($, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(j, this._sideSize, this._sideSize, this._sideSize, 0);
      for (let W = 1; W <= this._maxSideIndex; ++W, ++G) {
        Q.shouldNotify(G) && (yield { progress: Q.progress }), fillArray1D(d, this._sideSize, 0), fillArray1D(m, this._sideSize, 0), fillArray1D(g, this._sideSize, 0), fillArray1D(w, this._sideSize, 0), fillArray1D(I, this._sideSize, 0), fillArray1D(P, this._sideSize, 0);
        for (let q = 1; q <= this._maxSideIndex; ++q) {
          let et = 0, rt = 0, tt = 0, V = 0, X = 0, ot = 0;
          for (let it = 1; it <= this._maxSideIndex; ++it) et += this._weights[H][W][q][it], rt += this._momentsRed[H][W][q][it], tt += this._momentsGreen[H][W][q][it], V += this._momentsBlue[H][W][q][it], X += this._momentsAlpha[H][W][q][it], ot += this._moments[H][W][q][it], d[it] += et, m[it] += rt, g[it] += tt, w[it] += V, I[it] += X, P[it] += ot, F[W][q][it] = F[W - 1][q][it] + d[it], D[W][q][it] = D[W - 1][q][it] + m[it], U[W][q][it] = U[W - 1][q][it] + g[it], Z[W][q][it] = Z[W - 1][q][it] + w[it], $[W][q][it] = $[W - 1][q][it] + I[it], j[W][q][it] = j[W - 1][q][it] + P[it], this._weights[H][W][q][it] = this._weights[H - 1][W][q][it] + F[W][q][it], this._momentsRed[H][W][q][it] = this._momentsRed[H - 1][W][q][it] + D[W][q][it], this._momentsGreen[H][W][q][it] = this._momentsGreen[H - 1][W][q][it] + U[W][q][it], this._momentsBlue[H][W][q][it] = this._momentsBlue[H - 1][W][q][it] + Z[W][q][it], this._momentsAlpha[H][W][q][it] = this._momentsAlpha[H - 1][W][q][it] + $[W][q][it], this._moments[H][W][q][it] = this._moments[H - 1][W][q][it] + j[W][q][it];
        }
      }
    }
  }
  static _volumeFloat(d, m) {
    return m[d.alphaMaximum][d.redMaximum][d.greenMaximum][d.blueMaximum] - m[d.alphaMaximum][d.redMaximum][d.greenMinimum][d.blueMaximum] - m[d.alphaMaximum][d.redMinimum][d.greenMaximum][d.blueMaximum] + m[d.alphaMaximum][d.redMinimum][d.greenMinimum][d.blueMaximum] - m[d.alphaMinimum][d.redMaximum][d.greenMaximum][d.blueMaximum] + m[d.alphaMinimum][d.redMaximum][d.greenMinimum][d.blueMaximum] + m[d.alphaMinimum][d.redMinimum][d.greenMaximum][d.blueMaximum] - m[d.alphaMinimum][d.redMinimum][d.greenMinimum][d.blueMaximum] - (m[d.alphaMaximum][d.redMaximum][d.greenMaximum][d.blueMinimum] - m[d.alphaMinimum][d.redMaximum][d.greenMaximum][d.blueMinimum] - m[d.alphaMaximum][d.redMaximum][d.greenMinimum][d.blueMinimum] + m[d.alphaMinimum][d.redMaximum][d.greenMinimum][d.blueMinimum] - m[d.alphaMaximum][d.redMinimum][d.greenMaximum][d.blueMinimum] + m[d.alphaMinimum][d.redMinimum][d.greenMaximum][d.blueMinimum] + m[d.alphaMaximum][d.redMinimum][d.greenMinimum][d.blueMinimum] - m[d.alphaMinimum][d.redMinimum][d.greenMinimum][d.blueMinimum]);
  }
  static _volume(d, m) {
    return 0 | _WuQuant._volumeFloat(d, m);
  }
  static _top(d, m, g, w) {
    let I;
    switch (m) {
      case _WuQuant._alpha:
        I = w[g][d.redMaximum][d.greenMaximum][d.blueMaximum] - w[g][d.redMaximum][d.greenMinimum][d.blueMaximum] - w[g][d.redMinimum][d.greenMaximum][d.blueMaximum] + w[g][d.redMinimum][d.greenMinimum][d.blueMaximum] - (w[g][d.redMaximum][d.greenMaximum][d.blueMinimum] - w[g][d.redMaximum][d.greenMinimum][d.blueMinimum] - w[g][d.redMinimum][d.greenMaximum][d.blueMinimum] + w[g][d.redMinimum][d.greenMinimum][d.blueMinimum]);
        break;
      case _WuQuant._red:
        I = w[d.alphaMaximum][g][d.greenMaximum][d.blueMaximum] - w[d.alphaMaximum][g][d.greenMinimum][d.blueMaximum] - w[d.alphaMinimum][g][d.greenMaximum][d.blueMaximum] + w[d.alphaMinimum][g][d.greenMinimum][d.blueMaximum] - (w[d.alphaMaximum][g][d.greenMaximum][d.blueMinimum] - w[d.alphaMaximum][g][d.greenMinimum][d.blueMinimum] - w[d.alphaMinimum][g][d.greenMaximum][d.blueMinimum] + w[d.alphaMinimum][g][d.greenMinimum][d.blueMinimum]);
        break;
      case _WuQuant._green:
        I = w[d.alphaMaximum][d.redMaximum][g][d.blueMaximum] - w[d.alphaMaximum][d.redMinimum][g][d.blueMaximum] - w[d.alphaMinimum][d.redMaximum][g][d.blueMaximum] + w[d.alphaMinimum][d.redMinimum][g][d.blueMaximum] - (w[d.alphaMaximum][d.redMaximum][g][d.blueMinimum] - w[d.alphaMaximum][d.redMinimum][g][d.blueMinimum] - w[d.alphaMinimum][d.redMaximum][g][d.blueMinimum] + w[d.alphaMinimum][d.redMinimum][g][d.blueMinimum]);
        break;
      case _WuQuant._blue:
        I = w[d.alphaMaximum][d.redMaximum][d.greenMaximum][g] - w[d.alphaMaximum][d.redMaximum][d.greenMinimum][g] - w[d.alphaMaximum][d.redMinimum][d.greenMaximum][g] + w[d.alphaMaximum][d.redMinimum][d.greenMinimum][g] - (w[d.alphaMinimum][d.redMaximum][d.greenMaximum][g] - w[d.alphaMinimum][d.redMaximum][d.greenMinimum][g] - w[d.alphaMinimum][d.redMinimum][d.greenMaximum][g] + w[d.alphaMinimum][d.redMinimum][d.greenMinimum][g]);
        break;
      default:
        throw new Error("impossible");
    }
    return 0 | I;
  }
  static _bottom(d, m, g) {
    switch (m) {
      case _WuQuant._alpha:
        return -g[d.alphaMinimum][d.redMaximum][d.greenMaximum][d.blueMaximum] + g[d.alphaMinimum][d.redMaximum][d.greenMinimum][d.blueMaximum] + g[d.alphaMinimum][d.redMinimum][d.greenMaximum][d.blueMaximum] - g[d.alphaMinimum][d.redMinimum][d.greenMinimum][d.blueMaximum] - (-g[d.alphaMinimum][d.redMaximum][d.greenMaximum][d.blueMinimum] + g[d.alphaMinimum][d.redMaximum][d.greenMinimum][d.blueMinimum] + g[d.alphaMinimum][d.redMinimum][d.greenMaximum][d.blueMinimum] - g[d.alphaMinimum][d.redMinimum][d.greenMinimum][d.blueMinimum]);
      case _WuQuant._red:
        return -g[d.alphaMaximum][d.redMinimum][d.greenMaximum][d.blueMaximum] + g[d.alphaMaximum][d.redMinimum][d.greenMinimum][d.blueMaximum] + g[d.alphaMinimum][d.redMinimum][d.greenMaximum][d.blueMaximum] - g[d.alphaMinimum][d.redMinimum][d.greenMinimum][d.blueMaximum] - (-g[d.alphaMaximum][d.redMinimum][d.greenMaximum][d.blueMinimum] + g[d.alphaMaximum][d.redMinimum][d.greenMinimum][d.blueMinimum] + g[d.alphaMinimum][d.redMinimum][d.greenMaximum][d.blueMinimum] - g[d.alphaMinimum][d.redMinimum][d.greenMinimum][d.blueMinimum]);
      case _WuQuant._green:
        return -g[d.alphaMaximum][d.redMaximum][d.greenMinimum][d.blueMaximum] + g[d.alphaMaximum][d.redMinimum][d.greenMinimum][d.blueMaximum] + g[d.alphaMinimum][d.redMaximum][d.greenMinimum][d.blueMaximum] - g[d.alphaMinimum][d.redMinimum][d.greenMinimum][d.blueMaximum] - (-g[d.alphaMaximum][d.redMaximum][d.greenMinimum][d.blueMinimum] + g[d.alphaMaximum][d.redMinimum][d.greenMinimum][d.blueMinimum] + g[d.alphaMinimum][d.redMaximum][d.greenMinimum][d.blueMinimum] - g[d.alphaMinimum][d.redMinimum][d.greenMinimum][d.blueMinimum]);
      case _WuQuant._blue:
        return -g[d.alphaMaximum][d.redMaximum][d.greenMaximum][d.blueMinimum] + g[d.alphaMaximum][d.redMaximum][d.greenMinimum][d.blueMinimum] + g[d.alphaMaximum][d.redMinimum][d.greenMaximum][d.blueMinimum] - g[d.alphaMaximum][d.redMinimum][d.greenMinimum][d.blueMinimum] - (-g[d.alphaMinimum][d.redMaximum][d.greenMaximum][d.blueMinimum] + g[d.alphaMinimum][d.redMaximum][d.greenMinimum][d.blueMinimum] + g[d.alphaMinimum][d.redMinimum][d.greenMaximum][d.blueMinimum] - g[d.alphaMinimum][d.redMinimum][d.greenMinimum][d.blueMinimum]);
      default:
        return 0;
    }
  }
  _calculateVariance(d) {
    const m = _WuQuant._volume(d, this._momentsRed), g = _WuQuant._volume(d, this._momentsGreen), w = _WuQuant._volume(d, this._momentsBlue), I = _WuQuant._volume(d, this._momentsAlpha);
    return _WuQuant._volumeFloat(d, this._moments) - (m * m + g * g + w * w + I * I) / _WuQuant._volume(d, this._weights);
  }
  _maximize(d, m, g, w, I, P, F, D, U) {
    const Z = 0 | _WuQuant._bottom(d, m, this._momentsRed), $ = 0 | _WuQuant._bottom(d, m, this._momentsGreen), j = 0 | _WuQuant._bottom(d, m, this._momentsBlue), G = 0 | _WuQuant._bottom(d, m, this._momentsAlpha), Q = 0 | _WuQuant._bottom(d, m, this._weights);
    let H = 0, W = -1;
    for (let q = g; q < w; ++q) {
      let et = Z + _WuQuant._top(d, m, q, this._momentsRed), rt = $ + _WuQuant._top(d, m, q, this._momentsGreen), tt = j + _WuQuant._top(d, m, q, this._momentsBlue), V = G + _WuQuant._top(d, m, q, this._momentsAlpha), X = Q + _WuQuant._top(d, m, q, this._weights);
      if (X !== 0) {
        let ot = et * et + rt * rt + tt * tt + V * V, it = ot / X;
        et = I - et, rt = P - rt, tt = F - tt, V = D - V, X = U - X, X !== 0 && (ot = et * et + rt * rt + tt * tt + V * V, it += ot / X, it > H && (H = it, W = q));
      }
    }
    return { max: H, position: W };
  }
  _cut(d, m) {
    let g;
    const w = _WuQuant._volume(d, this._momentsRed), I = _WuQuant._volume(d, this._momentsGreen), P = _WuQuant._volume(d, this._momentsBlue), F = _WuQuant._volume(d, this._momentsAlpha), D = _WuQuant._volume(d, this._weights), U = this._maximize(d, _WuQuant._red, d.redMinimum + 1, d.redMaximum, w, I, P, F, D), Z = this._maximize(d, _WuQuant._green, d.greenMinimum + 1, d.greenMaximum, w, I, P, F, D), $ = this._maximize(d, _WuQuant._blue, d.blueMinimum + 1, d.blueMaximum, w, I, P, F, D), j = this._maximize(d, _WuQuant._alpha, d.alphaMinimum + 1, d.alphaMaximum, w, I, P, F, D);
    if (j.max >= U.max && j.max >= Z.max && j.max >= $.max) {
      if (g = _WuQuant._alpha, j.position < 0) return !1;
    } else g = U.max >= j.max && U.max >= Z.max && U.max >= $.max ? _WuQuant._red : Z.max >= j.max && Z.max >= U.max && Z.max >= $.max ? _WuQuant._green : _WuQuant._blue;
    switch (m.redMaximum = d.redMaximum, m.greenMaximum = d.greenMaximum, m.blueMaximum = d.blueMaximum, m.alphaMaximum = d.alphaMaximum, g) {
      case _WuQuant._red:
        m.redMinimum = d.redMaximum = U.position, m.greenMinimum = d.greenMinimum, m.blueMinimum = d.blueMinimum, m.alphaMinimum = d.alphaMinimum;
        break;
      case _WuQuant._green:
        m.greenMinimum = d.greenMaximum = Z.position, m.redMinimum = d.redMinimum, m.blueMinimum = d.blueMinimum, m.alphaMinimum = d.alphaMinimum;
        break;
      case _WuQuant._blue:
        m.blueMinimum = d.blueMaximum = $.position, m.redMinimum = d.redMinimum, m.greenMinimum = d.greenMinimum, m.alphaMinimum = d.alphaMinimum;
        break;
      case _WuQuant._alpha:
        m.alphaMinimum = d.alphaMaximum = j.position, m.blueMinimum = d.blueMinimum, m.redMinimum = d.redMinimum, m.greenMinimum = d.greenMinimum;
    }
    return d.volume = (d.redMaximum - d.redMinimum) * (d.greenMaximum - d.greenMinimum) * (d.blueMaximum - d.blueMinimum) * (d.alphaMaximum - d.alphaMinimum), m.volume = (m.redMaximum - m.redMinimum) * (m.greenMaximum - m.greenMinimum) * (m.blueMaximum - m.blueMinimum) * (m.alphaMaximum - m.alphaMinimum), !0;
  }
  _initialize(d) {
    this._colors = d, this._cubes = [];
    for (let m = 0; m < d; m++) this._cubes[m] = new WuColorCube();
    this._cubes[0].redMinimum = 0, this._cubes[0].greenMinimum = 0, this._cubes[0].blueMinimum = 0, this._cubes[0].alphaMinimum = 0, this._cubes[0].redMaximum = this._maxSideIndex, this._cubes[0].greenMaximum = this._maxSideIndex, this._cubes[0].blueMaximum = this._maxSideIndex, this._cubes[0].alphaMaximum = this._alphaMaxSideIndex, this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._table = [];
    for (let m = 0; m < 256; ++m) this._table[m] = m * m;
    this._pixels = [];
  }
  _setQuality(d = 5) {
    this._significantBitsPerChannel = d, this._maxSideIndex = 1 << this._significantBitsPerChannel, this._alphaMaxSideIndex = this._maxSideIndex, this._sideSize = this._maxSideIndex + 1, this._alphaSideSize = this._alphaMaxSideIndex + 1;
  }
}, WuQuant = _WuQuant;
__publicField(WuQuant, "_alpha", 3), __publicField(WuQuant, "_red", 2), __publicField(WuQuant, "_green", 1), __publicField(WuQuant, "_blue", 0);
var image_exports = {};
__export(image_exports, { AbstractImageQuantizer: () => AbstractImageQuantizer, ErrorDiffusionArray: () => ErrorDiffusionArray, ErrorDiffusionArrayKernel: () => ErrorDiffusionArrayKernel, ErrorDiffusionRiemersma: () => ErrorDiffusionRiemersma, NearestColor: () => NearestColor });
var AbstractImageQuantizer = class {
  quantizeSync(d, m) {
    for (const g of this.quantize(d, m)) if (g.pointContainer) return g.pointContainer;
    throw new Error("unreachable");
  }
}, NearestColor = class extends AbstractImageQuantizer {
  constructor(d) {
    super(), __publicField(this, "_distance"), this._distance = d;
  }
  *quantize(d, m) {
    const g = d.getPointArray(), w = d.getWidth(), I = d.getHeight(), P = new ProgressTracker(I, 99);
    for (let F = 0; F < I; F++) {
      P.shouldNotify(F) && (yield { progress: P.progress });
      for (let D = 0, U = F * w; D < w; D++, U++) {
        const Z = g[U];
        Z.from(m.getNearestColor(this._distance, Z));
      }
    }
    yield { pointContainer: d, progress: 100 };
  }
}, ErrorDiffusionArrayKernel = ((d) => (d[d.FloydSteinberg = 0] = "FloydSteinberg", d[d.FalseFloydSteinberg = 1] = "FalseFloydSteinberg", d[d.Stucki = 2] = "Stucki", d[d.Atkinson = 3] = "Atkinson", d[d.Jarvis = 4] = "Jarvis", d[d.Burkes = 5] = "Burkes", d[d.Sierra = 6] = "Sierra", d[d.TwoSierra = 7] = "TwoSierra", d[d.SierraLite = 8] = "SierraLite", d))(ErrorDiffusionArrayKernel || {}), ErrorDiffusionArray = class extends AbstractImageQuantizer {
  constructor(d, m, g = !0, w = 0, I = !1) {
    super(), __publicField(this, "_minColorDistance"), __publicField(this, "_serpentine"), __publicField(this, "_kernel"), __publicField(this, "_calculateErrorLikeGIMP"), __publicField(this, "_distance"), this._setKernel(m), this._distance = d, this._minColorDistance = w, this._serpentine = g, this._calculateErrorLikeGIMP = I;
  }
  *quantize(d, m) {
    const g = d.getPointArray(), w = new Point(), I = d.getWidth(), P = d.getHeight(), F = [];
    let D = 1, U = 1;
    for (const $ of this._kernel) {
      const j = $[2] + 1;
      U < j && (U = j);
    }
    for (let $ = 0; $ < U; $++) this._fillErrorLine(F[$] = [], I);
    const Z = new ProgressTracker(P, 99);
    for (let $ = 0; $ < P; $++) {
      Z.shouldNotify($) && (yield { progress: Z.progress }), this._serpentine && (D *= -1);
      const j = $ * I, G = D === 1 ? 0 : I - 1, Q = D === 1 ? I : -1;
      this._fillErrorLine(F[0], I), F.push(F.shift());
      const H = F[0];
      for (let W = G, q = j + G; W !== Q; W += D, q += D) {
        const et = g[q], rt = H[W];
        w.from(et);
        const tt = Point.createByRGBA(inRange0to255Rounded(et.r + rt[0]), inRange0to255Rounded(et.g + rt[1]), inRange0to255Rounded(et.b + rt[2]), inRange0to255Rounded(et.a + rt[3])), V = m.getNearestColor(this._distance, tt);
        if (et.from(V), this._minColorDistance && this._distance.calculateNormalized(w, V) < this._minColorDistance)
          continue;
        let X, ot, it, st;
        this._calculateErrorLikeGIMP ? (X = tt.r - V.r, ot = tt.g - V.g, it = tt.b - V.b, st = tt.a - V.a) : (X = w.r - V.r, ot = w.g - V.g, it = w.b - V.b, st = w.a - V.a);
        const at = D === 1 ? 0 : this._kernel.length - 1, ct = D === 1 ? this._kernel.length : -1;
        for (let K = at; K !== ct; K += D) {
          const lt = this._kernel[K][1] * D, vt = this._kernel[K][2];
          if (lt + W >= 0 && lt + W < I && vt + $ >= 0 && vt + $ < P) {
            const dt = this._kernel[K][0], ht = F[vt][lt + W];
            ht[0] += X * dt, ht[1] += ot * dt, ht[2] += it * dt, ht[3] += st * dt;
          }
        }
      }
    }
    yield { pointContainer: d, progress: 100 };
  }
  _fillErrorLine(d, m) {
    d.length > m && (d.length = m);
    const g = d.length;
    for (let w = 0; w < g; w++) {
      const I = d[w];
      I[0] = I[1] = I[2] = I[3] = 0;
    }
    for (let w = g; w < m; w++) d[w] = [0, 0, 0, 0];
  }
  _setKernel(d) {
    switch (d) {
      case 0:
        this._kernel = [[7 / 16, 1, 0], [3 / 16, -1, 1], [5 / 16, 0, 1], [1 / 16, 1, 1]];
        break;
      case 1:
        this._kernel = [[3 / 8, 1, 0], [3 / 8, 0, 1], [2 / 8, 1, 1]];
        break;
      case 2:
        this._kernel = [[8 / 42, 1, 0], [4 / 42, 2, 0], [2 / 42, -2, 1], [4 / 42, -1, 1], [8 / 42, 0, 1], [4 / 42, 1, 1], [2 / 42, 2, 1], [1 / 42, -2, 2], [2 / 42, -1, 2], [4 / 42, 0, 2], [2 / 42, 1, 2], [1 / 42, 2, 2]];
        break;
      case 3:
        this._kernel = [[1 / 8, 1, 0], [1 / 8, 2, 0], [1 / 8, -1, 1], [1 / 8, 0, 1], [1 / 8, 1, 1], [1 / 8, 0, 2]];
        break;
      case 4:
        this._kernel = [[7 / 48, 1, 0], [5 / 48, 2, 0], [3 / 48, -2, 1], [5 / 48, -1, 1], [7 / 48, 0, 1], [5 / 48, 1, 1], [3 / 48, 2, 1], [1 / 48, -2, 2], [3 / 48, -1, 2], [5 / 48, 0, 2], [3 / 48, 1, 2], [1 / 48, 2, 2]];
        break;
      case 5:
        this._kernel = [[0.25, 1, 0], [4 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [0.25, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1]];
        break;
      case 6:
        this._kernel = [[5 / 32, 1, 0], [3 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [5 / 32, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1], [2 / 32, -1, 2], [3 / 32, 0, 2], [2 / 32, 1, 2]];
        break;
      case 7:
        this._kernel = [[0.25, 1, 0], [3 / 16, 2, 0], [1 / 16, -2, 1], [2 / 16, -1, 1], [3 / 16, 0, 1], [2 / 16, 1, 1], [1 / 16, 2, 1]];
        break;
      case 8:
        this._kernel = [[0.5, 1, 0], [1 / 4, -1, 1], [1 / 4, 0, 1]];
        break;
      default:
        throw new Error(`ErrorDiffusionArray: unknown kernel = ${d}`);
    }
  }
};
function* hilbertCurve(d, m, g) {
  const w = Math.max(d, m), I = { width: d, height: m, level: Math.floor(Math.log(w) / Math.log(2) + 1), callback: g, tracker: new ProgressTracker(d * m, 99), index: 0, x: 0, y: 0 };
  yield* walkHilbert(I, 1), visit(I, 0);
}
function* walkHilbert(d, m) {
  if (!(d.level < 1)) {
    switch (d.tracker.shouldNotify(d.index) && (yield { progress: d.tracker.progress }), d.level--, m) {
      case 2:
        yield* walkHilbert(d, 1), visit(d, 3), yield* walkHilbert(d, 2), visit(d, 4), yield* walkHilbert(d, 2), visit(d, 2), yield* walkHilbert(d, 4);
        break;
      case 3:
        yield* walkHilbert(d, 4), visit(d, 2), yield* walkHilbert(d, 3), visit(d, 1), yield* walkHilbert(d, 3), visit(d, 3), yield* walkHilbert(d, 1);
        break;
      case 1:
        yield* walkHilbert(d, 2), visit(d, 4), yield* walkHilbert(d, 1), visit(d, 3), yield* walkHilbert(d, 1), visit(d, 1), yield* walkHilbert(d, 3);
        break;
      case 4:
        yield* walkHilbert(d, 3), visit(d, 1), yield* walkHilbert(d, 4), visit(d, 2), yield* walkHilbert(d, 4), visit(d, 4), yield* walkHilbert(d, 2);
    }
    d.level++;
  }
}
function visit(d, m) {
  switch (d.x >= 0 && d.x < d.width && d.y >= 0 && d.y < d.height && (d.callback(d.x, d.y), d.index++), m) {
    case 2:
      d.x--;
      break;
    case 3:
      d.x++;
      break;
    case 1:
      d.y--;
      break;
    case 4:
      d.y++;
  }
}
var ErrorDiffusionRiemersma = class extends AbstractImageQuantizer {
  constructor(d, m = 16, g = 1) {
    super(), __publicField(this, "_distance"), __publicField(this, "_weights"), __publicField(this, "_errorQueueSize"), this._distance = d, this._errorQueueSize = m, this._weights = ErrorDiffusionRiemersma._createWeights(g, m);
  }
  *quantize(d, m) {
    const g = d.getPointArray(), w = d.getWidth(), I = d.getHeight(), P = [];
    let F = 0;
    for (let D = 0; D < this._errorQueueSize; D++) P[D] = { r: 0, g: 0, b: 0, a: 0 };
    yield* hilbertCurve(w, I, (D, U) => {
      const Z = g[D + U * w];
      let { r: $, g: j, b: G, a: Q } = Z;
      for (let et = 0; et < this._errorQueueSize; et++) {
        const rt = this._weights[et], tt = P[(et + F) % this._errorQueueSize];
        $ += tt.r * rt, j += tt.g * rt, G += tt.b * rt, Q += tt.a * rt;
      }
      const H = Point.createByRGBA(inRange0to255Rounded($), inRange0to255Rounded(j), inRange0to255Rounded(G), inRange0to255Rounded(Q)), W = m.getNearestColor(this._distance, H);
      F = (F + 1) % this._errorQueueSize;
      const q = (F + this._errorQueueSize - 1) % this._errorQueueSize;
      P[q].r = Z.r - W.r, P[q].g = Z.g - W.g, P[q].b = Z.b - W.b, P[q].a = Z.a - W.a, Z.from(W);
    }), yield { pointContainer: d, progress: 100 };
  }
  static _createWeights(d, m) {
    const g = [], w = Math.exp(Math.log(m) / (m - 1));
    for (let I = 0, P = 1; I < m; I++) g[I] = (P + 0.5 | 0) / m * d, P *= w;
    return g;
  }
}, quality_exports = {};
__export(quality_exports, { ssim: () => ssim });
var K1 = 0.01, K2 = 0.03;
function ssim(d, m) {
  if (d.getHeight() !== m.getHeight() || d.getWidth() !== m.getWidth()) throw new Error("Images have different sizes!");
  const g = (255 * K1) ** 2, w = (255 * K2) ** 2;
  let I = 0, P = 0;
  return iterate(d, m, (F, D, U, Z) => {
    let $ = 0, j = 0, G = 0;
    for (let H = 0; H < F.length; H++) j += (F[H] - U) ** 2, G += (D[H] - Z) ** 2, $ += (F[H] - U) * (D[H] - Z);
    const Q = F.length - 1;
    j /= Q, G /= Q, $ /= Q, P += (2 * U * Z + g) * (2 * $ + w) / ((U ** 2 + Z ** 2 + g) * (j + G + w)), I++;
  }), P / I;
}
function iterate(d, m, g) {
  const w = d.getWidth(), I = d.getHeight();
  for (let P = 0; P < I; P += 8) for (let F = 0; F < w; F += 8) {
    const D = Math.min(8, w - F), U = Math.min(8, I - P), Z = calculateLumaValuesForWindow(d, F, P, D, U), $ = calculateLumaValuesForWindow(m, F, P, D, U);
    g(Z, $, calculateAverageLuma(Z), calculateAverageLuma($));
  }
}
function calculateLumaValuesForWindow(d, m, g, w, I) {
  const P = d.getPointArray(), F = [];
  let D = 0;
  for (let U = g; U < g + I; U++) {
    const Z = U * d.getWidth();
    for (let $ = m; $ < m + w; $++) {
      const j = P[Z + $];
      F[D] = 0.2126 * j.r + 0.7152 * j.g + 0.0722 * j.b, D++;
    }
  }
  return F;
}
function calculateAverageLuma(d) {
  let m = 0;
  for (const g of d) m += g;
  return m / d.length;
}
function buildPaletteSync(d, { colorDistanceFormula: m, paletteQuantization: g, colors: w } = {}) {
  const I = paletteQuantizationToPaletteQuantizer(colorDistanceFormulaToColorDistance(m), g, w);
  return d.forEach((P) => I.sample(P)), I.quantizeSync();
}
function applyPaletteSync(d, m, { colorDistanceFormula: g, imageQuantization: w } = {}) {
  return imageQuantizationToImageQuantizer(colorDistanceFormulaToColorDistance(g), w).quantizeSync(d, m);
}
function colorDistanceFormulaToColorDistance(d = "euclidean-bt709") {
  switch (d) {
    case "cie94-graphic-arts":
      return new CIE94GraphicArts();
    case "cie94-textiles":
      return new CIE94Textiles();
    case "ciede2000":
      return new CIEDE2000();
    case "color-metric":
      return new CMetric();
    case "euclidean":
      return new Euclidean();
    case "euclidean-bt709":
      return new EuclideanBT709();
    case "euclidean-bt709-noalpha":
      return new EuclideanBT709NoAlpha();
    case "manhattan":
      return new Manhattan();
    case "manhattan-bt709":
      return new ManhattanBT709();
    case "manhattan-nommyde":
      return new ManhattanNommyde();
    case "pngquant":
      return new PNGQuant();
    default:
      throw new Error(`Unknown colorDistanceFormula ${d}`);
  }
}
function imageQuantizationToImageQuantizer(d, m = "floyd-steinberg") {
  switch (m) {
    case "nearest":
      return new NearestColor(d);
    case "riemersma":
      return new ErrorDiffusionRiemersma(d);
    case "floyd-steinberg":
      return new ErrorDiffusionArray(d, 0);
    case "false-floyd-steinberg":
      return new ErrorDiffusionArray(d, 1);
    case "stucki":
      return new ErrorDiffusionArray(d, 2);
    case "atkinson":
      return new ErrorDiffusionArray(d, 3);
    case "jarvis":
      return new ErrorDiffusionArray(d, 4);
    case "burkes":
      return new ErrorDiffusionArray(d, 5);
    case "sierra":
      return new ErrorDiffusionArray(d, 6);
    case "two-sierra":
      return new ErrorDiffusionArray(d, 7);
    case "sierra-lite":
      return new ErrorDiffusionArray(d, 8);
    default:
      throw new Error(`Unknown imageQuantization ${m}`);
  }
}
function paletteQuantizationToPaletteQuantizer(d, m = "wuquant", g = 256) {
  switch (m) {
    case "neuquant":
      return new NeuQuant(d, g);
    case "rgbquant":
      return new RGBQuant(d, g);
    case "wuquant":
      return new WuQuant(d, g);
    case "neuquant-float":
      return new NeuQuantFloat(d, g);
    default:
      throw new Error(`Unknown paletteQuantization ${m}`);
  }
}
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * cie94.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ciede2000.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * cmetric.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * common.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * constants.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ditherErrorDiffusionArray.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * euclidean.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * helper.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * hueStatistics.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * iq.ts - Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * lab2rgb.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * lab2xyz.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * manhattanNeuQuant.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * nearestColor.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * palette.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * pngQuant.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * point.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * pointContainer.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2hsl.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2lab.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2xyz.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ssim.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * wuQuant.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * xyz2lab.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * xyz2rgb.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * MIT License
 *
 * Copyright 2015-2018 Igor Bezkrovnyi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * riemersma.ts - part of Image Quantization Library
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * colorHistogram.ts - part of Image Quantization Library
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * neuquant.ts - part of Image Quantization Library
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgbquant.ts - part of Image Quantization Library
 */
typeof setImmediate == "function" ? setImmediate : typeof process < "u" && (process == null || process.nextTick);
const QuantizeOptionsSchema = z.object({ colors: z.number().optional(), colorDistanceFormula: z.union([z.literal("cie94-textiles"), z.literal("cie94-graphic-arts"), z.literal("ciede2000"), z.literal("color-metric"), z.literal("euclidean"), z.literal("euclidean-bt709-noalpha"), z.literal("euclidean-bt709"), z.literal("manhattan"), z.literal("manhattan-bt709"), z.literal("manhattan-nommyde"), z.literal("pngquant")]).optional(), paletteQuantization: z.union([z.literal("neuquant"), z.literal("neuquant-float"), z.literal("rgbquant"), z.literal("wuquant")]).optional(), imageQuantization: z.union([z.literal("nearest"), z.literal("riemersma"), z.literal("floyd-steinberg"), z.literal("false-floyd-steinberg"), z.literal("stucki"), z.literal("atkinson"), z.literal("jarvis"), z.literal("burkes"), z.literal("sierra"), z.literal("two-sierra"), z.literal("sierra-lite")]).optional() }), methods = { quantize(d, m) {
  const { colors: g, colorDistanceFormula: w, paletteQuantization: I, imageQuantization: P } = QuantizeOptionsSchema.parse(m), F = utils_exports.PointContainer.fromUint8Array(d.bitmap.data, d.bitmap.width, d.bitmap.height), D = applyPaletteSync(F, buildPaletteSync([F], { colors: g, colorDistanceFormula: w, paletteQuantization: I }), { colorDistanceFormula: w, imageQuantization: P });
  return d.bitmap.data = Buffer.from(D.toUint8Array()), d;
} };
var parseBmfontAscii = function(d) {
  if (!d) throw new Error("no data provided");
  var m = { pages: [], chars: [], kernings: [] }, g = (d = d.toString().trim()).split(/\r\n?|\n/g);
  if (g.length === 0) throw new Error("no data in BMFont file");
  for (var w = 0; w < g.length; w++) {
    var I = splitLine(g[w], w);
    if (I) if (I.key === "page") {
      if (typeof I.data.id != "number") throw new Error("malformed file at line " + w + " -- needs page id=N");
      if (typeof I.data.file != "string") throw new Error("malformed file at line " + w + ' -- needs page file="path"');
      m.pages[I.data.id] = I.data.file;
    } else I.key === "chars" || I.key === "kernings" || (I.key === "char" ? m.chars.push(I.data) : I.key === "kerning" ? m.kernings.push(I.data) : m[I.key] = I.data);
  }
  return m;
};
function splitLine(d, m) {
  if (!(d = d.replace(/\t+/g, " ").trim())) return null;
  var g = d.indexOf(" ");
  if (g === -1) throw new Error("no named row at line " + m);
  var w = d.substring(0, g);
  d = (d = (d = (d = d.substring(g + 1)).replace(/letter=[\'\"]\S+[\'\"]/gi, "")).split("=")).map(function(U) {
    return U.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g);
  });
  for (var I = [], P = 0; P < d.length; P++) {
    var F = d[P];
    P === 0 ? I.push({ key: F[0], data: "" }) : P === d.length - 1 ? I[I.length - 1].data = parseData(F[0]) : (I[I.length - 1].data = parseData(F[0]), I.push({ key: F[1], data: "" }));
  }
  var D = { key: w, data: {} };
  return I.forEach(function(U) {
    D.data[U.key] = U.data;
  }), D;
}
function parseData(d) {
  return d && d.length !== 0 ? d.indexOf('"') === 0 || d.indexOf("'") === 0 ? d.substring(1, d.length - 1) : d.indexOf(",") !== -1 ? parseIntList$1(d) : parseInt(d, 10) : "";
}
function parseIntList$1(d) {
  return d.split(",").map(function(m) {
    return parseInt(m, 10);
  });
}
getDefaultExportFromCjs(parseBmfontAscii);
var GLYPH_DESIGNER_ERROR = "chasrset", parseAttribs = function(d) {
  for (var m in d = Object.assign({}, d), GLYPH_DESIGNER_ERROR in d && (d.charset = d[GLYPH_DESIGNER_ERROR], delete d[GLYPH_DESIGNER_ERROR]), d) m !== "face" && m !== "charset" && (d[m] = m === "padding" || m === "spacing" ? parseIntList(d[m]) : parseInt(d[m], 10));
  return d;
};
function parseIntList(d) {
  return d.split(",").map(function(m) {
    return parseInt(m, 10);
  });
}
var xmlParseFromString = self.DOMParser !== void 0 ? function(d) {
  return new self.DOMParser().parseFromString(d, "application/xml");
} : self.ActiveXObject !== void 0 && new self.ActiveXObject("Microsoft.XMLDOM") ? function(d) {
  var m = new self.ActiveXObject("Microsoft.XMLDOM");
  return m.async = "false", m.loadXML(d), m;
} : function(d) {
  var m = document.createElement("div");
  return m.innerHTML = d, m;
}, parseAttributes = parseAttribs, parseFromString = xmlParseFromString, NAME_MAP = { scaleh: "scaleH", scalew: "scaleW", stretchh: "stretchH", lineheight: "lineHeight", alphachnl: "alphaChnl", redchnl: "redChnl", greenchnl: "greenChnl", bluechnl: "blueChnl" }, browser = function(d) {
  d = d.toString();
  var m = parseFromString(d), g = { pages: [], chars: [], kernings: [] };
  ["info", "common"].forEach(function(Z) {
    var $ = m.getElementsByTagName(Z)[0];
    $ && (g[Z] = parseAttributes(getAttribs($)));
  });
  var w = m.getElementsByTagName("pages")[0];
  if (!w) throw new Error("malformed file -- no <pages> element");
  for (var I = w.getElementsByTagName("page"), P = 0; P < I.length; P++) {
    var F = I[P], D = parseInt(F.getAttribute("id"), 10), U = F.getAttribute("file");
    if (isNaN(D)) throw new Error('malformed file -- page "id" attribute is NaN');
    if (!U) throw new Error('malformed file -- needs page "file" attribute');
    g.pages[parseInt(D, 10)] = U;
  }
  return ["chars", "kernings"].forEach(function(Z) {
    var $ = m.getElementsByTagName(Z)[0];
    if ($) for (var j = Z.substring(0, Z.length - 1), G = $.getElementsByTagName(j), Q = 0; Q < G.length; Q++) {
      var H = G[Q];
      g[Z].push(parseAttributes(getAttribs(H)));
    }
  }), g;
};
function getAttribs(d) {
  return getAttribList(d).reduce(function(m, g) {
    return m[mapName(g.nodeName)] = g.nodeValue, m;
  }, {});
}
function getAttribList(d) {
  for (var m = [], g = 0; g < d.attributes.length; g++) m.push(d.attributes[g]);
  return m;
}
function mapName(d) {
  return NAME_MAP[d.toLowerCase()] || d;
}
getDefaultExportFromCjs(browser);
var HEADER$1 = [66, 77, 70], parseBmfontBinary = function(d) {
  if (d.length < 6) throw new Error("invalid buffer length for BMFont");
  var m = HEADER$1.every(function(P, F) {
    return d.readUInt8(F) === P;
  });
  if (!m) throw new Error("BMFont missing BMF byte header");
  var g = 3;
  if (d.readUInt8(g++) > 3) throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");
  for (var w = { kernings: [], chars: [] }, I = 0; I < 5; I++) g += readBlock(w, d, g);
  return w;
};
function readBlock(d, m, g) {
  if (g > m.length - 1) return 0;
  var w = m.readUInt8(g++), I = m.readInt32LE(g);
  switch (g += 4, w) {
    case 1:
      d.info = readInfo(m, g);
      break;
    case 2:
      d.common = readCommon(m, g);
      break;
    case 3:
      d.pages = readPages(m, g, I);
      break;
    case 4:
      d.chars = readChars(m, g, I);
      break;
    case 5:
      d.kernings = readKernings(m, g, I);
  }
  return 5 + I;
}
function readInfo(d, m) {
  var g = {};
  g.size = d.readInt16LE(m);
  var w = d.readUInt8(m + 2);
  return g.smooth = w >> 7 & 1, g.unicode = w >> 6 & 1, g.italic = w >> 5 & 1, g.bold = w >> 4 & 1, w >> 3 & 1 && (g.fixedHeight = 1), g.charset = d.readUInt8(m + 3) || "", g.stretchH = d.readUInt16LE(m + 4), g.aa = d.readUInt8(m + 6), g.padding = [d.readInt8(m + 7), d.readInt8(m + 8), d.readInt8(m + 9), d.readInt8(m + 10)], g.spacing = [d.readInt8(m + 11), d.readInt8(m + 12)], g.outline = d.readUInt8(m + 13), g.face = readStringNT(d, m + 14), g;
}
function readCommon(d, m) {
  var g = {};
  return g.lineHeight = d.readUInt16LE(m), g.base = d.readUInt16LE(m + 2), g.scaleW = d.readUInt16LE(m + 4), g.scaleH = d.readUInt16LE(m + 6), g.pages = d.readUInt16LE(m + 8), d.readUInt8(m + 10), g.packed = 0, g.alphaChnl = d.readUInt8(m + 11), g.redChnl = d.readUInt8(m + 12), g.greenChnl = d.readUInt8(m + 13), g.blueChnl = d.readUInt8(m + 14), g;
}
function readPages(d, m, g) {
  for (var w = [], I = readNameNT(d, m), P = I.length + 1, F = g / P, D = 0; D < F; D++) w[D] = d.slice(m, m + I.length).toString("utf8"), m += P;
  return w;
}
function readChars(d, m, g) {
  for (var w = [], I = g / 20, P = 0; P < I; P++) {
    var F = {}, D = 20 * P;
    F.id = d.readUInt32LE(m + 0 + D), F.x = d.readUInt16LE(m + 4 + D), F.y = d.readUInt16LE(m + 6 + D), F.width = d.readUInt16LE(m + 8 + D), F.height = d.readUInt16LE(m + 10 + D), F.xoffset = d.readInt16LE(m + 12 + D), F.yoffset = d.readInt16LE(m + 14 + D), F.xadvance = d.readInt16LE(m + 16 + D), F.page = d.readUInt8(m + 18 + D), F.chnl = d.readUInt8(m + 19 + D), w[P] = F;
  }
  return w;
}
function readKernings(d, m, g) {
  for (var w = [], I = g / 10, P = 0; P < I; P++) {
    var F = {}, D = 10 * P;
    F.first = d.readUInt32LE(m + 0 + D), F.second = d.readUInt32LE(m + 4 + D), F.amount = d.readInt16LE(m + 8 + D), w[P] = F;
  }
  return w;
}
function readNameNT(d, m) {
  for (var g = m; g < d.length && d[g] !== 0; g++) ;
  return d.slice(m, g);
}
function readStringNT(d, m) {
  return readNameNT(d, m).toString("utf8");
}
getDefaultExportFromCjs(parseBmfontBinary);
function e(d) {
  return d && d.__esModule && Object.prototype.hasOwnProperty.call(d, "default") ? d.default : d;
}
const t = (d) => {
  if (!d) return null;
  const m = {};
  switch (d.type) {
    case "ELEMENT": {
      let g = {};
      const w = E(d.value.attributes), I = t(d.value.children);
      if (w && (g = Object.assign(g, w)), I) {
        const P = r(d.value.children);
        g = Object.assign(g, P);
      }
      m[d.value.type] = g;
      break;
    }
    case "ATTRIBUTE": {
      const g = d.value;
      m[g.name] = g.value;
      break;
    }
    case "CONTENT":
      return { content: d.value };
  }
  return m;
}, r = (d) => d && Array.isArray(d) && d.length !== 0 ? n(d) ? { content: d[0].value } : { children: d.map(t) } : null, n = (d) => d && Array.isArray(d) && d.length === 1 && d[0].type === "CONTENT", E = (d) => d && Array.isArray(d) ? d.map(t).reduce((m, g) => Object.assign(m, g), {}) : null;
var s = { convert: (d) => t(d.value.children[0]) }, a = { Token: (d, m) => ({ type: d, value: m }), TOKEN_TYPE: { OPEN_BRACKET: "OPEN_BRACKET", ELEMENT_TYPE: "ELEMENT_TYPE", CLOSE_ELEMENT: "CLOSE_ELEMENT", ATTRIB_NAME: "ATTRIB_NAME", ATTRIB_VALUE: "ATTRIB_VALUE", ASSIGN: "ASSIGN", CLOSE_BRACKET: "CLOSE_BRACKET", CONTENT: "CONTENT", EOF: "EOF" } };
const { Token: T, TOKEN_TYPE: u } = a, c = T("EOF"), l = (d) => d === " " || d === `
` || d === "\r" || d === "	", o = (d) => d.replace(/'/g, '"');
var N = { createLexer: function(d) {
  let m = null, g = ((j) => {
    let G = 0;
    for (; G < j.length && l(j[G]); ) G++;
    return ((Q, H) => {
      if (Q.startsWith("<?xml", H)) {
        const W = Q.length;
        for (; H < W; ) if (Q[H] !== "?") H++;
        else {
          if (Q[H + 1] === ">") return H + 2;
          H++;
        }
      }
      return H;
    })(j, G);
  })(d), w = [];
  const I = () => d[g], P = () => m !== c && g < d.length, F = (j) => j === '"' || j === "'", D = () => {
    for (; P() && l(d[g]); ) g++;
  }, U = (j) => {
    if (P()) {
      if (d[g] === "<") {
        let G = "<";
        return g++, P() && d[g] === "/" ? (g++, G = "</") : P() && d[g] === "!" && d[g + 1] === "-" && d[g + 2] === "-" && (g++, g++, g++, G = "<!--"), G;
      }
      if (I() === "/") {
        let G = "/";
        return g++, P() && I() === ">" && (g++, G = "/>"), G;
      }
      if (d[g] === "=" || d[g] === ">") {
        const G = d[g];
        return g++, G;
      }
    }
    return Z(!!j);
  }, Z = (j) => {
    const G = j ? /[^>=<]/u : /[a-zA-Z0-9_:-]/;
    let Q = g;
    for (; P() && d[g].match(G); ) g++;
    return o(d.substring(Q, g));
  }, $ = () => {
    const j = g;
    D();
    const G = g - j;
    if (P()) if (m && m.type === u.OPEN_BRACKET) {
      D();
      const Q = U(!1);
      m = T(u.ELEMENT_TYPE, Q), w.push(Q);
    } else if (m && m.type === u.ASSIGN) {
      P() && F(I()) && g++;
      let Q = g;
      for (; P() && !F(I()); ) g++;
      const H = o(d.substring(Q, g));
      g++, m = T(u.ATTRIB_VALUE, H);
    } else {
      D();
      let Q = U(!0);
      switch (Q) {
        case "=":
          m = m.type === u.ATTRIB_NAME ? T(u.ASSIGN) : T(u.CONTENT, Q);
          break;
        case "</": {
          const H = g;
          for (; d[g] !== ">"; ) g++;
          m = T(u.CLOSE_ELEMENT, d.substring(H, g)), g++, w.pop();
          break;
        }
        case "/>": {
          const H = w.pop();
          m = T(u.CLOSE_ELEMENT, H);
          break;
        }
        case "<!--": {
          const H = ["!", "-", "-"];
          for (; P() && (H[2] !== ">" || H[1] !== "-" || H[0] !== "-"); ) H.shift(), H.push(d[g]), g++;
          return $();
        }
        case ">":
          m = T(u.CLOSE_BRACKET);
          break;
        case "<":
          m = T(u.OPEN_BRACKET);
          break;
        default:
          if (Q && Q.length > 0) {
            if (m.type === u.CLOSE_BRACKET) {
              let H = "";
              I() !== "<" && (H = Z(!0)), m = T(u.CONTENT, Q + H);
            } else if (m.type !== u.ATTRIB_NAME && m.type !== u.CONTENT) m.type === u.CLOSE_ELEMENT ? (Q = " ".repeat(G) + Q, m = T(u.CONTENT, Q)) : m = T(u.ATTRIB_NAME, Q);
            else {
              const H = " ".repeat(G) + Q;
              m = T(u.CONTENT, H);
            }
            break;
          }
          {
            const H = 'Unknown Syntax : "' + d[g] + '"';
            throw new Error(H);
          }
      }
    }
    else m = c;
    return m;
  };
  return { peek: I, next: $, hasNext: P };
} };
const { createLexer: i } = N, { Token: p, TOKEN_TYPE: O } = a, [A, f, C, h] = ["ROOT", "ELEMENT", "ATTRIBUTE", "CONTENT"], _ = (d, m) => ({ type: d, value: m }), L = (d) => _(h, d), y = (d, m, g) => _(f, { type: d, attributes: m, children: g }), v = (d, m) => _(C, { name: d, value: m }), S = (d, m) => {
  const g = [];
  for (; d.hasNext(); ) {
    const w = d.next();
    switch (w.type) {
      case O.OPEN_BRACKET: {
        const I = d.next(), [P, F] = R(d);
        let D = [];
        F.type !== O.CLOSE_ELEMENT && (D = S(d, I)), D && D.length > 0 && D[0].type === O.CONTENT && (D = b(D)), g.push(y(I.value, P, D));
        break;
      }
      case O.CLOSE_ELEMENT:
        if (w.value === m.value) return g;
        break;
      case O.CONTENT:
        g.push(L(w.value));
        break;
      case O.EOF:
        return g;
      default:
        throw new Error(`Unknown Lexem type: ${w.type} "${w.value}, scoping element: ${m.value}"`);
    }
  }
  return g;
}, R = (d) => {
  const m = [];
  let g = d.peek();
  if (!d.hasNext() || g && g.type === O.CLOSE_BRACKET || g && g.type === O.CLOSE_ELEMENT) return [m, g];
  for (g = d.next(); d.hasNext() && g && g.type !== O.CLOSE_BRACKET && g.type !== O.CLOSE_ELEMENT; ) {
    const w = g;
    d.next();
    const I = d.next(), P = v(w.value, I.value);
    m.push(P), g = d.next();
  }
  return [m, g];
};
function b(d) {
  let m = [], g = "";
  return d.forEach((w) => {
    w.type === O.CONTENT ? g += w.value : (g.length && (m.push(L(g)), g = ""), m.push(w));
  }), g.length && m.push(L(g)), m;
}
var B = { transpile: function(d, m) {
  const g = ((w) => _(A, { children: S(w, p(A, "ROOT")) }))(i(d));
  return m ? m.convert(g) : g;
} };
const M = s, { transpile: x } = B;
var k = e({ convertXML: function(d, m) {
  return x(d, m || M);
}, createAST: function(d) {
  return x(d);
} }), simpleXmlToJson_min = k, xmlPackage = getDefaultExportFromCjs(simpleXmlToJson_min);
const { convertXML } = xmlPackage;
createJimp({ formats: [png] });
Buffer.from([66, 77, 70, 3]);
var pixelmatch_1 = pixelmatch;
const defaultOptions = { threshold: 0.1, includeAA: !1, alpha: 0.1, aaColor: [255, 255, 0], diffColor: [255, 0, 0], diffColorAlt: null, diffMask: !1 };
function pixelmatch(d, m, g, w, I, P) {
  if (!isPixelData(d) || !isPixelData(m) || g && !isPixelData(g)) throw new Error("Image data: Uint8Array, Uint8ClampedArray or Buffer expected.");
  if (d.length !== m.length || g && g.length !== d.length) throw new Error("Image sizes do not match.");
  if (d.length !== w * I * 4) throw new Error("Image data size does not match width/height.");
  P = Object.assign({}, defaultOptions, P);
  const F = w * I, D = new Uint32Array(d.buffer, d.byteOffset, F), U = new Uint32Array(m.buffer, m.byteOffset, F);
  let Z = !0;
  for (let G = 0; G < F; G++) if (D[G] !== U[G]) {
    Z = !1;
    break;
  }
  if (Z) {
    if (g && !P.diffMask) for (let G = 0; G < F; G++) drawGrayPixel(d, 4 * G, P.alpha, g);
    return 0;
  }
  const $ = 35215 * P.threshold * P.threshold;
  let j = 0;
  for (let G = 0; G < I; G++) for (let Q = 0; Q < w; Q++) {
    const H = 4 * (G * w + Q), W = colorDelta(d, m, H, H);
    Math.abs(W) > $ ? P.includeAA || !antialiased(d, Q, G, w, I, m) && !antialiased(m, Q, G, w, I, d) ? (g && drawPixel(g, H, ...W < 0 && P.diffColorAlt || P.diffColor), j++) : g && !P.diffMask && drawPixel(g, H, ...P.aaColor) : g && (P.diffMask || drawGrayPixel(d, H, P.alpha, g));
  }
  return j;
}
function isPixelData(d) {
  return ArrayBuffer.isView(d) && d.constructor.BYTES_PER_ELEMENT === 1;
}
function antialiased(d, m, g, w, I, P) {
  const F = Math.max(m - 1, 0), D = Math.max(g - 1, 0), U = Math.min(m + 1, w - 1), Z = Math.min(g + 1, I - 1), $ = 4 * (g * w + m);
  let j, G, Q, H, W = m === F || m === U || g === D || g === Z ? 1 : 0, q = 0, et = 0;
  for (let rt = F; rt <= U; rt++) for (let tt = D; tt <= Z; tt++) {
    if (rt === m && tt === g) continue;
    const V = colorDelta(d, d, $, 4 * (tt * w + rt), !0);
    if (V === 0) {
      if (W++, W > 2) return !1;
    } else V < q ? (q = V, j = rt, G = tt) : V > et && (et = V, Q = rt, H = tt);
  }
  return q !== 0 && et !== 0 && (hasManySiblings(d, j, G, w, I) && hasManySiblings(P, j, G, w, I) || hasManySiblings(d, Q, H, w, I) && hasManySiblings(P, Q, H, w, I));
}
function hasManySiblings(d, m, g, w, I) {
  const P = Math.max(m - 1, 0), F = Math.max(g - 1, 0), D = Math.min(m + 1, w - 1), U = Math.min(g + 1, I - 1), Z = 4 * (g * w + m);
  let $ = m === P || m === D || g === F || g === U ? 1 : 0;
  for (let j = P; j <= D; j++) for (let G = F; G <= U; G++) {
    if (j === m && G === g) continue;
    const Q = 4 * (G * w + j);
    if (d[Z] === d[Q] && d[Z + 1] === d[Q + 1] && d[Z + 2] === d[Q + 2] && d[Z + 3] === d[Q + 3] && $++, $ > 2) return !0;
  }
  return !1;
}
function colorDelta(d, m, g, w, I) {
  let P = d[g + 0], F = d[g + 1], D = d[g + 2], U = d[g + 3], Z = m[w + 0], $ = m[w + 1], j = m[w + 2], G = m[w + 3];
  if (U === G && P === Z && F === $ && D === j) return 0;
  U < 255 && (U /= 255, P = blend(P, U), F = blend(F, U), D = blend(D, U)), G < 255 && (G /= 255, Z = blend(Z, G), $ = blend($, G), j = blend(j, G));
  const Q = rgb2y(P, F, D), H = rgb2y(Z, $, j), W = Q - H;
  if (I) return W;
  const q = rgb2i(P, F, D) - rgb2i(Z, $, j), et = rgb2q(P, F, D) - rgb2q(Z, $, j), rt = 0.5053 * W * W + 0.299 * q * q + 0.1957 * et * et;
  return Q > H ? -rt : rt;
}
function rgb2y(d, m, g) {
  return 0.29889531 * d + 0.58662247 * m + 0.11448223 * g;
}
function rgb2i(d, m, g) {
  return 0.59597799 * d - 0.2741761 * m - 0.32180189 * g;
}
function rgb2q(d, m, g) {
  return 0.21147017 * d - 0.52261711 * m + 0.31114694 * g;
}
function blend(d, m) {
  return 255 + (d - 255) * m;
}
function drawPixel(d, m, g, w, I) {
  d[m + 0] = g, d[m + 1] = w, d[m + 2] = I, d[m + 3] = 255;
}
function drawGrayPixel(d, m, g, w) {
  const I = blend(rgb2y(d[m + 0], d[m + 1], d[m + 2]), g * d[m + 3] / 255);
  drawPixel(w, m, I, I, I);
}
getDefaultExportFromCjs(pixelmatch_1);
const defaultPlugins = [methods$h, methods$g, methods$f, methods$e, methods$c, methods$a, methods$b, methods$9, methods$8, methods$7, methods$6, methods$5, methods$4, methods$3, methods$d, methods$2, methods$1, methods], defaultFormats = [bmp, msBmp, gif, jpeg$2, png, tiff];
bmp().mime, gif().mime, jpeg$2().mime, png().mime, tiff().mime;
const Jimp = createJimp({ formats: defaultFormats, plugins: defaultPlugins });
var Me, Ce;
const Ge = class Ge extends EventTarget {
  constructor(g, { id: w, component: I, props: P }) {
    super();
    re(this, "_props");
    re(this, "result", createDeferredPromise());
    re(this, "id");
    re(this, "component");
    re(this, "modals");
    xe(this, Me, /* @__PURE__ */ state(!1));
    xe(this, Ce, /* @__PURE__ */ user_derived(() => this.modals.stack.length === 0 ? !1 : this.modals.stack[this.modals.stack.length - 1].id === this.id && !this.modals.transitioning));
    re(this, "close", (...g) => {
      var I;
      if (((I = this.onBeforeClose) == null ? void 0 : I.call(this)) === !1)
        return !1;
      const w = g[0];
      return this.dispatchEvent(new CustomEvent("close", { detail: w })), this.result.resolve(w), !0;
    });
    re(this, "onBeforeClose");
    this.id = w || (Ge._idCounter++).toString(), this.component = I, this._props = P ?? {}, this.modals = g;
  }
  get exitBeforeEnter() {
    return get(pe(this, Me));
  }
  set exitBeforeEnter(g) {
    set(pe(this, Me), g, !0);
  }
  get isOpen() {
    return get(pe(this, Ce));
  }
  set isOpen(g) {
    set(pe(this, Ce), g);
  }
  get index() {
    return this.modals.stack.indexOf(this);
  }
  get props() {
    return {
      ...this._props,
      id: this.id,
      index: this.index,
      isOpen: this.isOpen,
      close: this.close
    };
  }
  get promise() {
    return this.result.promise;
  }
};
Me = new WeakMap(), Ce = new WeakMap(), re(Ge, "_idCounter", 0);
let StackedModal = Ge;
function createDeferredPromise() {
  let d, m;
  return { promise: new Promise((w, I) => {
    d = w, m = I;
  }), resolve: d, reject: m };
}
var Pe, Be, Re;
class ModalStack {
  constructor() {
    xe(this, Pe, /* @__PURE__ */ state(proxy([])));
    xe(this, Be, /* @__PURE__ */ state(null));
    xe(this, Re, /* @__PURE__ */ state(!1));
    /**
     * Opens a new modal
     */
    re(this, "open", async (m, g, w) => {
      var F;
      if (this.transitioning)
        return;
      if (w != null && w.replace && !((F = this.stack[this.stack.length - 1]) == null ? void 0 : F.close()))
        throw new Error("Current modal prevented closing");
      this.action = "push";
      const I = this.stack[this.stack.length - 1];
      I != null && I.exitBeforeEnter && (this.transitioning = !0);
      const P = new StackedModal(this, { id: w == null ? void 0 : w.id, component: m, props: g });
      return this.stack.push(P), P.addEventListener(
        "close",
        () => {
          P.exitBeforeEnter && (this.transitioning = !0), this.stack.indexOf(P) > -1 && this.stack.splice(this.stack.indexOf(P), 1), this.action = "pop";
        },
        { once: !0 }
      ), P.promise;
    });
    /**
     * Closes the last `amount` of modals in the stack
     *
     * If closing was prevented by any modal it returns false
     */
    re(this, "close", (m = 1) => {
      if (typeof m != "number" || m < 1)
        throw new Error(`amount must be a number greater than 0. Received ${m}`);
      const g = this.stack.slice(this.stack.length - m).reverse();
      let w = 0;
      for (const I of g) {
        if (!I.close())
          break;
        w++;
      }
      return m === w;
    });
    /**
     * Closes a modal by its id. Can be provided with `options.id` in modals.open(Comp, props, options)
     */
    re(this, "closeById", (m) => {
      const g = this.stack.find((w) => w.id === m);
      return g ? g.close() : !1;
    });
    /**
     * Closes all modals in the stack.
     *
     * If closing was prevented by any modal, it returns false
     */
    re(this, "closeAll", () => this.close(this.stack.length));
  }
  get stack() {
    return get(pe(this, Pe));
  }
  set stack(m) {
    set(pe(this, Pe), m, !0);
  }
  get action() {
    return get(pe(this, Be));
  }
  set action(m) {
    set(pe(this, Be), m, !0);
  }
  get transitioning() {
    return get(pe(this, Re));
  }
  set transitioning(m) {
    set(pe(this, Re), m, !0);
  }
}
Pe = new WeakMap(), Be = new WeakMap(), Re = new WeakMap();
const key = Symbol("modal");
function setModal(d) {
  setContext(key, d);
}
function StackedModalContext(d, m) {
  push(m, !0), setModal(m.modal);
  var g = comment(), w = first_child(g);
  snippet(w, () => m.children), append(d, g), pop();
}
const modals = new ModalStack();
var root$6 = /* @__PURE__ */ template("<!> <!>", 1);
function Modals(d, m) {
  push(m, !0);
  function g(D) {
    return typeof D.prototype > "u";
  }
  var w = root$6(), I = first_child(w);
  {
    var P = (D) => {
      var U = comment(), Z = first_child(U);
      snippet(Z, () => m.backdrop ?? noop, () => modals), append(D, U);
    };
    if_block(I, (D) => {
      modals.stack.length > 0 && D(P);
    });
  }
  var F = sibling(I, 2);
  each(F, 19, () => modals.stack, (D) => D.id, (D, U) => {
    StackedModalContext(D, {
      get modal() {
        return get(U);
      },
      children: (Z, $) => {
        var j = comment(), G = first_child(j);
        {
          var Q = (W) => {
            var q = comment(), et = first_child(q);
            await_block(
              et,
              () => get(U).component(),
              (rt) => {
                var tt = comment(), V = first_child(tt);
                snippet(V, () => m.loading ?? noop, () => modals), append(rt, tt);
              },
              (rt, tt) => {
                var V = comment(), X = first_child(V);
                {
                  var ot = (st) => {
                    var at = comment(), ct = first_child(at);
                    snippet(
                      ct,
                      () => m.modal,
                      () => ({
                        component: get(tt).default,
                        props: get(U).props
                      }),
                      () => modals
                    ), append(st, at);
                  }, it = (st) => {
                    var at = comment(), ct = first_child(at);
                    component(ct, () => get(tt).default, (K, lt) => {
                      lt(K, spread_props(() => get(U).props));
                    }), append(st, at);
                  };
                  if_block(X, (st) => {
                    m.modal ? st(ot) : st(it, !1);
                  });
                }
                append(rt, V);
              }
            ), append(W, q);
          }, H = (W) => {
            var q = comment(), et = first_child(q);
            {
              var rt = (V) => {
                var X = comment(), ot = first_child(X);
                snippet(
                  ot,
                  () => m.modal,
                  () => ({
                    component: get(U).component,
                    props: get(U).props
                  }),
                  () => modals
                ), append(V, X);
              }, tt = (V) => {
                var X = comment(), ot = first_child(X);
                component(ot, () => get(U).component, (it, st) => {
                  st(it, spread_props(() => get(U).props));
                }), append(V, X);
              };
              if_block(et, (V) => {
                m.modal ? V(rt) : V(tt, !1);
              });
            }
            append(W, q);
          };
          if_block(G, (W) => {
            g(get(U).component) ? W(Q) : W(H, !1);
          });
        }
        append(Z, j);
      },
      $$slots: { default: !0 }
    });
  }), append(d, w), pop();
}
const colors = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADcAAAABCAYAAAB6+Db2AAAArklEQVR4AQXBkXbDUBgA4G/nFPYoe4g+QB9gjzAYDovBYLFQCAQuFAKBC4EfLhQKgUGgECgUCsPBPWf7vhf81VrVWpVSRIS3z8ZxoUyVdiPnapg3jnMlFUveimC+btzuYTxsCdb22yT76LeMi2cKxcVuPnhNiUiGhfc5ESeP6arPP77KnrU1FvqR9rK36uziQZCbrFtP0nwmyIdFJ6ThzDDRV543uoE8+z12mq7xDxIfXmk17RunAAAAAElFTkSuQmCC";
var Ne;
class NESColors {
  constructor() {
    re(this, "colorsImage");
    xe(this, Ne, /* @__PURE__ */ state(!1));
  }
  get colorsLoaded() {
    return get(pe(this, Ne));
  }
  set colorsLoaded(m) {
    set(pe(this, Ne), m, !0);
  }
  async loadColors() {
    this.colorsImage = await Jimp.read(colors), this.colorsLoaded = !0;
  }
  colors() {
    if (!this.colorsImage) return [];
    let m = [];
    return this.colorsImage.scan((g, w, I) => {
      let P = this.colorsImage.getPixelColor(g, w);
      m.push(intToRGBA$1(P));
    }), m;
  }
}
Ne = new WeakMap();
const leftArm = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQCAMAAADQmBKKAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAABaUExURQAAAP+gRPj4+OQAWDy8/wC4APi4APC8PPg4AABc//DQsORcEAB4+P94WPyYOABAWLz/GLy8vAD///h4WLj4GPjYeACIiACoAP+jRwBY+OdfEwDo2GhE/wAAADZc3gIAAAAedFJOU///////////////////////////////////////AOwYHF4AAAAJcEhZcwAADsAAAA7AAWrWiQkAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCA1LjEuOBtp6qgAAAC2ZVhJZklJKgAIAAAABQAaAQUAAQAAAEoAAAAbAQUAAQAAAFIAAAAoAQMAAQAAAAIAAAAxAQIAEAAAAFoAAABphwQAAQAAAGoAAAAAAAAAv3YBAOgDAAC/dgEA6AMAAFBhaW50Lk5FVCA1LjEuOAADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAAlAAAAAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAABMaKL5Hc4K5QAABvZJREFUeF7tnNt64joMhYWhDG1pCwNMw+zm/V9zf7Jz0FpKbMKh04usfTOWHPu37CR2FbbUdV2LSv/RCYroctXp0oELpkivlcVisQACCQGKpqDl5XK57G08mFpWKzRMUQsEPMsQDJEsOXzAo5eDX8LqBiJpAmRNy6US2TKHAAw0HgkhrK6ftAbINqjjN9MgCw+ESwgakBAkXM9TiwJ4IFsD3U2fppT4W4sG6AaeBEQAroxriLqMS7y/5D5ASED9s1sXGAAtoAV3002TriHqkVUERKAblYCmtOaBYMpulbaDd3FJA0D+SX+9YjuTGnNAetvfjWcaS5KLxh3jcxXQYzUDlTQDlTQDlTQDlTQDlZSAAIv3P3zmcC8utnAFLg+bGkUHbtqDPOkuqS8HuFxCfJn2Jvf6X6+zIxo2tVIHH0Tl6UmkOwbpJhmQJETG1sJbYFmuKcS/uPvc9qAFMgN+UvVAadu+6WMierDtET0Q7vfk1y/aAGb3czo5fFZXILON13hsNpvutBVD1hOlHWNX28/gdKDnZ4ox8GgDmwjUGGN8Lg+RAqHh5XWcR49Bz+v1sx+CLSoPhUiXduvmPT5d7dwvr69ZIBchJ9mEsNmYdYzL3B0lUTSH8vL6kqtdy1oE71OvSGQbpSBk1oSP2MtLJkARaE0PjgFN6jIvnbEM0YVAd5S8ltbQBVN2V0kpQuVFfWdlJ1iBCgvke9U8qdn87/SDUJJmoJJmoJJmoJJmoJISkHtW27J/tWQqD1m82xl6i/5LTxFuw9WV06nHeLlBka0jhAG9OTeWa3kHoJi/gWTBhyXyQDT+7ZaIZLfb5YFoRO8AFMNju5SPvRJ1RT0U5jbxDCS7XQAgjq8HsrVrkRVlU/YfHx+GT08YdpuuBF0hFre2i8iTBXp7oxjDBGuGdEUB2gOQhADZnu1vR2QORdo8TZkHgknEc5yuoRVcwkC8g/NAitxbZBfE8pSAZPkO8U8t9n4PRHJAadL6kuxoRuiWCCEUgFB4j3l5IB4Rr1kPBNWLQCL7/X7vHY1E18yod0AKBAQTgerEkyOaxBPrIwJGjJao9TWmCDTeqfzmJ3NWEt7e9E5neytZvr9fEKHxAPEISyoCFSOkyzrHM1ERyL0+jNxzyCszX9OVgHIt4j1q/v0Yxefg5d1cXvNaxQixcVwTql4pfnUVNKHqtcotaK8pda/VpD4mVf4OzUAl/USgoccoGpxb1RsHGqByvgiSWg58zOHX5+CbTbov8eI3cXgBA7Lblkjxj54hHCgk+fZjTFogWegeED6rW2PGjHegcuT2jDRCIYQDEkEDsg8UIsyXMZCsMacoe5vvU54y0AGBcEQ8wJQw67+dpC9XNTNg/xKvPHZEcjzlgWo5qCzBH8j17EOA/VrKKJqPOYlfJ8yWlWcSUCTCkPz5g91BxFcrkdzHpZQEFuHxFKbMDzEEsUApe9eXdT1nePgekEB3Ka8AlHfFP4ZYPgYKssq16MSAp9Mpc733DAHhnGWau0AKdBpvYcDDBzkGulWS4xkC4sfivYFKT+qiUpKcrY/SBR39OCAluqTafXRRT9lJv7O+savLNAOVNAOVNAOV9COB3JuTys7Pw+A9pXsXc30sgpr0FDQgn1gM/FscOseISHU+n9tKUlXV37/2Et6iVRkiTU81n0p2ps/PT9taTL2AIQCRVNXZEElVCRHRFnlbZf6unPJleG4SQSDMl/GHlhqQCoDkrwAQ/e5DLygAYbqMd4z8CVwRqIlQV2FxEntuq+J/XZnUrCFrYcD0GSUYYE30U9aVLc/Akq940RupA70eSJacq8Dm2kVtyjBFi9OJfpM5ijN4B7qIcfLEiWKAUh4gkiq/qL04AJTgmqh07DEHjRz9MBArd31ZEcgcDeNNkF3UD1YD1Je3FaRESaOO+ymenU3xnwPRlP8AINQPBFKN9jvqeJzStxlsbTXqeKBufg59q2agkmagkmagkhIQYA08Jpzf1bBi33DtIVtrxpdfOHL+CHekcYtLWzZogDd4gwPwliQ1y3/Q4fFI2Qgxv8Kpazmfz2ciguvpK77hHaJ8OVNS+3MuY9HsSDBE8Q/Vxp+ALBE0EF+e0B6mdpLxa2xXrPmyg0By6qjq68tigUAhRCCD8PWVA6LkV7SNBmgAqCHqLO5/LNNEqDccv75M+7K1HxEqkGD7bk5ACUj+c0QGyJ47uwj15SMB8bmOD5bZAMU1dDggEK0JTjmnCPVl5WGgruQBY+tFoFF/qgJFFyEE8gdNPgnbn+85qWN8QofkIkQ87hHjAfkpZjXuGRMDDT3ZUQOA4xeMe8bkgbJJXS+KGCnjGpHgEvIRKCob0YxrTPkR3qprms4N8GY9su2rNAOVNAOVNAOVNAOV9D8yizfx/iRoOAAAAABJRU5ErkJggg==", rightArm = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQCAMAAADQmBKKAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAABUUExURQAAAOQAWPj4+P+gRDy8//i4AABY+AC4APg4AORcEPDQsLz/GP94WPyYOABAWAB4+Ly8vAD///h4WACIiLj4GPjYeP+jRwCoAOdfEwDo2GhE/wAAAFh4JbwAAAAcdFJOU////////////////////////////////////wAXsuLXAAAACXBIWXMAAA7AAAAOwAFq1okJAAAAGHRFWHRTb2Z0d2FyZQBQYWludC5ORVQgNS4xLjgbaeqoAAAAtmVYSWZJSSoACAAAAAUAGgEFAAEAAABKAAAAGwEFAAEAAABSAAAAKAEDAAEAAAACAAAAMQECABAAAABaAAAAaYcEAAEAAABqAAAAAAAAAL92AQDoAwAAv3YBAOgDAABQYWludC5ORVQgNS4xLjgAAwAAkAcABAAAADAyMzABoAMAAQAAAAEAAAAFoAQAAQAAAJQAAAAAAAAAAgABAAIABAAAAFI5OAACAAcABAAAADAxMDAAAAAATGii+R3OCuUAAAdwSURBVHhe7Zxxc9owDMWFoYxuXcMYpBt8/++5kwKJ3pNjh4Zx/SPverfaUuxfZCeR43RyuYhcUFzBRRPWeZ9gu0tyuciKWkgJ26QeZLVa8SGy7itks5lDZEDYfEoJagg4z7PuqTebWUQdkO/AeBAI+hc+ARHl6eseAIQ96ATxFcRrDlhcK0/vI5tNSp8nUqA19wgIikd27K87g8FF0jwgO0GsoyEjB+7QJtXaAclsID4cB4UjpEA0pAj08Aih4lVFQ/poIJ6krMwcIiCaQ7UGy5pwaLgvc/d4lc3UZ5rJAn2moZw+1Q5N+tyz7dN6WEOP0gJU0wJU0wJU0wJU0wJUkwERVe7BBE+r4I8VfHzFjOqA0CWTX0FWyh1wRvnywgRgZn6U2sgjZTI+nwVSi5zAycsLEbH/FCDnojwZoN5HRLZbD8A5rhIxAZddkRSBbNXwjQ4R2e12N6ItAMWkOyz02FwiugHhEd8ISHEGIIyQHY49ltd13B3qCkQxRqAku90QIQ0QAa1WvgeOGEfoIvL6fZTIDDTq8g2BlCfJ2IiFM+ZJziN6kde5QLKzIF1LOSAo8wiFFYl8HyfSer5Q+YyT4tx4zOysUZEvAL1+LwPxhYqye9CuQjEuDqANWTFCHCCS8tArtZnSOfQ61qB0PGWgcI7zpBEabfAKNGoPU+IRKjVZB3qyrnPoSwEVI/h0fSGUTgtQTQtQTQtQTfZaOFNZKIYyV8QGwSPe9iDfzOQHIR8KZihzhfz4EXp8G2o4wbxc5OdPZ84AiMi780iUwnODIg3Yf9SA3t5c0WocUQcECzHl2XsiztmRSESSJ8oCYftM5GOsQ7bZENH7+/t+FEiPxpAkAOKAW5VfiKckAWjoQZRHiRBo70LEQBdpGggJA2UXvu53JcIGXQ9dhDbidyUZSAfFm5vmFwDxNRCX4gEI7REIeAIQ9RCAMGC57Sk8ITbDyk3/5UG3WeuBaIohkPIQUHEOafuukAMiyX6/33tGHLEAJMgT+tN5yiHzkp80ZCTZd0S+ijpsGrjukSfIXuWMu+hNqAwkAYjE7Rdc1fqml/l4iDqg3pzxM54iUPOrYGXpTacEZERwYwySvX90ZFQYgCh501tzGYgeHUGlIb9fUgHCKVDwe5gyD69xTfWbpUqEQFP9ZunLRQjyoYomO87T9G6mez5JC1BNXxOo/rD0VXwf5zIfHx+LocJJbSLp4HxCB/Z0G35PlF+yf61cfhYaUDocHFHogdq0HNzb6BM12RV3p7IdDDKgwwEeb+EA2ScfIoGPOWWdgEg3FOF4za8C4ShRB4Qu8vt3PKW+xnJ4D5RSAiDdGAAAy4h9hcixDCSiQeqrfickkn1Kw0km0Q8nC0D8mlkwwFpzPI4S6TIoJfGTKAJBkMOqaA08F3nJRAjH7Hg8FYC6DopAfj/R/Pkyc6W4K22rhvuBBgeNhgfS/Vbp9+8qF4mKzcRTBeK1La08hYHuF4dQjkeG7hVfWNlC1a/F5wOh5FSKcTT8byA5qUZbyxjCywKb1BnHT8qIRpvLGTig/wFovLVxi9OwJf0Q8QmDCianUgsP1vN6mqgFqKYFqKYFqKavCYQpYYaSb4xQxGPZmqnK2AepscupXcrIR4RPlHx6ZV/twWd7LR+PTYYTAHU5tSXVNyKRD/TXBhyR5leOSGTbtuKIpA0degQRadsM81X2lv1K1DmJfHx4It168SmlxgdD1GoHg70V+fMHOqQJoe6jL9uvKawH+sAQ6caC3+wwQBiCHBAQ2eLWObTStmNE1yFzyw7u70Y8lHkdJG27df39Ef3hEA2rW2mlUaY8keXU9g1V7x/2u2pAW53XA5AGHSeJrE9r/2eVun00No20lpP8ALTCCt7wih8S2iAORdXJzyLlKQBxFW+whRSvWgagLofGFxKjPDmgeB+6W35AulXGyQ1Z5hQGjdXPlB+fkyEV/8rPaaLbHHUhWoAKEpnO8xSg0hwOmuz4LC1ANS1ANS1ANS1ANXVA4U4KxcyyBVM693uuTE1kzE5mFZG/6ObTB30Di39FQasITs8aTWKD/wBUJFJjXLnB8Tuzu7eM5E9HW8ZM32Tpqm9YRJxLRJbk/8UA4Zv2rjs4Q10X+f5gb0eaRhcNjVs4HQ6HlIZ1X0iRvcTc5a8j0gPi9tEQomTfpKXUW85n8L4uYnqijscBnUtEHdDBhahbdUSgW4iSLXtkKzciOZ9hECRJox49kL46cLuoOmbc+qDpQLcIpW0Xgu0VSM7HIwLZp6D9zBIdLnqZwXPWKQJ1Q0YHuEl9XeprCLryEfcHu2/ghi/3dAPViFwPBSK9QnEPuPN3RasZUlCbQQNP2K/UT3X9nLYdXdiQ00EbHbXr9tSI9SqR3XqY0+Y/AMX7kBG5eGiI8IzPNO2cRqpRstu5dwW9+uuMxNc1TCCrSOmBQMkusmFSZxRihmW7bB4IxJf93YqvM5zG6kG4YcY3xvvFY+o1avDS/4zFrfSUZQaOjSHX9Bq3OBHQf9W0bh68pVjSxH4KMX6wntbRVC1ANS1ANX05oH/P2YROx3frLAAAAABJRU5ErkJggg==", leftLeg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANgAAABgCAMAAABIZ0zHAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAABXUExURQAAAPj4+OQAWP+gRDy8/wC4APDQsPi4APg4APC8PORcEABY+PyYOAD//wB4+Lz/GLy8vABAWP94WPh4WACIiLj4GP+jR+dfEwCoAPjYeADo2GhE/wAAAKxy7+MAAAAddFJOU/////////////////////////////////////8AWYbnagAAAAlwSFlzAAAOvwAADr8BOAVTJAAAABh0RVh0U29mdHdhcmUAUGFpbnQuTkVUIDUuMS44G2nqqAAAALZlWElmSUkqAAgAAAAFABoBBQABAAAASgAAABsBBQABAAAAUgAAACgBAwABAAAAAgAAADEBAgAQAAAAWgAAAGmHBAABAAAAagAAAAAAAACNdgEA6AMAAI12AQDoAwAAUGFpbnQuTkVUIDUuMS44AAMAAJAHAAQAAAAwMjMwAaADAAEAAAABAAAABaAEAAEAAACUAAAAAAAAAAIAAQACAAQAAABSOTgAAgAHAAQAAAAwMTAwAAAAAMtaCmjnQuhBAAAHX0lEQVR4Xu2bAXMaOQyFZSAJCWlKQyBp2P//O28k2cuu9B6FAzIhw7uZTvuktf3ZZlmtOelU4rK/R0kp0VKx5OhU4XRmn0HWskwmFExKQWR4JjQ5mSqZTqNlktksWmdSAzO0GGxcebB4iS05mhaYqqJrXLPZDF1xshxsqlwxpJLJBI0Vc3UyKSW7mm5g0xiSUi7FpWDW7QQ2b0sJuHzrRtv86LX0zCW2wBfi6qRuk9irB32PJncKV1gHmpItAHe6b/I8a2eStG2VO3CsNFQ2EXygYi3FAO33POLtOhYdUHD3DJQ1dFnx3tpAecZhalzfBuxc6ifo8l0N9bW9faFuYNemG9i16ceD0Zsx9ckNHHkuGIGmC4Zgn0g1j4xSI6AYswtYnRadJtwDNE0wn01nlmfxL1AvsVKoPhhGe98EodCeb24YqfnJBxqAxZBK7u7Qc20tP1NACm0IdSF7CncUkPv7g9EsQeSBZMrd3d1dCsl8rgTR9jcD2WZcta6LrkoeH3NA7u+fnnBLWQ728PAAc0Ugmczn83k0KxhYXyuAwGhEHh7wo7E8Pj7miNw/OVkMIPVggKxf9nFTYlwATEQWC2TDQtN7Bd32V2T76UnBog+lWTpzuYcB1mhQjgXIZKGKLi3HnCv3ywpc3Ym+ZDEApe88SAdECNZ848pkJJ37bCL0E2ZLFgJY0s/cwWREbKDHirXT+zGAtXvnceAF16KfRTPQDezadAO7NvVg7KZI7Hb/BV6weqEQ8lR2s46mifYQAv53v+kP7F7E7r9WkDn2mlCEpXuVACM08AzAajs5n9jsEvn16yWZNZSzu05+/wZuqxJwBPudPEOw2QyWG7L8w9rxrqP76+UFkwlK7+Q3LnNYlUC6rVzBsT9msCVZLgmZdgCe5kQULLgWeYEBG2c0tR0dziuKvL6+It9K1uDYH/gASMGWf5KtAMoVwWz0cPweSQFrJ7k6eh1QBhDjyr6BpdFo/gxPnWAy8vhduTKATVu26XTa4MurRAINSHJdeV+JH3BLkXRmaljLPxGMHQv57SF10N77JITmp25JQ8YFeHeXjD0+IOPKZCyfieUTm8pydc3iBSLPz7lCj1k77QbEc75aaDD9DhpvoZR3dSILcP1gRDewa9MN7NrkYPGWMhDz+/tRskZGE8jdH2B2NJgsUVYr3Awf6O42C7yh9T8D3I4WUQPDZKR5VSvIhlFhv9HzqgW0JPM5skmZs288UZolYmQxpJE30pA9l6eYPnaibO1hitrZc2yzXGZf1uvcKZE+3a9cOV/e3t5QM+28JYRECJn9YA752g70IZeCKVq0oaTnImBvya5YaUj+O1gApusFwLydPE6rM5fZ13aMLPpQ/Om+gUUydoxUuTJZ/YFjJCPT01cV0ff1OmLF9kikZDI2EdSvXAkMp3PfuQ5dsj1J/uqhRLBj1Q/0tGYG7RzUEE/qK99c5F6D+JgHM8STvq+uccwH6QZ2bbqBXZt6sD03PxJgdjSaYID36rflaLabdbSTasa+dBzBrj4gIJdNHGulHxJ2s5/kGfR4hiITu5OCwXC6bJBrwh3YcU5ykSrYakWeL1jFNynp4MZGU7RiijZbGdlsNu/ZVlWuGNQrNtGEsiSvXGA+OYeZoPMx3YZwOJ1s8m+s1H7fvOdkE26InEchaZK2QMDkAzRPu13Xujr4Os8QTNvBKybTv1PUkJ4tZhvJKuh65BtjylU+Pj5yQHciXLBS0GeM/OCvE3l/52CxzmkTujloybSCLmL/5SUT+VBlH+/ETmRdcr2kY0EfDZF3/YwhMrIjXIftRelWjqWv4EJIPkopiAv3a2uWC0FbLvDjU8Midw/biWHFWq+456Thq4HQkGIhMl+veB6l39fahr1IGvmbzWYhspAIhrv1GAA7UvxiCqz/A7GjjQF02VXhju8rpmy8r7HsXV3q90gdf/EAeAy2lrWV2+u1jL4hYPYeyVTXS++KMXKMTrp4rCHxCc0al4GdtBdPufYyOs/0fEewuhH/3lYMavz591v2yBn8YywWIT6xVSSEbexmjShK+QwTxcHYjELT54wIh2jzyAUag31+yueIKz4e9WJbBbv1ACi6JtgQ24tStsBFGoF9KtjnIWCCz+vwKLtO6HDEvtWTW4qdRMaQc0UXagQmomwHkJFzLQYm2+12m22NvMCfYmqVsEI+bh9pBKZU+ikbWAQMnJ6YjzvWZ+Mt8GnhaJUvsIuuWHSx6kNwHZSB/WPFLBeebHWyQPvKVyw+9FuP+AeOOhRIxlc+S3SdjMWq3wAGuOpTPAazijW6dUBpRLoN9ReaCczKeT3uj76I5GaIDMzuhfYA29SiEMwED1kXJVUneoEWaYnMuUpJpb59wFaiBfDY3+pOjM0w6VL5zXAov5Z8YHaKIY3FerI/iYwjYs30vzwNe7FlHw42HGqThdibECrFSi83Qqv/1CB/DLZV3O0xYFitbIw+le/mBHYuYVwqnnVUM5q/8C10KbAjdb5B7Gb0fG2eoG8xiEvox4L9B5zQovBWSOLMAAAAAElFTkSuQmCC", rightLeg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANgAAABgCAMAAABIZ0zHAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAABXUExURQAAAPj4+P+gROQAWDy8/wC4APC8PPDQsPi4AORcEPg4AABY+PyYOAB4+AD//wBAWLy8vLz/GP94WPh4WLj4GACIiP+jR+dfEwCoAPjYeADo2GhE/wAAAJp89PIAAAAddFJOU/////////////////////////////////////8AWYbnagAAAAlwSFlzAAAOvwAADr8BOAVTJAAAABh0RVh0U29mdHdhcmUAUGFpbnQuTkVUIDUuMS44G2nqqAAAALZlWElmSUkqAAgAAAAFABoBBQABAAAASgAAABsBBQABAAAAUgAAACgBAwABAAAAAgAAADEBAgAQAAAAWgAAAGmHBAABAAAAagAAAAAAAACmdgEA6AMAAKZ2AQDoAwAAUGFpbnQuTkVUIDUuMS44AAMAAJAHAAQAAAAwMjMwAaADAAEAAAABAAAABaAEAAEAAACUAAAAAAAAAAIAAQACAAQAAABSOTgAAgAHAAQAAAAwMTAwAAAAAOJJdZHPQJXjAAAHi0lEQVR4Xu1bDXPaOhA8Y/ISoLQpEKCB//8739xJsvHtnjAJZEKG7Uyn3fvQrSQrkuXIUQxHiobzkfuxCQKOx8mEWih5FYgJa1vWQtOwQqOOEO5umEyosOmUkFeCCWtboswKJaVWhaH7UURloTKZTm8rTP9q29a3myolgpMyTxqtAcySdHmTTKesI66ElFhabdk3YkPpycwTWrtCA9Akmhxj0uT17JWQhfHJwnUpD74J0ra01jzbff5gsl8FWVjG0KTFQDVdNyDflQq1Jl2+m2ir10IlaxLmq+kL8vRJqd5WUmGum6HSUlTlB9ClukKukfi6lr4YD2H3hoewe8ND2L0hCQt+vnA2cuesIbBEEQGtGP2j0NyCn5xs15d28YSOkii4IQyI+BwTGgdQL+6t+76nJ+TpZrAiOFIQ7kTOGLgNIJ2/txyleXoiyvg2V9NQOi5UWbLHTu7/BbyIPD+DjSC9GuBNiwoDZSaASQjeDVj9dPdrhhe0qC4UVqTNZqOUmUtFGDOotPmc8IvFYgFsOYx5Wi1t+/LClLUtE2aFzmaz2WhhGkEa6MYSLXOF5yUpQ2871gGtlhcFmKITrjYxmz3PIICgCLMGnOkEQ0sW5qWZLhy08FxXhPmWU0cMqII0YGPmYkVYDUXZ/DQm6IaAjk3h0T0LG/WUnQrDORGiq2h0xHjUjtvj2y0OeVKc9f8CjC++hsGIfRNlV0ERdpVe+k74MUI8HsLuDSYsVMcMlUcxMFBSEfCWhth4es5aPLdEhniR4QbOKmKaHYGidkXkF7IqLPujkWdKzUK7ybD8/dsbeJZi8GSnC1qI2lVhRFl/bIEQY/+8eloNLW9AlsslF4buif+LvIKfgJjcZCDKjNCW4XYx63pFZaqLN7BcLskoyHLJ3UX+UmWyMmHeJKvVauVJM8ClYhGmebww5VUXCLNLMGjVLEuDN5lexxn4wGRh4kUkXcRdKwK6F4YtZF2Oj08hWZdXYbTPkiw2LmCSlaxU11CZrAS4bCE58pJhLUy9Vf6YMjdk8eY7P6y+FRXG+s0iWJf2eQbCpFlxZehbhMlUGrzEL7qcMtpqBeWW05d/aiMmhM5NVQbO9u7k169hQUkYrbVnIdUlqGWpmAgC324KDeYQuN0fut4ZztyTf/8oPITdGx7C7g3dcu8NCk7iCtRbPFX8Pdnl8WzMGyIekY8t6zUJ4emLMG/kbNwRAR3ylQFgSMeW9ZooC9KkdudstyAiuJXOhRJ/keGb5J5/Jd5hD3GYmwqDiEoWmc/5Nkj3ZchrngnJpe/JgVT+lWVP9Ww2GzQxqJcNGI5Z2EH24p4ZkjBi4N/LmTBPJmFwpjDedG02zAY4FUaUvb29YZZ8I4GGo6StNFhUGHRSlEYHzO+8iykLYzYHE9bBG98UwLKblmxSXWw6si89u7uoU1J52/DXlI2ZjlWPJMwrC/vhxAQG8sFz5BzxZsvCziurOpgw9vbhYtSKvQRdnrOJ6g5iusaeBL8V6hV3p9/7U1YvuB/5ut83xN0VPBYPYfeGnywsXhoCPqDDbuKstuspRbRUXbiI9bctYKFspWX96cD4wDvKX+eZhUL96HVUmCigFbJpPBX3g/FbtMT50z0VsxCYmzQNbO2Npzdtdj+Gb+7Nne3h4jp32y0qy8KAV9OWBXAkYezQYgYykvkeCZSVgrAkWSxoOapsh4YgS7nNIQaGThjLJfs9YaOW0/gK7rxVGFMmO5bGEk3+wbFUeb1WRJ4iCUtPGYyZ7Pd7MmI2ZDBi9ohRZelzP/Q/ym6325FKZcKEyXJLO5RD3WTdiP1xylTXfk8S8bnYnW9BmD4aWtSQNmHb7Ral8Skhdg9MDBRJ2DoJk6Ey2e+bptljopwfefpKQvSrU/pZra0eJs3xEzYXS6usZYQJCyJEdZm0U7ZcSJExs2UREslCFiILsqDxZiNhl6EWHbRrukyxU2ZvDxU6+AN6saUjFiE1ir/mewk+ENvr9Yob2djRdDN8zLh3Bboq6ph9ZtA+EQoIFV8Im4m2Mn5C2ccjb4erdNDHI28HmYjOxM8tIB+PvB2uNWLVFJSmZMBWDbHFExkRj8jnsaZ5pzGwi0j94DkDZy3AUwlhpjAk4gnUUYW9c2FEWTS8nC0TwrPZwHaiJQKCRORAAxhM2Lu8jxcWVUpJhRowi0KW5FSU0uNRMJGjlekzpqqCqmhJeqEJdySxME1yOBBb+izOswq9ZMWjYFE8ZAOkxeNdwQJ07+c5vQDyV0KlWcdlyOEAZ5n6uTE4+tqQeb0cNmLSDZkvjQ2YnZfyvdaJVbeEQZty2BxwzM4KIx0lB5KIIgtLr3N06AZReGhMtN2x+uebvhIy6FSEMcufMXJl9h0DjpnqInIZyus3rQnXED5get1P5ruOGPl9v1wPXNfpl8IKpkzPvLLGx0wOh7FzUWztSLB/jRHWr1yDSu08yQLsGfPKaI5i06Mv3l+prijE4+S3aiHE//8M8qsNFkHTV9D7DwtKA9Y0Ix6zioe9cxpbikIWC+vjC0IuA5fLEXvk0/CIHAViupqGTsevRlzD+M4p6CLGh9wO36GGm+DHCvsfNQqd+LoFBWUAAAAASUVORK5CYII=", pants = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANgAAABgCAMAAABIZ0zHAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAwUExURQAAAOQAWPj4+ABY+P94WLy8vAB4+Lz/GPyYOABAWLj4GACIiPh4WADo2GhE/wAAAFozMeQAAAAQdFJOU////////////////////wDgI10ZAAAACXBIWXMAAA6/AAAOvwE4BVMkAAAAGHRFWHRTb2Z0d2FyZQBQYWludC5ORVQgNS4xLjgbaeqoAAAAtmVYSWZJSSoACAAAAAUAGgEFAAEAAABKAAAAGwEFAAEAAABSAAAAKAEDAAEAAAACAAAAMQECABAAAABaAAAAaYcEAAEAAABqAAAAAAAAAI12AQDoAwAAjXYBAOgDAABQYWludC5ORVQgNS4xLjgAAwAAkAcABAAAADAyMzABoAMAAQAAAAEAAAAFoAQAAQAAAJQAAAAAAAAAAgABAAIABAAAAFI5OAACAAcABAAAADAxMDAAAAAAy1oKaOdC6EEAAAOQSURBVHhe7ZvRkqsgDEBTXNvVtfb//3YnAS2SgNAilQ5n7uxDCJAj1urFwgMWHlvgYnAalvTLNoxxJ8KxU0Ct7HdMB8eUtBAj5kQXYbcH7NcHdqcCYl4ErcWMHwmf2HpGAPCjcRzhmXj5iLzAYtBaYfFoHEeBqXClSmsVEdOLVlarkJj3ND2Q4hOWoonVRhOrjSZWG02sNrKLfeAmQyRfFebRpOvyDfkOGauAjsg44jvkLIPMcg74DlnrkJ9AP8NpCslNE6uNJlYbTaw2mlhtNLHa8Is5t327t4FLQtoNI8+FH3r8+WENHszjEgu7gRXorXQA6P2pGrjqKa57iRZw48m0cRbt9YDLr7BbFxIbelQz9P3gTzXAldjN09CwNy6WvGLJYjAM/cow8NVmkNl+mgZut9tNGBTMivEWGXPkWdgNPIGBzAZDIHNFmsGHXI+/Uh+ebB55sjELJWYGUj5ir4itH7OyXhFXYJtXxMiMliycdkbCFZvTXToiZydcMZgl+zqxdcnc+PmpsOQ4mlhtNLHaiBBj10QW0BS9gO7OE2hfLvXO63p49y3VDxh1kzNiTwkw7s0TaF/elHQkdJj3048bgnEmYFyONMA4viGGh58q/fvbJJmx7ZDd4EbzgToL+/P4E1AIUMsR0wbbSBlopeK0gmLkhFpsHBYoxHoqug0CgRxjFjXM+QhVTWaVegXFaO3dUC1UW/geTaw2mlhtNLHagPT/iPKkJ49zLIDPUQqmhILgooRtmwdMSqlp4g2f4ZtXDCYkviDPip0MWrFpSjrSRX+59ypYYfIJlJj+ESoo8TWaWG00sdpoYrXRxGrji8WWu3KuKEcD6G0MZ8fFjJE2ksHus9YZVxQ84K7U/X6/82zarYkaRQPQ0bTdpo/Z/uH7Pr4qn/WD/cwB86yUmtU8z6yLAK4YafEJAmspgr+JQ7MO/9lxvUNiRUz8qpS6stHpacNgN1q+bhcJOhXJi2frFaMD7jYJoBf+4E//3ZiJI5gXUoUXHBc1qVc01FUeQSuhWtyGFKHFtksmj49O+N6m3CYfjAT8nckHRkVnUtwkT7GofHx9OCbvJfwDw6jGcVRKu/nzNpCYG/RznFdIbNlbH5V0TfPgXBI/h7+K18SOXIQk/GWQkP6QqehT8TwECtZvpHyjmLnek1kg75yECtbfYPjnu1aMvpf0l1jCxeMshAs2dwCRX7inorqCY/kHOWOCIS5FXqUAAAAASUVORK5CYII=", head = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANgAAACQCAMAAABd9VXeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAABgUExURQAAAPj4+PygROQAWDy8/PngqO28PABc/AC4APU4APW4AABY9eFcELX4GLy8vAB49bn/GPV4WPmYOABAWAD//Nrx+v///wCIiADo1QCoAORfE/yjR7j4GPzgqGhE/AAAAJzfJpoAAAAgdFJOU/////////////////////////////////////////8AXFwb7QAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAUGFpbnQuTkVUIDUuMS44G2nqqAAAALZlWElmSUkqAAgAAAAFABoBBQABAAAASgAAABsBBQABAAAAUgAAACgBAwABAAAAAgAAADEBAgAQAAAAWgAAAGmHBAABAAAAagAAAAAAAADZdgEA6AMAANl2AQDoAwAAUGFpbnQuTkVUIDUuMS44AAMAAJAHAAQAAAAwMjMwAaADAAEAAAABAAAABaAEAAEAAACUAAAAAAAAAAIAAQACAAQAAABSOTgAAgAHAAQAAAAwMTAwAAAAAOV9aYViUZW+AAAQ8ElEQVR4Xu2dDVvbvA6G5YbASmlL+TgwCuv//5fneh7ZiS0pIXsp29g1jXVMdhzflmzHipPK6XQSyMmKpPH3VCXjV5EVjvAHnTqrgPAEQeacECZ9VFC9Trquc4VLGshSBQYkcvFzUENQhi8HrUBx9Re5yOKSPi5yEgVzNZoEW6GmwFpZsLCFMhbR2oSUhWhN0hkkg4mIdSKcV39LBmwFg7madixoFYIVmzX6wkU0e9SHBf7UBa2fT4xf8G8NJmm1WqVkj+m6btWtVtZk9Ngu+26dJCnlHkab2dN/VPJpwy4wglVJqGJaJXyYxuhQivNF8usZmvzk6ikks2f/qLBB2WPsUFBM1hrsJIACXHJtQXtZV5wD61OfUt/3nwOW4FwpeTCkUVoPqsEq/TB0OzA2mo42BixJL5I+D4xuHoANtW1Vq9Wq1/ZvgIeRwGRH9XsA8ER1/k8HY6+xflVSk1jvQm3QPaxpUFH8MWptOXCLVMfIReOKwck/JmX2jLk6jOGu32ift/nnwLLB6oOgQQuRKzr5ByX3iymuLFGqkWlXpNPREU1j0BmHWeXMggmaPdsm8FIrdV0HX+ysHbwoAD+sfpQmRQdcOzidS3CtGJySJuhEUoc2xS9BjkZKz7PVVD3T3ivirDJ9MoUC0yKwU+qlR/Mbk+VJOOqVnyozJ5MRbIkr6tgdjB6/hWsODGSpS+Cay5VlEuwzF10zMnc6XvTjun8uU5Hhum9J5l8gs9XIk9hsniJ5kPhTuObBpgbMUPJwb9W/S85YkZ9ohF8gf1BVziv/wL6aEGxqnol0KhNHRLoyj1k1Ss/6IBFyadUTBYXCa8UrijtGvn2LSxFZU+xlIS7T3RFyrWITdKmHyV+atPF3AzaESGxJochJrq7StbJ5sHBakpTW63XCZ1Mjrj7saQtXZ8i4XMnzZJ0kl+U3y1UuzZZdnAnsdX0tVyldXV3ZxHBJwSrRYg2ZbDZwlM3GtrNKZ8iwJlWwbhGY3NwUrpsbOnGd6kUyUgrBIp/WFeUa7lgnyibJhmJNFpNli3n9pR7iDHbT3wwSRCaswBFFrnDZ4MDkm4jvZ2owNHfjibKhtQSAdXat5vW1JyBXSl3b/eTykna8dGCQDAfzLQLDj+tj8i1Lo9aW5lp/XSMAa4OSAjBiGTIakWsiM67IZcR1kpvtFkz8pDfOC7pYSuqOhquIA9PgTG/AEmyWPJhcq8VIVoFdC1bbqXed7/KSXDaCdCNg2orQau9x6aiYpU3QuBn+GjJCSZJ2tGeACikGDKMiR0YuguqErkPwza0e5BIiqbODR5ItuBLA3uXy004R2ErrKmbQL9NJM9YPozHs1ugHMQQlBmZrICCDi3owXcou8MN5sNz3AjBU086TJZhjR8WxGOtbMRcOuGTf++Vgahx7oGxoMMvFTokgD7hNQryIzTEGiyw3cFwU9EEwXThqoNOe3msyLsZFr9ZrIZcyMclKx8C3Y5YbXaMv45oF06HDjB2TosO91Q5gQdKEaG8NfFQvPZZxzYF90zjtQq4pA5RIf5gWy1Q7CCfpKCWQmVxKtphrUgJffkemDviZkubysZy5DH+yfNV6vyv/wL6a/AP7avIP7KuJguVPQxnOY6oLk5hsFSoT6vmpOEgJlUOtGg0/ePlubwHJDrl3lpb7AvTquE1h6j5Q+qKziNze3t4G5Wj84RAleB2p+ru7tjFGMP2ojpP73W63u/85sIdAOVmf29uUbu1Na83uTJY1ReqETvrHx/7u7q7eLsk8ki6Ef+sKyP397h7SnlZXURNrqQmwYfVT10iSgItgrvEOgr+N7pAOelV+SIcqSeRO5PGx70kmd4UsRzYuBNuZ2m1u97sQDEtARjptdRA/2T/sxXUojWnJHlLXiFxwxVtzisAu02B3Iv1jB1+kNxYyeNXFRbpI/GlKukcfu7+3nRJgukfWtvODEMxYDVh72Sta3XC3t+SiGIQCUGefA8OST8SAgUz/GC6Qgas1GXfrhK4o+wzWDCA5Dsl/GoONUMZkAj/kIQ1YK6MeHQMLuMdHcA2dDP8ITIat1O3QkXetgW9UZzK9mdCSxWAnGIsWaxzxJAASYpkT0wD60ehhsINK0w6dPMJeAKsHDxZ1wZEDO+3G/ADjjwUrXCbcUtrS1OeEvqXWaoiHrCkBb9QfCMWNFYdmxFcbithpQDKYDviDFn/zXswWjJEuuETby/Jmdmwgazd+w1oPDw8P+4fGMiiJYGylRq07rxLtNqoZzNT6HJppgnHaPtGUo5Ypj706Yq0bykrGYrscg9m14yI3IvG8XVPPGbAke3ClNr/GNhCXa8YO0uS4X2OxvLeRQWhrMwz2GPdrHQ9R00g9esguR2EiMAazrcVqaRIGC7RgGpTrDRjJctyv7UvlpoHf1qTnbLjylQfP4MEY8N1ZV9TApQ26owdBzGyVwdgSdrDJEeWWS3sZxczQeZKPLrbYO+5aFT8UoR3u1WS8YKzUJOs6/DV2IRGg3AHaWXvDm+8pOy699BNpxz4lYyg4tWMKBVymdP2MYtZFrD6PiiaiiUEvY9lD1Kd7e32sI31wDaxgrphSzuEQpRgud/mzQMrdBAcGZ9Tpp0lRj3BceYp2mZnky6jAoiR3QJDpXcnXwUaZp9UoiKu8Vpt9wmpnhA208IhluYxE9cnTamSw+ID/InEDhbIw2/uSx75gEXJOWd5AS/O9K8O06paNv0fOVgudgScW1r9BzlcLEfnfz44Gnyh/SDXOL383mC65bdLMKG1jcjlvEZtWEq16apCbyD2T4EWApb86NEnpKRzjotIxcCBct0s7l6hP+/kn77gXyeig3u1QmE0Rke1WtsG5I5FTgsH0P3a9lJ6e7AqB+rDyJcC229kgqz5dbB5lJFe7VbGogYVWMrm3W+llC/HHeJERy4M9TYBFDtGAmWBCflbYPoYbg8lOp8OdKWXbb/UHhO4oJwKDDf+zZJycWp226M6ZbBqMj6vuUZQnC1yR1y7wRGN4XK5tedG2yBsBlsPWHkzP4nRZjJaR/uKKdZ1Q+v4ZcQ+wN8cEBtPwasIyt2kfoa3yp1tjeeFyHdkiMJEn/rRKdgFnskkwXGmlxIApjVodwp1xtoF0Ty0W3M0pcCi6F0eQJWCAKWCW6wkI6Gi1spJKPQO2YlUTqto8O617b9sN07mLoQ9YMA4bHDqct0TyDtgTpQHD9u2Efc5mW1/pY9o7hjSqStCjNlne4r6+NuXsEGGj27auWMiWcc3PYwWsJsvVpzSZOYlRmrtqGUxt0IBdE+vabt/nWpJxPzO2ZldMC/xQwSYqKpLB5Ompro+ktazx1/pQK4N6tcKzmwwgNuOirLHvFIZfm03QGo9y81gJUi0H410MExHXcsiF8SMNRisetDY7TKdNKascocRz/1UDlactMJ3V+fUCz3KNC77lYGF9VP1E0z/J6IwofM35zYKVE7s5XQfwJKl5icI1yBiQMiOjPgBvR91TtrsLT04IbyMdBLecgkAe2Ag2poz1t2BDANedWBfWbYJcDz1vfV3pOb7ijy1FY3KLgx7cAAA3ZES8PeZJX3KAPjYqh/qv13VeplCWeQpGV52vbAPlgoyOak2z+lhwRxPBZJykvYUIMO0bLVjpY74++qqHxWfWF154rvOIgqlvHUy8ogTX7Qyd+3ylyym0r9dPyJp+5RvoPMI+pr5lbxWW4Lpj8JosEz40IRiDAsOfSaQEjqOYuHaaVndGUdNb7ZlEwWgbNyp+aYErKtjfxaXXv/E9kq8tpPncrvR75G/jGUTBQovN2HFCP5VfR1ef5jWQnHtx/ljUFdvtSTnl+/Pz8/eo/JMkd3uSFUph/IgPOfKpVJMmLz4zV9y9vt/Ppk5showFWbFusZMzuFIC2Xdb2kSDynaboqCfbI7H4zF64FaOQTHVYsMmydFqZoRgUTlCLoBZMr8vitocaLFkskH1AzKRl+OLeKtJj/UbX+LY6mV/xElt/gkhWGixZ3AFYBMNqguxBG9s9UduSTseN8djwwU7Ho9HR0YwvmyySZA9juAd/Fo9KcwV1FO72PN3gDVk0un7gex+iGIx/DT6o3Sp62iyNuHleDy+yMuLIRsbrlkAoYGO2PG40B8VLB48ICLyvVkRY08gXlTlN7+9vqbXV0mv7QJ6tJjrYccXGMyB6fLW7g84IxhtJcmC9T12F/f25UeS5DW9SnJgQx8zJxB4IdIM2bBlzYHRFY8/ATbYvk3RlnNgw27CrgnXafYALI+KtngMHi8vIGirmuOrgSuWTrkYTBdifjWWW84MHgOABXvT9erbq22gLC7EUxrOgVF6+wLBTCb7ZSaTYUzEPwbhLaW3CEwX3MYVX98or/a04wFOD/XLS1tRWTGktert/AwvPIqkpWCFi5Gkhkz6tzfHVUXB7IPKr6iQ4xqjP17fp+THjgJmXa5YeDGYOmHqA2cEly2fowfWpu55XpB5Lp4iuoqUF5RkuTgh8l2xRl0sHF7NBcKwG/Z0Esw2UlAf8r6FKaFyWjgMOa7SKa0WFzzwFHfJMyH0fzQEwJYdcjaJAaYk36zYLzwEYLDwF1hDi6QjbvlafSzc8I1A5881328R2Ufx8wnRbarkOriB60+T5UMHwA4D1p8PtviCahg8iPXHg0WzxpQQLGMtPugrCFzxL8TiteLfiDUsW6z660tBCuC8pohe9PjkUDlIkDhVEMRom3yTB42S0xG6sVkFwYvgxJjTw3uXeYXYKgeRlf2GEL2lrLfgmgSmmZtazbrHL4KcaLqu+GxS2opsU0omOsMHZyD2eRiC+XJU8uN0tQYrBL5S3z9ZwyeS2kXUqgHzV/9GmM4Le2cxtAt2wrRkaGbay7e0Dq8TZABrv1RCH87Nz7E2JWUHbXUKpkmrZWBciQWX9tlcbaxwNBi9scmv80YIBkfEt4RUBRFKsbq2qLyatyZDz/iRUvqxwGAa88iLzTYBTQYyROQJpg1Ix1GL2e6nFzGBU2u1ICMYHVG57DNAahWcf9Tp3iX5kX78+OH24EbCxe1zBMZabmExbuks0RhyqbmMxZAjv2Ox0g6J+ZsrCoJiwWzZZCNyuAWKbfND8LOES8GGJmpSOHbgZ0vLlermh9YgLRdfhxndVeEp8tdErcihYIPgCcKBbHhwPSLDt7DAcPYMXgQ3H1JKiNTbcmgsUKlLDvr1Gicw2/EkESqlZMk48jEYr0brOvaWTvq9/il8JfsodTFMos3hjSbFS12MzT2EDRiTr9RrnMBsfxNZbTbchG7ACKJff6X77/HVUEqmsu/VZLkPZ4MFsekT/BBYC7iG0EDUL4aYaXufQV+Guca+xVq7YXMmC4bhcKVG4ygBME5ofKdCfqqTrqi+ONPQp0w1fRFQyTzYluez90/0hbMprZtpqVgXYHVufnMXyfgv8ThT82nVfP6RY6yQr/7oQTbFC0e7yae+GDZwd7w0su7BtD4WTB9UReAYL88FWJ7Ohmo2jfoOWE6yKV6GUdEmqEjfu9vKeFssA1umj2kDGS6QqYuikQoYc+Rq2ne2Di0d9LFyDpfi5b0sAbKs9dI13MW9svf3OKzwm8C4NXsY7kEMlX2eenhu3dxJYFr+zsRzgEWCscNtx5MNRz7PpWh4MSlMVu8KLhecbd4cpwi4OJHhK/h8ipcleZzIerVy29Y4pNs5rEj+ErKme/AK0T4nTpMBLOBiC9l701OyKJOTsFPO9lVdm7RjL41YK7J6pqDpFCvLcn1c9BstzdmWVvK/yOeV3IpfZ36y/LJT8bLDKj9Rft25PtPvAvmlJ/uV8teC/R9w0Vat0SVTXwAAAABJRU5ErkJggg==", chest = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAACQCAMAAACf4EZzAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAABjUExURQAAADy8/Pj4+OQAWPygRABc/PU4AABY9fW4APngqOFcEAC4AO28PAUFBby8vABAWAB49fV4WPmYOAD//Lz/GLn/GACIiLX4GACoAPyjR7j4GORfEwDo1fh4WGhE/FjYVAAAAN+47VkAAAAhdFJOU///////////////////////////////////////////AJ/B0CEAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCA1LjEuOBtp6qgAAAC2ZVhJZklJKgAIAAAABQAaAQUAAQAAAEoAAAAbAQUAAQAAAFIAAAAoAQMAAQAAAAIAAAAxAQIAEAAAAFoAAABphwQAAQAAAGoAAAAAAAAAYAAAAAEAAABgAAAAAQAAAFBhaW50Lk5FVCA1LjEuOAADAACQBwAEAAAAMDIzMAGgAwABAAAAAQAAAAWgBAABAAAAlAAAAAAAAAACAAEAAgAEAAAAUjk4AAIABwAEAAAAMDEwMAAAAACrgCETU544KAAAEFdJREFUeF7tnQ1fIjkMxrN1FuE8385TRF2X7/8p7/ckfUnSdoZBUNbjWVegSUv7p+mUznSkrRaZVzEty1tExd5x7KVnNU05ww9WkAfvdXyRaeBFXdFtyPKWKF0Ay5kvLi5QNB6sJYodWokx+YsBEWofVdcTmuBTEfJGbim3t1k+XQxDZYF/TiYAIsKD9foMaUBVNUUfBKT4tN5A+KhPiWX8BRA6UJ396CIaUuVQS2+GRwLUMopM27xNA/LGHEsdQOKfATWyH10AJLXjWnrzbpJGDQM/eNsEoDTaWBk+6RMa+4yOJjQMDZBu7q27quCpi2DyfT4JYYtQ2/9zhaMYqid19NaDaLL8aKwAddw/V2RGEG89jCYLZ4RWpwToBKTnGhnQiVTNJ3yNPB/I+3yNTqQaDULe44t0KvUQQnlONpxOvXzClwlc0mA9nAFVojiPilMqb/4ynVBNhqzTqdRJASrypq/USVXmFHUGNKEzoAmdAU3oDGhCZ0ATOgOaUAFUpiB+KjIxPSnzl7YX0rKx6aGK8BatcWssxSdW9Wt4jCm5E/1koQR+VC5pRbgkadHCyleAQrikyyguy3vkJiyXS28qGmuaZG8vstEK2q7+SqpdxhS9Ix6lXAyFQMKoWUPHp/JB1oTn8vKytfae+VxcXFiLUpdPQtNb9mZAf4FPZFS7jCktuY7yCVeCqFW0BdTwIM2HEY3w6QGC3aeJFJwmoMJn3x4ENhUfC+jqKnYhm1fsU4C2Ob5EvqWGTyN/NPfOuVhAtU8CpBDVTiOq+w6rlEFXKcSurpolC6HIqe2R4QS69B60FDzg0+omiU/TyPYdAEU++8TYJKDtVZbOpwQ2FJhQ+61TkDU7IUZmiNvnjRkQN77KyyqA/m7wKSG25yjdBmSKmOCDMhb4t/DpWUyoE6S0XPLhq8NHHDq9Q0QXf0c+LRda/QVAew9CMgZB/DkyHQdobIjcUXGm0CqFlnSxlAjzpqgIyCcXCaE2H+5BoLL3GARAYJSGAn4xq4hdJIHiUyFa0vKCAXlL1jgeIfR3hw96kO0/swEJIe7njKgKseMqhdjIFHEHjQxRZZBOmNqOHcE5dqCvARRH6U7zdlanfzIge5DfD5AEmETZ5/KJ4ecTDyYZgz4wDyqAlvxF7PMBHVc8BsXw2msexL84wn7+lPHgW/GR47yZB81rXgT0c8kz2uXyu3UgDmE9D5rbOPHnLpSGoLlFnL6ISDrQHoNdzJAIYR7kXb6F5NP3qTso5aE0k96nkD9Ce+FRS65xIXG/Ur6xFJA9++A3l0Zy5tPQmcmEzoAmZK+TbuJqJteJ44UYVT475yW6vr6+rhK1nNGbGw6imO7Ndr9YKzfd3NxWXnR7cyO+1iBWV4BPobu7O500mjspWq+vr0PQhGxmontfAN3f399HG8s7iOgfTo8PKt3LmsHn9vb21nshTQipxHgJpi8AOIzuoOKmLTiHYnIL3+IBPhYQdpJlAYUyJj4CSPi0AdE/vOAWH7SB7DvU9bsBIe0CgY/qQkxGFtar/IDBSKIY0MND9jPlhhBM55LVWuVwHcK//1pAxcwglE2UCEU+3izqA9rSj/L2IVR7sojQh+imOBHdEPpPqkvcqSJnFnz2LT1YPozroTTEfT6eTwuQHYQoBGm5+GmTyALy1qgxQIVQaO9ZAx0HCD/ZnE67NAFt6aEC9KDbQSFFILOrCtAEQ7j+1/HZUuQTA8nYRNneBCRZHCDVOt7QF9+9zQfu0mOi0KNUTSYAbeOgUwAZPirGAKiZPymEx2vPZyagyk7/8LBsAcVEtuM/djwCT4fPdhvHHFYck5RxCpDlg/7iHSKfRv+BCp/w6PEwIBl9uoA0ocreAVSGAP7148f4nlk5aonw9NZ4akKNIjygO98KCbK7u9ABlM+rhceWnTQgb2TJ8IOeVtsBqBLSkl1+/8Cma5NRiyMsRhnoIMa0eZRPDchjQGyNdCAB9BjC42MbQGmYtyTRfeChvOHQBqQOIvGhnn8oEWIK/xFm8bmxj/GZBsSEWulF9PjYw7OL5BDWzL8joPFv8hxh6Dk33JOqGNvy+ND9BC2hhwYIwVMlK3G9feIMdbO3AKkIq756NEXCBaGVnuyUL2oaUL/+xxd3FwdI1WanahFHVQ4xvNopXxQ9TPH5SrUBFbNx7kniKg3SVYRNiL9tpO9gE6H0+WoCUmbt21ckJMf4mXxkohPwPe0E+RwIECbTeRY0v4lqt+X8zEdWDUhH2M6AdpltjOkDWY+titCegL6tzoCm5PicAdXyiLRJPf//qs/nDEjU5XMGlNThgyXX4mJNST7d90ErbVIOPsG80saJr2W10Y4YlVlrvJ5t4URSVHO5BCshT/q8C1ZGnnT7FsVG1NiNIEtxRSkh2wez0kIh2DsvWACLpXsHCnq5/KaxbMPvaYQLgyu3jnS+JiAKT0/aCa+fFCEHqCoC67maD9EPrA2q5Ut94gbrJo6PJkKLZQUoLQVDNyGei9IOoGHEV06vK8e2CKttnK294LYl4NCIwKfThbBlQ+dlM26iqbLz/SINIXSheGuTYSDHhwEVLZZL/w7qhMsNaHmz57NmQOtZgERtQFsyfJ4YmHZEWIVV3BRVl8ABpQnJPUdNFxpwYxO5uUl956C4X0rUuuI8GwM6U2Vdr9aqgAhoZz4Yg2IH76zZwqUAQm/S3QfmsKAVAIUmID8GyekBTikuNIQB/5s3xkHPFC0Ay5tTH4qB6o1bWpMhtAaynfkIoHVYr/uAEGVctASXr4TectjMz/fQzIqAbClTgIRQu4sCUMCnFNCDvI3za0Dr9Zr/e6+eJBMA9QahSOjp6WkRCXkrV7/Lp5yZFDX48M2DOMSqwtm4WCC2+u8gh8/OmecaELqUd+pKZZ0CtFhEQpU5y1ui1Nlt7kEN19ESEFujgPhIFnDA9yZY8eknIbzWTbeOpudBVQ/y1l1Uatg/+dEXx1jnIMDKpXsDizBMMxda8wA9owNhHl3Oy3pjFobpNAJ5207KVyAE6p+/7WscwJQIUISMTIHmEGLPCTxTEbCDiO+YzXz2AfQxycywaD4gbr+3HFSYP/PY/AV81FwxE9q9Ert7fkyxB+ovYZ8mTNPiNDQCmlGHGa4fU54fesPxxYCiThdQ6kM++TNEq3STRvkeNqcSc3z/XOUOJCsdcxo9x/fPVRyCuAfNwvN/AbTDbL+nuf7/O50BTegMaEJnQBM6A5qQAdQe6s2r+jBQp7TTjNw76Bfum2FVmbrkusKmDfZpnX1cpvG8fI+VJ70yROG5cKMQnu1bZJtXcTD+kqa/LhJtTC2INpclvzNuzEtJG1akTnPhDMlqhZ/4erMplbqzxe0gVzVeVjRLi3a3DQhaQvXfDGHlS6YNi5JWEgk0lPASd6ZU7SsZNzUgGlbldvj8BxUGWsmUMGUphDazCVlAIWBd8dCAPCHPhztM0qV0INxPUOy6A7T4iMrX0UxL7o3vAG0+BOj+vgHouYTYMz2H8OwBtQipi+4rQjhHoMrn3lLEcPjGgtFHEeK2loLEjHAyXYhWK/ShBEgTwrOZVyE7QKDjVu+BhRE94wG/VBbZhmCqB5ldCRZI9dLgkQgDo4yCW8Vq8dkyCsI4FCUBJj8MSBHiR1/CuNqATCGAkoR30ba0TyPVjuW3bdBLeMkv6cXwEUKKUbwxrmoJbV439PpKm81rCxCLccQnqaQMKCPmR1/AhAwgnH0eB+S6jwAKQcWZvLL7WhShio8EWcqdwkt/0gC0QeteX2s+chDLf/5NtEKQpa2EkBCS3z7/hEw7eG9adf5HYivGmDZEc0ISJa+sYyZkOlO28h1e5fCFp+ogL3YQYj4tQHxqn5Hg18DDtToDKciQP/Yjl3tK8C/os6zPM9HbGw9AreLhf3EhtwuWaHN8fOFVJelys5G7mfJjZWY2r+hA3sTCCDTg3Jms+Ng/tUh3mQ0eZg7RAOTqHsch60RvIbw9U5NPHKd5LpC6ksvuLgBqXOOUCLUASXSBT28IQbGLEPR1MsoIQrwLggdpnW8XqTOrLGyuvrdTaXi9Be5CJrGImA8oxD7kzHoqxR3N2plQCrCKDx/GEqBOA2lFfHEJJtCrlb2Eht8176Np5x+Ru68A6o/rYXwbOMRskpJMFqWgqv+4LtTkw9NFfM4NPnKklgDrtQ+DDocYDvH+GiO9Xa2Tf0Q7AkIlXYrW5MbnF+KxmV4aRbPKbMVbWHyo94lKpg2+jEJorIiOdgU0oXScb/Pht/mF0n+9+NonxVlcz9qNrijC4By7z6jjXJkxCONzcwyaVinEW0T069fLy8uvX/VBPmksNwh1TaJSgQnHmcJRTN8cpXkUO4TohTVS8GjbpgFhLrQaMBPypg8JpcXbfoiO8CGIpgsetY7ZoGMC0oRGK3nKKhF22BZIaZnQgUv/BopAjkP/O+hMZEJnQBM6A5pQCxAPRdWApF+a4cr6+WwjB2+xuAxVfqfGSNlLahRfOU4K/lxWGqUJaz/86+3NFL1W30nWAdfmR8NgNkQNg9+v1Pj6yYoGd46sOgdiGxVvc2HsvBPHcpDdOUgz35rG7wLUFIpgFoASxS+Zki4ba+1J4BMbwht1irBmZQlR8CuE8TO5lMqaC+Hfa0CMRL9w3znjSlSa4rIkifcv0XthQuH93ddkSpT4lP4R+VSAckMG2fAQ05lIVgMQLzPbenFaSGe+1u85+3u1jSLe7yMKL+yCCWAAjlmTi0lM7b2UTu97AIpAyopNCBGQCzJal11versDQiwSwoPng7fgZTCtuPScHHIT0BibGVGhbuQpfDwgqOpAWPw7CCDQkHU+WRMMIeQIM10ImwGli1QDn+xXkt0UdRNlnVApJSSH1IZm/VGtiAh38WRe2hzu8WMjLCZJ3GlAVeUmFYdkGdXStQvMzPcg3m47DCHUKy60WODcXWc7DoqvAPFpbkeoyYfz5/sP0Z3jw4BkAaIoJckgpNV8g1HxGESBfzjQ8JSf86HM9RQ5LVd9XwYgjD2d7TjA7gAR/uamGj3faVgDk82YRHdBRh/uSs42EWIaUOcTGBUfxVKQoSX8lFPEqn1jiNVvIoQ6fCA9hIKV+5OkvNGtHwASW/y7WjWdGqS3Jcbe9wTEjKXXxBDDMN0qKTr75MSu7lpFuf4SXs4a9wT6I1iWzH6qI7zY5Jieyiei3/owX0a4/QixfxmBouzgs4NIYmwkFw7rEP7qau3GE4cuH3wsMgFqecgR5nfh8/u3mijiExVCYeAYaxUxIgVIetB+gGKk+1QlYjTyq+E3mT3Kp0OJiug3pLy534DMIIB87glJGW/lMJZCzDt+WCAkf7X38GUDEvoN/2ZEahIhoYW+s3eIbeXYxXz4gHYMQHK7TnVwP6QwaQAgji7uTsqWJxF78EmA+NjFcxM+6B8F0HQc7S8PyLxNjLf93j3m4E9XJkLH43NE8diThiLH52PKkQo2/J1Mvqc6t5MXqOCkgwzRBzyvl0vCtBl9SL6FWac/QHJhilwAdtATn6WkjwTq1wvdB4cAOXs1e1msr8OV9MVS9/6fv2w4ogMW9cXK90Gaf+XFmA5Z1hfrOEPEQQv7jjoDmtB/2kFLto6lxHEAAAAASUVORK5CYII=";
var Fe;
class ImagePartLoader {
  constructor() {
    re(this, "LeftArmImage");
    re(this, "RightArmImage");
    re(this, "PantsImage");
    re(this, "LeftLegImage");
    re(this, "RightLegImage");
    re(this, "HeadImage");
    re(this, "ChestImage");
    xe(this, Fe, /* @__PURE__ */ state(!1));
    this.LeftArmImage = new SpriteMap(leftArm, 2, 3), this.RightArmImage = new SpriteMap(rightArm, 2, 3), this.LeftLegImage = new SpriteMap(leftLeg, 3, 2), this.RightLegImage = new SpriteMap(rightLeg, 3, 2), this.PantsImage = new SpriteMap(pants, 3, 2), this.HeadImage = new SpriteMap(head, 3, 3), this.ChestImage = new SpriteMap(chest, 4, 3);
  }
  get imagesLoaded() {
    return get(pe(this, Fe));
  }
  set imagesLoaded(m) {
    set(pe(this, Fe), m, !0);
  }
  async loadImages() {
    const m = [
      this.LeftArmImage.loadImage(),
      this.RightArmImage.loadImage(),
      this.LeftLegImage.loadImage(),
      this.RightLegImage.loadImage(),
      this.PantsImage.loadImage(),
      this.HeadImage.loadImage(),
      this.ChestImage.loadImage()
    ];
    return Promise.all(m).then(() => {
      this.imagesLoaded = !0;
    });
  }
  /**
   * 
   * @param imageBasin ``JimpInstance`` that contains the part desired
   * @param xPos X position of part. Goes from left to right.
   * @param yPos Y position of part. Goes from top to bottom.
   * @returns A ``JimpInstance`` with the cropped part that is desired. May be blank if the coordenates were sent incorrectly
   */
  getCroppedPart(m, g, w) {
    switch (m) {
      case "Left Arm":
        return this.LeftArmImage.getCroppedPart(g, w);
      case "Right Arm":
        return this.RightArmImage.getCroppedPart(g, w);
      case "Left Leg":
        return this.LeftLegImage.getCroppedPart(g, w);
      case "Right Leg":
        return this.RightLegImage.getCroppedPart(g, w);
      case "Pants":
        return this.PantsImage.getCroppedPart(g, w);
      case "Head":
        return this.HeadImage.getCroppedPart(g, w);
      case "Chest":
        return this.ChestImage.getCroppedPart(g, w);
    }
  }
}
Fe = new WeakMap();
const SPRITE_SIZE = 8;
class SpriteMap {
  /**
   * 
   * @param url URL of sprite map
   * @param width how many 8x8 squares wide is each sprite
   * @param height how many 8x8 squares high is each sprite
   */
  constructor(m, g, w) {
    re(this, "_spriteMap");
    re(this, "url");
    re(this, "width");
    re(this, "height");
    this.url = m, this.width = g, this.height = w;
  }
  get spriteMap() {
    return this._spriteMap;
  }
  async loadImage() {
    this._spriteMap = await Jimp.read(this.url);
  }
  getCroppedPart(m, g) {
    const w = this.width * SPRITE_SIZE * m, I = this.height * SPRITE_SIZE * g, P = this.width * SPRITE_SIZE, F = this.height * SPRITE_SIZE;
    return this._spriteMap.clone().crop({ h: F, w: P, x: w, y: I }).autocrop({ cropOnlyFrames: !1 });
  }
}
class RobotMasterParts {
  constructor() {
    re(this, "leftArm", new Part("Left Arm"));
    re(this, "rightArm", new Part("Right Arm"));
    re(this, "pants", new Part("Pants"));
    re(this, "leftLeg", new Part("Left Leg"));
    re(this, "rightLeg", new Part("Right Leg"));
    re(this, "head", new Part("Head"));
    re(this, "chest", new Part("Chest"));
  }
  getPart(m) {
    switch (m) {
      case "Left Arm":
        return this.leftArm;
      case "Right Arm":
        return this.rightArm;
      case "Pants":
        return this.pants;
      case "Left Leg":
        return this.leftLeg;
      case "Right Leg":
        return this.rightLeg;
      case "Head":
        return this.head;
      case "Chest":
        return this.chest;
    }
  }
}
var De, Oe, ze, Le;
class Part {
  constructor(m) {
    xe(this, De, /* @__PURE__ */ state(0));
    xe(this, Oe, /* @__PURE__ */ state(0));
    xe(this, ze, /* @__PURE__ */ state());
    xe(this, Le, /* @__PURE__ */ state("Cut"));
    re(this, "type");
    this.type = m;
  }
  get x() {
    return get(pe(this, De));
  }
  set x(m) {
    set(pe(this, De), m, !0);
  }
  get y() {
    return get(pe(this, Oe));
  }
  set y(m) {
    set(pe(this, Oe), m, !0);
  }
  get img() {
    return get(pe(this, ze));
  }
  set img(m) {
    set(pe(this, ze), m, !0);
  }
  get name() {
    return get(pe(this, Le));
  }
  set name(m) {
    set(pe(this, Le), m, !0);
  }
  setup(m) {
    let { x: g, y: w } = initialPositions[this.type];
    this.x = g, this.y = w, this.img = m.getCroppedPart(this.type, 1, 0);
  }
  colorSwap(m, g) {
    for (const { x: I, y: P } of this.img.scanIterator())
      this.img.getPixelColor(I, P) == rgbaToInt(m.r, m.g, m.b, m.a) && this.img.setPixelColor(rgbaToInt(g.r, g.g, g.b, g.a), I, P);
    let w = this.img;
    this.img = void 0, this.img = w;
  }
}
De = new WeakMap(), Oe = new WeakMap(), ze = new WeakMap(), Le = new WeakMap();
const initialPositions = {
  Pants: { x: 24, y: 32 },
  "Left Leg": { x: 10, y: 34 },
  "Right Leg": { x: 34, y: 34 },
  "Left Arm": { x: 12, y: 22 },
  "Right Arm": { x: 36, y: 22 },
  Head: { x: 22, y: 6 },
  Chest: { x: 24, y: 26 }
};
var Ue, Ze, $e;
class CanvasController {
  constructor() {
    re(this, "ctx");
    re(this, "canvasWidth", 0);
    re(this, "canvasHeight", 0);
    xe(this, Ue, /* @__PURE__ */ state(proxy(new ImagePartLoader())));
    xe(this, Ze, /* @__PURE__ */ state(proxy(new RobotMasterParts())));
    xe(this, $e, /* @__PURE__ */ state(proxy(new NESColors())));
  }
  get imageLoader() {
    return get(pe(this, Ue));
  }
  set imageLoader(m) {
    set(pe(this, Ue), m, !0);
  }
  get rmParts() {
    return get(pe(this, Ze));
  }
  set rmParts(m) {
    set(pe(this, Ze), m, !0);
  }
  get nesColors() {
    return get(pe(this, $e));
  }
  set nesColors(m) {
    set(pe(this, $e), m, !0);
  }
  async setup(m) {
    this.ctx = m.getContext("2d"), this.canvasWidth = m.width, this.canvasHeight = m.height, await Promise.all([
      this.imageLoader.loadImages(),
      this.nesColors.loadColors()
    ]), this.getPartsInOrder().forEach((g) => g.setup(this.imageLoader));
  }
  draw(m, g, w) {
    let I = new ImageData(new Uint8ClampedArray(m.bitmap.data), m.bitmap.width, m.bitmap.height);
    createImageBitmap(I).then((P) => this.ctx.drawImage(P, g, w));
  }
  clearCanvas() {
    this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
  }
  drawRobotMaster() {
    this.clearCanvas(), this.getPartsInOrder().reverse().forEach((m) => {
      m.img && this.draw(m.img, m.x, m.y);
    });
  }
  isLoaded() {
    return this.imageLoader.imagesLoaded && this.nesColors.colorsLoaded;
  }
  getNesColors() {
    return this.nesColors;
  }
  getPart(m) {
    return this.rmParts.getPart(m);
  }
  getCroppedPart(m, g, w) {
    return this.imageLoader.getCroppedPart(m, g, w);
  }
  getPartsInOrder() {
    return [
      this.rmParts.getPart("Head"),
      this.rmParts.getPart("Left Arm"),
      this.rmParts.getPart("Right Arm"),
      this.rmParts.getPart("Chest"),
      this.rmParts.getPart("Pants"),
      this.rmParts.getPart("Left Leg"),
      this.rmParts.getPart("Right Leg")
    ];
  }
  async cropRobotMaster() {
    return await (await Jimp.fromBitmap(this.ctx.getImageData(0, 0, this.canvasWidth, this.canvasHeight))).autocrop({ leaveBorder: 1 });
  }
}
Ue = new WeakMap(), Ze = new WeakMap(), $e = new WeakMap();
const controller = new CanvasController();
var on_click$5 = (d, m, g) => {
  m(g()), modals.close();
}, root_1$6 = /* @__PURE__ */ template('<button aria-label="Click to change to this color" class="svelte-rew90v"><div class="square svelte-rew90v"></div></button>'), root$5 = /* @__PURE__ */ template('<p class="svelte-rew90v">Click one of the buttons to select it:</p> <div class="grid svelte-rew90v"></div>', 1);
function ColorChanger(d, m) {
  push(m, !0);
  const g = (U, Z = noop) => {
    var $ = root_1$6();
    const j = /* @__PURE__ */ user_derived(() => `rgb(${Z().r}, ${Z().g}, ${Z().b}, ${Z().a})`);
    $.__click = [on_click$5, P, Z];
    var G = child($);
    let Q;
    template_effect(() => Q = set_style(G, "", Q, { "--color": get(j) })), append(U, $);
  };
  let w = controller.getNesColors(), I = /* @__PURE__ */ user_derived(() => controller.isLoaded() ? w.colors() : []);
  function P(U) {
    controller.getPart(m.selectedPart).colorSwap(m.selectedColor, U);
  }
  var F = root$5(), D = sibling(first_child(F), 2);
  each(D, 21, () => get(I), index, (U, Z) => {
    g(U, () => get(Z));
  }), append(d, F), pop();
}
delegate(["click"]);
var on_click$4 = (d, m) => m.close(), root_1$5 = /* @__PURE__ */ template('<div role="dialog" class="modal svelte-1g1np3c"><section class="surface-0 svelte-1g1np3c"><!> <button aria-label="Close Dialog" class="surface-1 svelte-1g1np3c">X</button></section></div>');
function ColorChangerModal(d, m) {
  push(m, !0);
  var g = comment(), w = first_child(g);
  {
    var I = (P) => {
      var F = root_1$5(), D = child(F), U = child(D);
      ColorChanger(U, {
        get selectedPart() {
          return m.selectedPart;
        },
        get selectedColor() {
          return m.selectedColor;
        }
      });
      var Z = sibling(U, 2);
      Z.__click = [on_click$4, m], append(P, F);
    };
    if_block(w, (P) => {
      m.isOpen && P(I);
    });
  }
  append(d, g), pop();
}
delegate(["click"]);
var on_click$3 = (d, m) => m.close(), root_1$4 = /* @__PURE__ */ template(`<div role="dialog" class="modal svelte-1aqyc36"><section class="surface-0 svelte-1aqyc36"><div class="content svelte-1aqyc36"><h1 class="svelte-1aqyc36">What is this?</h1> <p class="svelte-1aqyc36">Hello! KFCMan here! For my one year anniversary I decided to
                    make a widget for you to place on your server. Seeing as
                    there are no mega-man themed stuff (at least from what I
                    research), I thought to myself, why not make something?</p> <p class="svelte-1aqyc36">And here we are! It took me months to develop this, hope you
                    like it!</p> <h2 class="svelte-1aqyc36">How do I use this?</h2> <p class="svelte-1aqyc36">There are two sections in this widget:</p> <ol class="svelte-1aqyc36"><li>Robot Master Panel</li> <li>Parts Modifier</li></ol> <p class="svelte-1aqyc36">The <b>Robot Master Panel</b> is a 64x64 canvas, showing the
                    constructed robot master that you made. Simple as that.</p> <p class="svelte-1aqyc36">The <b>Parts Modifier</b>, meanwhile, are where you edit
                    every part of your Robot Master. Each one modifies the type,
                    position, and color of each part of your Robot Master, and
                    they're displayed on the Robot Master Panel.</p> <p class="svelte-1aqyc36">The Robot Master Parts were <del>stolen</del> borrowed from Robot
                    Masters from the classic saga, so mix and match whatever you
                    feel fits best.</p> <p class="svelte-1aqyc36">Keep in mind that the order they're showed in, also
                    represents where their "layer" is located relative to the
                    other parts. The head is the top layer, then the arms,
                    chest, pants, and finally the legs. Also, some parts may be
                    missing as they were not located on the original Robot
                    Master designs.</p> <p class="svelte-1aqyc36">Once you're done, click the Export button download the Robot
                    Master you created, along with a widget for you to copy
                    somewhere on your site.</p> <p class="svelte-1aqyc36"></p></div> <button aria-label="Close Dialog" class="surface-1 svelte-1aqyc36">X</button></section></div>`);
function InformationModal(d, m) {
  push(m, !0);
  var g = comment(), w = first_child(g);
  {
    var I = (P) => {
      var F = root_1$4(), D = child(F), U = child(D), Z = sibling(child(U), 22);
      Z.textContent = "V1.0.0";
      var $ = sibling(U, 2);
      $.__click = [on_click$3, m], append(P, F);
    };
    if_block(w, (P) => {
      m.isOpen && P(I);
    });
  }
  append(d, g), pop();
}
delegate(["click"]);
const widgetHTML = `
<section style="border-sizing: border-box; --orange-500: #f66d1e; --blue-800: #162c33; --gray-900: #ffffff;">
<div style="display: flex; flex-direction: column; align-items: center; background-color: var(--blue-800); padding: 1rem; border-radius: 0.5rem; color: var(--gray-900);">
    <div style="width: 10rem; height: 10rem; display: flex; justify-content: center; align-items: center; image-rendering: pixelated;border-image-source: url(https://file.garden/Z85j0wcYZ0vCXjU9/robot%20master%20frame.png); border-image-width: 2rem; border-image-repeat: round; border-image-slice: 33.33% fill;">
        <img src="IMAGE_URL_HERE" alt="Robot Master" />
    </div>
    <div style="width: 24ch; text-align: center; font-family: monospace;">
        <p>HALT! THIS WEBSITE IS IN CONTROL OF DR WILY</p>
        <p>This is [Robot Master Name]'s Domain</p>
        <p style="font-size: xx-small;" >Want to join? <a style="color: var(--orange-500)" target="_blank" href="https://kunfucutsman.neocities.org/fun/robot-master-maker/">Click here!</a></p>
    </div>
</div>
</section>
`;
function copyRobotMasterWidget() {
  navigator.clipboard.writeText(widgetHTML), alert("Widget was copied!");
}
var on_click$2 = (d, m) => m.close(), root_1$3 = /* @__PURE__ */ template('<div role="dialog" class="modal svelte-1yx8ke4"><section class="surface-0 svelte-1yx8ke4"><div class="content svelte-1yx8ke4"><div class="column svelte-1yx8ke4"><canvas class="svelte-1yx8ke4"></canvas> <button class="surface-1 input-bg download-button svelte-1yx8ke4">Click here to download your Robot Master</button></div> <div class="column svelte-1yx8ke4"><div><!></div> <button class="surface-1 input-bg download-button svelte-1yx8ke4">Click here to copy the widget</button></div></div> <button aria-label="Close Dialog" class="surface-1 close-button svelte-1yx8ke4">X</button></section></div>');
function ExportModal(d, m) {
  push(m, !0);
  let g = /* @__PURE__ */ state(void 0), w = "";
  onMount(async () => {
    const U = await controller.cropRobotMaster();
    get(g).width = U.bitmap.width, get(g).height = U.bitmap.height, get(g).getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(U.bitmap.data), U.bitmap.width, U.bitmap.height), 0, 0), w = get(g).toDataURL();
  });
  function I() {
    const U = document.createElement("a");
    U.href = w, U.download = "Robot Master", U.click(), U.remove();
  }
  var P = comment(), F = first_child(P);
  {
    var D = (U) => {
      var Z = root_1$3(), $ = child(Z), j = child($), G = child(j), Q = child(G);
      bind_this(Q, (V) => set(g, V), () => get(g));
      var H = sibling(Q, 2);
      H.__click = I;
      var W = sibling(G, 2), q = child(W), et = child(q);
      html(et, () => widgetHTML);
      var rt = sibling(q, 2);
      rt.__click = [copyRobotMasterWidget];
      var tt = sibling(j, 2);
      tt.__click = [on_click$2, m], append(U, Z);
    };
    if_block(F, (U) => {
      m.isOpen && U(D);
    });
  }
  append(d, P), pop();
}
delegate(["click"]);
function openColorChangerModal(d, m) {
  modals.open(ColorChangerModal, { selectedPart: d, selectedColor: m });
}
function openInformationModal() {
  modals.open(InformationModal);
}
function openExportModal() {
  modals.open(ExportModal);
}
var on_click$1 = (d, m, g) => openColorChangerModal(m.selectedPart, g()), root_1$2 = /* @__PURE__ */ template('<button aria-label="Click to modify color" class="svelte-qci57"><div class="square svelte-qci57"></div></button>'), root$4 = /* @__PURE__ */ template('<div><p>Change colors:</p> <div class="flex svelte-qci57"></div></div>');
function ColorPicker(d, m) {
  push(m, !0);
  const g = (F, D = noop) => {
    var U = root_1$2();
    U.__click = [on_click$1, m, D];
    var Z = child(U);
    let $;
    template_effect(() => $ = set_style(Z, "", $, {
      "--color": `rgb(${D().r}, ${D().g}, ${D().b}, ${D().a})`
    })), append(F, U);
  };
  let w = /* @__PURE__ */ user_derived(() => {
    if (!m.jimpo) return [];
    let F = /* @__PURE__ */ new Set();
    return m.jimpo.scan((D, U, Z) => {
      F.add(m.jimpo.getPixelColor(D, U));
    }), [...F.values()].filter((D) => D !== 0).toSorted((D, U) => D - U).map((D) => intToRGBA$1(D));
  });
  var I = root$4(), P = sibling(child(I), 2);
  each(P, 21, () => get(w), index, (F, D) => {
    g(F, () => get(D));
  }), append(d, I), pop();
}
delegate(["click"]);
var root$3 = /* @__PURE__ */ template('<label class="svelte-yd2aa6"><p> </p> <input type="number" class="input-bg svelte-yd2aa6"></label>');
function NumberInput(d, m) {
  push(m, !0);
  let g = prop(m, "min", 3, 0), w = prop(m, "max", 3, 100), I = prop(m, "step", 3, 1), P = prop(m, "value", 15, 1);
  var F = root$3(), D = child(F), U = child(D), Z = sibling(D, 2);
  template_effect(() => {
    set_text(U, `${m.label ?? ""}:`), set_attribute(Z, "min", g()), set_attribute(Z, "max", w()), set_attribute(Z, "step", I());
  }), bind_value(Z, P), append(d, F), pop();
}
const RMPosition = {
  Bomb: { y: 0, x: 0 },
  Cut: { y: 0, x: 1 },
  Elec: { y: 0, x: 2 },
  Fire: { y: 0, x: 3 },
  Guts: { y: 0, x: 4 },
  Ice: { y: 0, x: 5 },
  Air: { y: 1, x: 0 },
  Bubble: { y: 1, x: 1 },
  Crash: { y: 1, x: 2 },
  Flash: { y: 1, x: 3 },
  Heat: { y: 1, x: 4 },
  Metal: { y: 1, x: 5 },
  Quick: { y: 1, x: 6 },
  Wood: { y: 1, x: 7 },
  Gemini: { y: 2, x: 0 },
  Hard: { y: 2, x: 1 },
  Magnet: { y: 2, x: 2 },
  Needle: { y: 2, x: 3 },
  Shadow: { y: 2, x: 4 },
  Snake: { y: 2, x: 5 },
  Spark: { y: 2, x: 6 },
  Top: { y: 2, x: 7 },
  Doc: { y: 2, x: 8 },
  Bright: { y: 3, x: 0 },
  Dive: { y: 3, x: 1 },
  Drill: { y: 3, x: 2 },
  Dust: { y: 3, x: 3 },
  Pharaoh: { y: 3, x: 4 },
  Ring: { y: 3, x: 5 },
  Skull: { y: 3, x: 6 },
  Toad: { y: 3, x: 7 },
  Charge: { y: 4, x: 0 },
  Crystal: { y: 4, x: 1 },
  Gravity: { y: 4, x: 2 },
  Gyro: { y: 4, x: 3 },
  Napalm: { y: 4, x: 4 },
  Star: { y: 4, x: 5 },
  Stone: { y: 4, x: 6 },
  Wave: { y: 4, x: 7 },
  Blizzard: { y: 5, x: 0 },
  Centaur: { y: 5, x: 1 },
  Flame: { y: 5, x: 2 },
  Knight: { y: 5, x: 3 },
  Plant: { y: 5, x: 4 },
  Tomahawk: { y: 5, x: 5 },
  Wind: { y: 5, x: 6 },
  Yamato: { y: 5, x: 7 }
}, MMGames = {
  MM1: 0,
  MM2: 1,
  MM3: 2,
  MM4: 3,
  MM5: 4,
  MM6: 5
};
var root_2$1 = /* @__PURE__ */ template('<option class="svelte-1hgcjs9"> </option>'), root_1$1 = /* @__PURE__ */ template('<optgroup class="svelte-1hgcjs9"></optgroup>'), root$2 = /* @__PURE__ */ template('<select class="input-bg svelte-1hgcjs9"></select>');
function RMSelectTag(d, m) {
  push(m, !0);
  let g = prop(m, "value", 15);
  function w() {
    let F = [];
    for (const D in MMGames)
      F.push({ game: D, row: MMGames[D] });
    return F;
  }
  function I(F) {
    let D = [];
    for (const U in RMPosition)
      RMPosition[U].y == F && D.push(U);
    return D;
  }
  var P = root$2();
  each(P, 21, w, index, (F, D) => {
    let U = () => get(D).game, Z = () => get(D).row;
    var $ = root_1$1();
    each($, 21, () => I(Z()), index, (j, G) => {
      var Q = root_2$1(), H = {}, W = child(Q);
      template_effect(() => {
        H !== (H = get(G)) && (Q.value = (Q.__value = get(G)) ?? ""), set_text(W, get(G));
      }), append(j, Q);
    }), template_effect(() => set_attribute($, "label", U())), append(F, $);
  }), bind_select_value(P, g), append(d, P), pop();
}
var root$1 = /* @__PURE__ */ template('<article class="flex surface-4 svelte-doaxay"><img class="svelte-doaxay"> <div><p> </p> <!></div> <div><!></div> <div><!></div> <div><!></div></article>');
function PartTag(d, m) {
  push(m, !0);
  let g = prop(m, "thisPart", 15), w;
  user_effect(() => {
    var q, et;
    controller.isLoaded() && (((q = g().img) == null ? void 0 : q.bitmap.data.length) ?? !1) && ((et = g().img) == null || et.getBase64("image/png").then((rt) => w.src = rt));
  }), user_effect(() => {
    controller.isLoaded() && controller.drawRobotMaster();
  }), user_effect(() => {
    if (!controller.isLoaded()) return;
    let { x: q, y: et } = RMPosition[g().name];
    g(g().img = controller.getCroppedPart(g().type, q, et), !0);
  });
  var I = root$1(), P = child(I);
  bind_this(P, (q) => w = q, () => w);
  var F = sibling(P, 2), D = child(F), U = child(D), Z = sibling(D, 2);
  RMSelectTag(Z, {
    get value() {
      return g().name;
    },
    set value(q) {
      g(g().name = q, !0);
    }
  });
  var $ = sibling(F, 2), j = child($);
  NumberInput(j, {
    label: "X Position",
    min: 0,
    max: 63,
    get value() {
      return g().x;
    },
    set value(q) {
      g(g().x = q, !0);
    }
  });
  var G = sibling($, 2), Q = child(G);
  NumberInput(Q, {
    label: "Y Position",
    min: 0,
    max: 63,
    get value() {
      return g().y;
    },
    set value(q) {
      g(g().y = q, !0);
    }
  });
  var H = sibling(G, 2), W = child(H);
  ColorPicker(W, {
    get jimpo() {
      return g().img;
    },
    get selectedPart() {
      return g().type;
    }
  }), template_effect(() => {
    set_attribute(P, "alt", `${g().name}'s ${g().type}`), set_text(U, `${g().name}'s ${g().type}`);
  }), append(d, I), pop();
}
const helpSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="28px" height="28px" viewBox="0 -960 960 960" fill="#212529">\r
    <path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/>\r
</svg>`, outputSVG = `<svg xmlns="http://www.w3.org/2000/svg" height="28px" viewBox="0 -960 960 960" width="28px" fill="#212529">\r
    <path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v80h-80v-80H200v560h560v-80h80v80q0 33-23.5 56.5T760-120H200Zm480-160-56-56 103-104H360v-80h367L624-624l56-56 200 200-200 200Z"/>\r
</svg>`, buttonWithIcon = (d, m = noop, g = noop, w = noop) => {
  var I = root_1();
  I.__click = function(...F) {
    var D;
    (D = w()) == null || D.apply(this, F);
  };
  var P = child(I);
  html(P, m), template_effect(() => set_attribute(I, "aria-label", g())), append(d, I);
};
var root_1 = /* @__PURE__ */ template('<button class="surface-1 svelte-1t4r4p"><!></button>'), root_2 = /* @__PURE__ */ template('<li class="svelte-1t4r4p"><!></li>'), root_3 = /* @__PURE__ */ template('<li class="svelte-1t4r4p"><!></li>'), on_click = (d, m) => m()(), root_4 = /* @__PURE__ */ template('<div class="backdrop svelte-1t4r4p"></div>'), root = /* @__PURE__ */ template('<div class="rmm-container svelte-1t4r4p"><div class="flex svelte-1t4r4p"><div class="svelte-1t4r4p"><canvas width="64" height="64" class="svelte-1t4r4p"></canvas> <ul class="button-list svelte-1t4r4p"></ul></div> <ul class="parts svelte-1t4r4p"></ul></div></div> <!>', 1);
function RobotMasterMaker(d, m) {
  push(m, !1);
  let g = /* @__PURE__ */ mutable_source(), w = [
    {
      icon: helpSVG,
      desc: "Help",
      action: () => openInformationModal()
    },
    {
      icon: outputSVG,
      desc: "Export Robot Master",
      action: () => openExportModal()
    }
  ];
  onMount(async () => await controller.setup(get(g))), init$1();
  var I = root(), P = first_child(I), F = child(P), D = child(F), U = child(D);
  bind_this(U, (G) => set(g, G), () => get(g));
  var Z = sibling(U, 2);
  each(Z, 5, () => w, index, (G, Q) => {
    var H = root_2(), W = child(H);
    buttonWithIcon(W, () => get(Q).icon, () => get(Q).desc, () => get(Q).action), append(G, H);
  });
  var $ = sibling(D, 2);
  each($, 5, () => controller.getPartsInOrder(), index, (G, Q) => {
    var H = root_3(), W = child(H);
    PartTag(W, {
      get thisPart() {
        return get(Q);
      }
    }), append(G, H);
  });
  var j = sibling(P, 2);
  Modals(j, { backdrop: (Q, H) => {
    let W = () => H == null ? void 0 : H().close;
    var q = root_4();
    q.__click = [on_click, W], append(Q, q);
  }, $$slots: { backdrop: !0 } }), append(d, I), pop();
}
delegate(["click"]);
function startRMM(d) {
  mount(RobotMasterMaker, { target: d });
}
export {
  startRMM
};
